{"ast":null,"code":"/*\n@license\nThe MIT License (MIT)\n\nCopyright (c) 2016 Twilio Inc.\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n\n*/\n'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nvar _asyncToGenerator = require('@babel/runtime/helpers/asyncToGenerator');\nvar _classCallCheck = require('@babel/runtime/helpers/classCallCheck');\nvar _createClass = require('@babel/runtime/helpers/createClass');\nvar _inherits = require('@babel/runtime/helpers/inherits');\nvar _possibleConstructorReturn = require('@babel/runtime/helpers/possibleConstructorReturn');\nvar _getPrototypeOf = require('@babel/runtime/helpers/getPrototypeOf');\nvar _regeneratorRuntime = require('@babel/runtime/regenerator');\nrequire('core-js/modules/web.dom-collections.iterator.js');\nvar _typeof = require('@babel/runtime/helpers/typeof');\nvar twilsock = require('twilsock');\nvar _assertThisInitialized = require('@babel/runtime/helpers/assertThisInitialized');\nvar _defineProperty = require('@babel/runtime/helpers/defineProperty');\nvar operationRetrier = require('@twilio/operation-retrier');\nvar _slicedToArray = require('@babel/runtime/helpers/slicedToArray');\nvar _toConsumableArray = require('@babel/runtime/helpers/toConsumableArray');\nvar logger = require('loglevel');\nvar uuid = require('uuid');\nvar declarativeTypeValidator = require('@twilio/declarative-type-validator');\nfunction _interopDefaultLegacy(e) {\n  return e && typeof e === 'object' && 'default' in e ? e : {\n    'default': e\n  };\n}\nfunction _interopNamespace(e) {\n  if (e && e.__esModule) return e;\n  var n = Object.create(null);\n  if (e) {\n    Object.keys(e).forEach(function (k) {\n      if (k !== 'default') {\n        var d = Object.getOwnPropertyDescriptor(e, k);\n        Object.defineProperty(n, k, d.get ? d : {\n          enumerable: true,\n          get: function () {\n            return e[k];\n          }\n        });\n      }\n    });\n  }\n  n['default'] = e;\n  return Object.freeze(n);\n}\nvar _asyncToGenerator__default = /*#__PURE__*/_interopDefaultLegacy(_asyncToGenerator);\nvar _classCallCheck__default = /*#__PURE__*/_interopDefaultLegacy(_classCallCheck);\nvar _createClass__default = /*#__PURE__*/_interopDefaultLegacy(_createClass);\nvar _inherits__default = /*#__PURE__*/_interopDefaultLegacy(_inherits);\nvar _possibleConstructorReturn__default = /*#__PURE__*/_interopDefaultLegacy(_possibleConstructorReturn);\nvar _getPrototypeOf__default = /*#__PURE__*/_interopDefaultLegacy(_getPrototypeOf);\nvar _regeneratorRuntime__default = /*#__PURE__*/_interopDefaultLegacy(_regeneratorRuntime);\nvar _typeof__default = /*#__PURE__*/_interopDefaultLegacy(_typeof);\nvar _assertThisInitialized__default = /*#__PURE__*/_interopDefaultLegacy(_assertThisInitialized);\nvar _defineProperty__default = /*#__PURE__*/_interopDefaultLegacy(_defineProperty);\nvar _slicedToArray__default = /*#__PURE__*/_interopDefaultLegacy(_slicedToArray);\nvar _toConsumableArray__default = /*#__PURE__*/_interopDefaultLegacy(_toConsumableArray);\nvar logger__namespace = /*#__PURE__*/_interopNamespace(logger);\nvar uuid__namespace = /*#__PURE__*/_interopNamespace(uuid);\nfunction __decorate(decorators, target, key, desc) {\n  var c = arguments.length,\n    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n    d;\n  if ((typeof Reflect === \"undefined\" ? \"undefined\" : _typeof__default['default'](Reflect)) === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {\n    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  }\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n}\nfunction __metadata(metadataKey, metadataValue) {\n  if ((typeof Reflect === \"undefined\" ? \"undefined\" : _typeof__default['default'](Reflect)) === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\n}\nvar domain;\n\n// This constructor is used to store event handlers. Instantiating this is\n// faster than explicitly calling `Object.create(null)` to get a \"clean\" empty\n// object (tested with v8 v4.9).\nfunction EventHandlers() {}\nEventHandlers.prototype = Object.create(null);\nfunction EventEmitter() {\n  EventEmitter.init.call(this);\n}\n\n// nodejs oddity\n// require('events') === require('events').EventEmitter\nEventEmitter.EventEmitter = EventEmitter;\nEventEmitter.usingDomains = false;\nEventEmitter.prototype.domain = undefined;\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nEventEmitter.defaultMaxListeners = 10;\nEventEmitter.init = function () {\n  this.domain = null;\n  if (EventEmitter.usingDomains) {\n    // if there is an active domain, then attach to it.\n    if (domain.active) ;\n  }\n  if (!this._events || this._events === Object.getPrototypeOf(this)._events) {\n    this._events = new EventHandlers();\n    this._eventsCount = 0;\n  }\n  this._maxListeners = this._maxListeners || undefined;\n};\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\n  if (typeof n !== 'number' || n < 0 || isNaN(n)) throw new TypeError('\"n\" argument must be a positive number');\n  this._maxListeners = n;\n  return this;\n};\nfunction $getMaxListeners(that) {\n  if (that._maxListeners === undefined) return EventEmitter.defaultMaxListeners;\n  return that._maxListeners;\n}\nEventEmitter.prototype.getMaxListeners = function getMaxListeners() {\n  return $getMaxListeners(this);\n};\n\n// These standalone emit* functions are used to optimize calling of event\n// handlers for fast cases because emit() itself often has a variable number of\n// arguments and can be deoptimized because of that. These functions always have\n// the same number of arguments and thus do not get deoptimized, so the code\n// inside them can execute faster.\nfunction emitNone(handler, isFn, self) {\n  if (isFn) handler.call(self);else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i) listeners[i].call(self);\n  }\n}\nfunction emitOne(handler, isFn, self, arg1) {\n  if (isFn) handler.call(self, arg1);else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i) listeners[i].call(self, arg1);\n  }\n}\nfunction emitTwo(handler, isFn, self, arg1, arg2) {\n  if (isFn) handler.call(self, arg1, arg2);else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i) listeners[i].call(self, arg1, arg2);\n  }\n}\nfunction emitThree(handler, isFn, self, arg1, arg2, arg3) {\n  if (isFn) handler.call(self, arg1, arg2, arg3);else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i) listeners[i].call(self, arg1, arg2, arg3);\n  }\n}\nfunction emitMany(handler, isFn, self, args) {\n  if (isFn) handler.apply(self, args);else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i) listeners[i].apply(self, args);\n  }\n}\nEventEmitter.prototype.emit = function emit(type) {\n  var er, handler, len, args, i, events, domain;\n  var doError = type === 'error';\n  events = this._events;\n  if (events) doError = doError && events.error == null;else if (!doError) return false;\n  domain = this.domain;\n\n  // If there is no 'error' event listener then throw.\n  if (doError) {\n    er = arguments[1];\n    if (domain) {\n      if (!er) er = new Error('Uncaught, unspecified \"error\" event');\n      er.domainEmitter = this;\n      er.domain = domain;\n      er.domainThrown = false;\n      domain.emit('error', er);\n    } else if (er instanceof Error) {\n      throw er; // Unhandled 'error' event\n    } else {\n      // At least give some kind of context to the user\n      var err = new Error('Uncaught, unspecified \"error\" event. (' + er + ')');\n      err.context = er;\n      throw err;\n    }\n    return false;\n  }\n  handler = events[type];\n  if (!handler) return false;\n  var isFn = typeof handler === 'function';\n  len = arguments.length;\n  switch (len) {\n    // fast cases\n    case 1:\n      emitNone(handler, isFn, this);\n      break;\n    case 2:\n      emitOne(handler, isFn, this, arguments[1]);\n      break;\n    case 3:\n      emitTwo(handler, isFn, this, arguments[1], arguments[2]);\n      break;\n    case 4:\n      emitThree(handler, isFn, this, arguments[1], arguments[2], arguments[3]);\n      break;\n    // slower\n    default:\n      args = new Array(len - 1);\n      for (i = 1; i < len; i++) args[i - 1] = arguments[i];\n      emitMany(handler, isFn, this, args);\n  }\n  return true;\n};\nfunction _addListener(target, type, listener, prepend) {\n  var m;\n  var events;\n  var existing;\n  if (typeof listener !== 'function') throw new TypeError('\"listener\" argument must be a function');\n  events = target._events;\n  if (!events) {\n    events = target._events = new EventHandlers();\n    target._eventsCount = 0;\n  } else {\n    // To avoid recursion in the case that type === \"newListener\"! Before\n    // adding it to the listeners, first emit \"newListener\".\n    if (events.newListener) {\n      target.emit('newListener', type, listener.listener ? listener.listener : listener);\n\n      // Re-assign `events` because a newListener handler could have caused the\n      // this._events to be assigned to a new object\n      events = target._events;\n    }\n    existing = events[type];\n  }\n  if (!existing) {\n    // Optimize the case of one listener. Don't need the extra array object.\n    existing = events[type] = listener;\n    ++target._eventsCount;\n  } else {\n    if (typeof existing === 'function') {\n      // Adding the second element, need to change to array.\n      existing = events[type] = prepend ? [listener, existing] : [existing, listener];\n    } else {\n      // If we've already got an array, just append.\n      if (prepend) {\n        existing.unshift(listener);\n      } else {\n        existing.push(listener);\n      }\n    }\n\n    // Check for listener leak\n    if (!existing.warned) {\n      m = $getMaxListeners(target);\n      if (m && m > 0 && existing.length > m) {\n        existing.warned = true;\n        var w = new Error('Possible EventEmitter memory leak detected. ' + existing.length + ' ' + type + ' listeners added. ' + 'Use emitter.setMaxListeners() to increase limit');\n        w.name = 'MaxListenersExceededWarning';\n        w.emitter = target;\n        w.type = type;\n        w.count = existing.length;\n        emitWarning(w);\n      }\n    }\n  }\n  return target;\n}\nfunction emitWarning(e) {\n  typeof console.warn === 'function' ? console.warn(e) : console.log(e);\n}\nEventEmitter.prototype.addListener = function addListener(type, listener) {\n  return _addListener(this, type, listener, false);\n};\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\nEventEmitter.prototype.prependListener = function prependListener(type, listener) {\n  return _addListener(this, type, listener, true);\n};\nfunction _onceWrap(target, type, listener) {\n  var fired = false;\n  function g() {\n    target.removeListener(type, g);\n    if (!fired) {\n      fired = true;\n      listener.apply(target, arguments);\n    }\n  }\n  g.listener = listener;\n  return g;\n}\nEventEmitter.prototype.once = function once(type, listener) {\n  if (typeof listener !== 'function') throw new TypeError('\"listener\" argument must be a function');\n  this.on(type, _onceWrap(this, type, listener));\n  return this;\n};\nEventEmitter.prototype.prependOnceListener = function prependOnceListener(type, listener) {\n  if (typeof listener !== 'function') throw new TypeError('\"listener\" argument must be a function');\n  this.prependListener(type, _onceWrap(this, type, listener));\n  return this;\n};\n\n// emits a 'removeListener' event iff the listener was removed\nEventEmitter.prototype.removeListener = function removeListener(type, listener) {\n  var list, events, position, i, originalListener;\n  if (typeof listener !== 'function') throw new TypeError('\"listener\" argument must be a function');\n  events = this._events;\n  if (!events) return this;\n  list = events[type];\n  if (!list) return this;\n  if (list === listener || list.listener && list.listener === listener) {\n    if (--this._eventsCount === 0) this._events = new EventHandlers();else {\n      delete events[type];\n      if (events.removeListener) this.emit('removeListener', type, list.listener || listener);\n    }\n  } else if (typeof list !== 'function') {\n    position = -1;\n    for (i = list.length; i-- > 0;) {\n      if (list[i] === listener || list[i].listener && list[i].listener === listener) {\n        originalListener = list[i].listener;\n        position = i;\n        break;\n      }\n    }\n    if (position < 0) return this;\n    if (list.length === 1) {\n      list[0] = undefined;\n      if (--this._eventsCount === 0) {\n        this._events = new EventHandlers();\n        return this;\n      } else {\n        delete events[type];\n      }\n    } else {\n      spliceOne(list, position);\n    }\n    if (events.removeListener) this.emit('removeListener', type, originalListener || listener);\n  }\n  return this;\n};\n\n// Alias for removeListener added in NodeJS 10.0\n// https://nodejs.org/api/events.html#events_emitter_off_eventname_listener\nEventEmitter.prototype.off = function (type, listener) {\n  return this.removeListener(type, listener);\n};\nEventEmitter.prototype.removeAllListeners = function removeAllListeners(type) {\n  var listeners, events;\n  events = this._events;\n  if (!events) return this;\n\n  // not listening for removeListener, no need to emit\n  if (!events.removeListener) {\n    if (arguments.length === 0) {\n      this._events = new EventHandlers();\n      this._eventsCount = 0;\n    } else if (events[type]) {\n      if (--this._eventsCount === 0) this._events = new EventHandlers();else delete events[type];\n    }\n    return this;\n  }\n\n  // emit removeListener for all listeners on all events\n  if (arguments.length === 0) {\n    var keys = Object.keys(events);\n    for (var i = 0, key; i < keys.length; ++i) {\n      key = keys[i];\n      if (key === 'removeListener') continue;\n      this.removeAllListeners(key);\n    }\n    this.removeAllListeners('removeListener');\n    this._events = new EventHandlers();\n    this._eventsCount = 0;\n    return this;\n  }\n  listeners = events[type];\n  if (typeof listeners === 'function') {\n    this.removeListener(type, listeners);\n  } else if (listeners) {\n    // LIFO order\n    do {\n      this.removeListener(type, listeners[listeners.length - 1]);\n    } while (listeners[0]);\n  }\n  return this;\n};\nEventEmitter.prototype.listeners = function listeners(type) {\n  var evlistener;\n  var ret;\n  var events = this._events;\n  if (!events) ret = [];else {\n    evlistener = events[type];\n    if (!evlistener) ret = [];else if (typeof evlistener === 'function') ret = [evlistener.listener || evlistener];else ret = unwrapListeners(evlistener);\n  }\n  return ret;\n};\nEventEmitter.listenerCount = function (emitter, type) {\n  if (typeof emitter.listenerCount === 'function') {\n    return emitter.listenerCount(type);\n  } else {\n    return listenerCount.call(emitter, type);\n  }\n};\nEventEmitter.prototype.listenerCount = listenerCount;\nfunction listenerCount(type) {\n  var events = this._events;\n  if (events) {\n    var evlistener = events[type];\n    if (typeof evlistener === 'function') {\n      return 1;\n    } else if (evlistener) {\n      return evlistener.length;\n    }\n  }\n  return 0;\n}\nEventEmitter.prototype.eventNames = function eventNames() {\n  return this._eventsCount > 0 ? Reflect.ownKeys(this._events) : [];\n};\n\n// About 1.5x faster than the two-arg version of Array#splice().\nfunction spliceOne(list, index) {\n  for (var i = index, k = i + 1, n = list.length; k < n; i += 1, k += 1) list[i] = list[k];\n  list.pop();\n}\nfunction arrayClone(arr, i) {\n  var copy = new Array(i);\n  while (i--) copy[i] = arr[i];\n  return copy;\n}\nfunction unwrapListeners(arr) {\n  var ret = new Array(arr.length);\n  for (var i = 0; i < ret.length; ++i) {\n    ret[i] = arr[i].listener || arr[i];\n  }\n  return ret;\n}\nvar log = logger__namespace.getLogger(\"twilio-notificatiions\");\nfunction prepareLine(prefix, args) {\n  return [\"\".concat(new Date().toISOString(), \" Twilio.Notifications \").concat(prefix, \":\")].concat(Array.from(args));\n}\nvar Logger = /*#__PURE__*/function () {\n  function Logger() {\n    _classCallCheck__default['default'](this, Logger);\n  }\n  _createClass__default['default'](Logger, [{\n    key: \"setLevel\",\n    value: function setLevel(level) {\n      log.setLevel(level);\n    }\n  }, {\n    key: \"trace\",\n    value: function trace() {\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n      log.trace.apply(null, prepareLine(\"T\", args));\n    }\n  }, {\n    key: \"debug\",\n    value: function debug() {\n      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n      }\n      log.debug.apply(null, prepareLine(\"D\", args));\n    }\n  }, {\n    key: \"info\",\n    value: function info() {\n      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n        args[_key3] = arguments[_key3];\n      }\n      log.info.apply(null, prepareLine(\"I\", args));\n    }\n  }, {\n    key: \"warn\",\n    value: function warn() {\n      for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n        args[_key4] = arguments[_key4];\n      }\n      log.warn.apply(null, prepareLine(\"W\", args));\n    }\n  }, {\n    key: \"error\",\n    value: function error() {\n      for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {\n        args[_key5] = arguments[_key5];\n      }\n      log.error.apply(null, prepareLine(\"E\", args));\n    }\n  }]);\n  return Logger;\n}();\nvar logInstance = new Logger();\nfunction _createSuper$3(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct$3();\n  return function _createSuperInternal() {\n    var Super = _getPrototypeOf__default['default'](Derived),\n      result;\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf__default['default'](this).constructor;\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n    return _possibleConstructorReturn__default['default'](this, result);\n  };\n}\nfunction _isNativeReflectConstruct$3() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n  try {\n    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\nvar RegistrationState = function RegistrationState() {\n  var token = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n  var notificationId = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"\";\n  var messageTypes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new Set();\n  _classCallCheck__default['default'](this, RegistrationState);\n  this.token = token;\n  this.notificationId = notificationId;\n  this.messageTypes = messageTypes;\n};\nfunction setDifference(a, b) {\n  return [].concat(_toConsumableArray__default['default'](_toConsumableArray__default['default'](a).filter(function (x) {\n    return !b.has(x);\n  })), _toConsumableArray__default['default'](_toConsumableArray__default['default'](b).filter(function (x) {\n    return !a.has(x);\n  })));\n}\nfunction hasDifference(a, b) {\n  var reasons = new Set();\n  if (a.notificationId !== b.notificationId) {\n    reasons.add(\"notificationId\");\n  }\n  if (a.token !== b.token) {\n    reasons.add(\"token\");\n  }\n  if (setDifference(a.messageTypes, b.messageTypes).length > 0) {\n    reasons.add(\"messageType\");\n  }\n  return [reasons.size > 0, reasons];\n}\nvar Connector = /*#__PURE__*/function (_EventEmitter) {\n  _inherits__default['default'](Connector, _EventEmitter);\n  var _super = _createSuper$3(Connector);\n\n  // @todo replace with FSM\n  function Connector(channelType) {\n    var _this;\n    _classCallCheck__default['default'](this, Connector);\n    _this = _super.call(this);\n    _defineProperty__default['default'](_assertThisInitialized__default['default'](_this), \"desiredState\", new RegistrationState());\n    _defineProperty__default['default'](_assertThisInitialized__default['default'](_this), \"currentState\", new RegistrationState());\n    _defineProperty__default['default'](_assertThisInitialized__default['default'](_this), \"_hasActiveAttempt\", false);\n    _this.channelType = channelType;\n    return _this;\n  }\n  /**\n   * Set desired notification ID for the registration.\n   * Call commitChanges() afterwards to commit this change.\n   * @param notificationId Notification context ID to register.\n   */\n\n  _createClass__default['default'](Connector, [{\n    key: \"setNotificationId\",\n    value: function setNotificationId(notificationId) {\n      this.desiredState.notificationId = notificationId;\n    }\n    /**\n     * Return true is this connector is in usable state and should be able to commit changes.\n     */\n  }, {\n    key: \"isActive\",\n    value: function isActive() {\n      return this.desiredState.notificationId !== \"\";\n    }\n  }, {\n    key: \"subscribe\",\n    value: function subscribe(messageType) {\n      if (this.desiredState.messageTypes.has(messageType)) {\n        logInstance.debug(\"message type '\".concat(messageType, \"' for channel \").concat(this.channelType, \" is already registered\"));\n        return;\n      }\n      this.desiredState.messageTypes.add(messageType);\n    }\n  }, {\n    key: \"unsubscribe\",\n    value: function unsubscribe(messageType) {\n      if (!this.desiredState.messageTypes.has(messageType)) {\n        return;\n      }\n      this.desiredState.messageTypes.delete(messageType);\n    }\n  }, {\n    key: \"updateToken\",\n    value: function updateToken(token) {\n      // @todo not entirely correct?\n      this.desiredState.token = token;\n    }\n    /**\n     * Perform actual registration after all required changes are settled.\n     */\n  }, {\n    key: \"commitChanges\",\n    value: function () {\n      var _commitChanges = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee() {\n        var _hasDifference, _hasDifference2, needToUpdate, reasons, stateToPersist, persistedState;\n        return _regeneratorRuntime__default['default'].wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                if (!this._hasActiveAttempt) {\n                  _context.next = 3;\n                  break;\n                }\n\n                // Concurrent access violation\n                logInstance.error(\"One registration attempt is already in progress\");\n                throw new Error(\"One registration attempt is already in progress\");\n              case 3:\n                _hasDifference = hasDifference(this.desiredState, this.currentState), _hasDifference2 = _slicedToArray__default['default'](_hasDifference, 2), needToUpdate = _hasDifference2[0], reasons = _hasDifference2[1];\n                if (needToUpdate) {\n                  _context.next = 6;\n                  break;\n                }\n                return _context.abrupt(\"return\");\n              case 6:\n                if (!this.currentState.notificationId) {\n                  reasons.delete(\"notificationId\");\n                }\n                logInstance.trace(\"Persisting \".concat(this.channelType, \" registration\"), reasons, this.desiredState);\n                _context.prev = 8;\n                this._hasActiveAttempt = true;\n                stateToPersist = new RegistrationState();\n                stateToPersist.token = this.desiredState.token;\n                stateToPersist.notificationId = this.desiredState.notificationId;\n                stateToPersist.messageTypes = new Set(this.desiredState.messageTypes);\n                if (!(stateToPersist.messageTypes.size > 0)) {\n                  _context.next = 24;\n                  break;\n                }\n                _context.next = 17;\n                return this.updateRegistration(stateToPersist, reasons);\n              case 17:\n                persistedState = _context.sent;\n                this.currentState.token = persistedState.token;\n                this.currentState.notificationId = persistedState.notificationId;\n                this.currentState.messageTypes = new Set(persistedState.messageTypes); // @todo twilsock emits registered(notificationContextId) when this context is reg'd\n\n                this.emit(\"stateChanged\", this.channelType, \"registered\", this.currentState);\n                _context.next = 30;\n                break;\n              case 24:\n                _context.next = 26;\n                return this.removeRegistration();\n              case 26:\n                this.currentState.token = stateToPersist.token;\n                this.currentState.notificationId = stateToPersist.notificationId;\n                this.currentState.messageTypes.clear();\n                this.emit(\"stateChanged\", this.channelType, \"unregistered\", this.currentState);\n              case 30:\n                _context.next = 35;\n                break;\n              case 32:\n                _context.prev = 32;\n                _context.t0 = _context[\"catch\"](8);\n                throw _context.t0;\n              case 35:\n                _context.prev = 35;\n                this._hasActiveAttempt = false;\n                return _context.finish(35);\n              case 38:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this, [[8, 32, 35, 38]]);\n      }));\n      function commitChanges() {\n        return _commitChanges.apply(this, arguments);\n      }\n      return commitChanges;\n    }()\n  }]);\n  return Connector;\n}(EventEmitter);\nfunction _createSuper$2(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct$2();\n  return function _createSuperInternal() {\n    var Super = _getPrototypeOf__default['default'](Derived),\n      result;\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf__default['default'](this).constructor;\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n    return _possibleConstructorReturn__default['default'](this, result);\n  };\n}\nfunction _isNativeReflectConstruct$2() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n  try {\n    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\nvar retrierConfig = {\n  min: 2000,\n  max: 120000,\n  randomness: 0.2\n};\n/**\n * Manages the registrations on ERS service.\n * Deduplicates registrations and manages them automatically.\n */\n\nvar RegistrarConnector = /*#__PURE__*/function (_Connector) {\n  _inherits__default['default'](RegistrarConnector, _Connector);\n  var _super = _createSuper$2(RegistrarConnector);\n\n  /**\n   * Creates new instance of the ERS registrar\n   *\n   * @param channelType {string} Channel this connector will be servicing.\n   * @param context {any} productId, platform, and protocolVersion.\n   * @param twilsock {TwilsockClient} connection transport.\n   * @param registrarUrl {string}\n   */\n  function RegistrarConnector(channelType, context,\n  // context is separate from config because it's not shared with other connectors\n  twilsock, registrarUrl) {\n    var _this;\n    _classCallCheck__default['default'](this, RegistrarConnector);\n    _this = _super.call(this, channelType);\n    _defineProperty__default['default'](_assertThisInitialized__default['default'](_this), \"registrationId\", null);\n    _this.context = context;\n    _this.twilsock = twilsock;\n    _this.registrarUrl = registrarUrl;\n    return _this;\n  }\n  _createClass__default['default'](RegistrarConnector, [{\n    key: \"updateRegistration\",\n    value: function () {\n      var _updateRegistration = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee(registration, reasons) {\n        var _this2 = this;\n        var registrarRequest, productId, url, headers, response;\n        return _regeneratorRuntime__default['default'].wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                if (!reasons.has(\"notificationId\")) {\n                  _context.next = 3;\n                  break;\n                }\n                _context.next = 3;\n                return this.removeRegistration();\n              case 3:\n                if (!(!registration.notificationId || !registration.notificationId.length)) {\n                  _context.next = 6;\n                  break;\n                }\n                logInstance.error(\"No push notification ID for registration\");\n                throw new Error(\"No push notification ID for registration\");\n              case 6:\n                logInstance.trace(\"Registering\", this.channelType, registration);\n                registrarRequest = {\n                  endpoint_platform: this.context.platform,\n                  channel_type: this.channelType,\n                  version: this.context.protocolVersion.toString(),\n                  message_types: Array.from(registration.messageTypes),\n                  data: {\n                    registration_id: registration.notificationId\n                  } //ttl: 'PT24H' - This is totally ignored by notify, all bindings use PT1Y ttl.\n                };\n                productId = this.context.productId;\n                url = \"\".concat(this.registrarUrl, \"?productId=\").concat(productId);\n                headers = {\n                  \"Content-Type\": \"application/json\" // 'X-Twilio-Token': registration.token\n                };\n                logInstance.trace(\"Creating registration for channel \".concat(this.channelType));\n                _context.prev = 12;\n                _context.next = 15;\n                return new operationRetrier.AsyncRetrier(retrierConfig).run(function () {\n                  return _this2.twilsock.post(url, headers, registrarRequest, productId);\n                });\n              case 15:\n                response = _context.sent;\n                this.registrationId = response.body.id;\n                logInstance.debug(\"Registration created: \", response);\n                _context.next = 24;\n                break;\n              case 20:\n                _context.prev = 20;\n                _context.t0 = _context[\"catch\"](12);\n                logInstance.error(\"Registration failed: \", _context.t0);\n                throw _context.t0;\n              case 24:\n                return _context.abrupt(\"return\", registration);\n              case 25:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this, [[12, 20]]);\n      }));\n      function updateRegistration(_x, _x2) {\n        return _updateRegistration.apply(this, arguments);\n      }\n      return updateRegistration;\n    }()\n  }, {\n    key: \"removeRegistration\",\n    value: function () {\n      var _removeRegistration = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee2() {\n        var _this3 = this;\n        var productId, url, headers;\n        return _regeneratorRuntime__default['default'].wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                if (this.registrationId) {\n                  _context2.next = 2;\n                  break;\n                }\n                return _context2.abrupt(\"return\");\n              case 2:\n                productId = this.context.productId;\n                url = \"\".concat(this.registrarUrl, \"/\").concat(this.registrationId, \"?productId=\").concat(productId);\n                headers = {\n                  \"Content-Type\": \"application/json\" // 'X-Twilio-Token': this.config.token\n                };\n                logInstance.trace(\"Removing registration for \".concat(this.channelType));\n                _context2.prev = 6;\n                _context2.next = 9;\n                return new operationRetrier.AsyncRetrier(Object.assign(retrierConfig, {\n                  maxAttemptsCount: 3\n                })).run(function () {\n                  return _this3.twilsock.delete(url, headers, {}, productId);\n                });\n              case 9:\n                this.registrationId = null;\n                this.currentState.notificationId = \"\";\n                logInstance.debug(\"Registration removed for \".concat(this.channelType));\n                _context2.next = 18;\n                break;\n              case 14:\n                _context2.prev = 14;\n                _context2.t0 = _context2[\"catch\"](6);\n                logInstance.error(\"Failed to remove registration \", this.channelType, _context2.t0);\n                throw _context2.t0;\n              case 18:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this, [[6, 14]]);\n      }));\n      function removeRegistration() {\n        return _removeRegistration.apply(this, arguments);\n      }\n      return removeRegistration;\n    }()\n  }, {\n    key: \"sendDeviceRemoveRequest\",\n    value: function () {\n      var _sendDeviceRemoveRequest = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee3(registrationId) {\n        var _this4 = this;\n        var productId, url, headers, payload;\n        return _regeneratorRuntime__default['default'].wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                if (!(registrationId === \"\")) {\n                  _context3.next = 2;\n                  break;\n                }\n                throw new Error(\"Empty registration ID\");\n              case 2:\n                productId = this.context.productId;\n                url = \"\".concat(this.registrarUrl, \"?productId=\").concat(productId);\n                headers = {\n                  \"Content-Type\": \"application/json\" // @todo Content-Length??\n                };\n                payload = {\n                  binding_type: this.channelType,\n                  address: registrationId\n                };\n                _context3.prev = 6;\n                logInstance.trace(\"Removing old registrations for \".concat(this.channelType));\n                _context3.next = 10;\n                return new operationRetrier.AsyncRetrier(Object.assign(retrierConfig, {\n                  maxAttemptsCount: 3\n                })).run(function () {\n                  return _this4.twilsock.delete(url, headers, payload, productId);\n                });\n              case 10:\n                this.registrationId = null;\n                this.currentState.notificationId = \"\";\n                logInstance.debug(\"Registration removed for \".concat(this.channelType));\n                _context3.next = 19;\n                break;\n              case 15:\n                _context3.prev = 15;\n                _context3.t0 = _context3[\"catch\"](6);\n                logInstance.error(\"Failed to remove registration \", this.channelType, _context3.t0);\n                throw _context3.t0;\n              case 19:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this, [[6, 15]]);\n      }));\n      function sendDeviceRemoveRequest(_x3) {\n        return _sendDeviceRemoveRequest.apply(this, arguments);\n      }\n      return sendDeviceRemoveRequest;\n    }()\n  }]);\n  return RegistrarConnector;\n}(Connector);\nfunction _createSuper$1(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct$1();\n  return function _createSuperInternal() {\n    var Super = _getPrototypeOf__default['default'](Derived),\n      result;\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf__default['default'](this).constructor;\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n    return _possibleConstructorReturn__default['default'](this, result);\n  };\n}\nfunction _isNativeReflectConstruct$1() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n  try {\n    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n/**\n * Registrar connector implementation for twilsock -- @todo Drop twilsock.connector COMPLETELY?!\n */\n\nvar TwilsockConnector = /*#__PURE__*/function (_Connector) {\n  _inherits__default['default'](TwilsockConnector, _Connector);\n  var _super = _createSuper$1(TwilsockConnector);\n\n  /**\n   * Create twilsock registration connector.\n   * @param productId product ID\n   * @param platform platform ID string\n   * @param twilsock {TwilsockClient} connection transport.\n   */\n  function TwilsockConnector(productId, platform, twilsock) {\n    var _this;\n    _classCallCheck__default['default'](this, TwilsockConnector);\n    _this = _super.call(this, \"twilsock\");\n    _defineProperty__default['default'](_assertThisInitialized__default['default'](_this), \"contextId\", uuid__namespace.v4());\n    _this.productId = productId;\n    _this.platform = platform;\n    _this.twilsock = twilsock;\n    return _this;\n  }\n  _createClass__default['default'](TwilsockConnector, [{\n    key: \"updateRegistration\",\n    value: function () {\n      var _updateRegistration = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee(registration, reasons) {\n        var messageTypes, context;\n        return _regeneratorRuntime__default['default'].wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                if (reasons.has(\"messageType\")) {\n                  _context.next = 2;\n                  break;\n                }\n                return _context.abrupt(\"return\", registration);\n              case 2:\n                messageTypes = Array.from(registration.messageTypes);\n                context = {\n                  product_id: this.productId,\n                  notification_protocol_version: 4,\n                  endpoint_platform: this.platform,\n                  message_types: messageTypes\n                };\n                _context.prev = 4;\n                _context.next = 7;\n                return this.twilsock.setNotificationsContext(this.contextId, context);\n              case 7:\n                _context.next = 13;\n                break;\n              case 9:\n                _context.prev = 9;\n                _context.t0 = _context[\"catch\"](4);\n                logInstance.error(\"Failed to update twilsock notification context: \".concat(_context.t0));\n                throw _context.t0;\n              case 13:\n                return _context.abrupt(\"return\", registration);\n              case 14:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this, [[4, 9]]);\n      }));\n      function updateRegistration(_x, _x2) {\n        return _updateRegistration.apply(this, arguments);\n      }\n      return updateRegistration;\n    }()\n  }, {\n    key: \"removeRegistration\",\n    value: function () {\n      var _removeRegistration = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee2() {\n        return _regeneratorRuntime__default['default'].wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                _context2.prev = 0;\n                _context2.next = 3;\n                return this.twilsock.removeNotificationsContext(this.contextId);\n              case 3:\n                _context2.next = 9;\n                break;\n              case 5:\n                _context2.prev = 5;\n                _context2.t0 = _context2[\"catch\"](0);\n                logInstance.error(\"Failed to remove twilsock notification context: \".concat(_context2.t0));\n                throw _context2.t0;\n              case 9:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this, [[0, 5]]);\n      }));\n      function removeRegistration() {\n        return _removeRegistration.apply(this, arguments);\n      }\n      return removeRegistration;\n    }() // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  }, {\n    key: \"sendDeviceRemoveRequest\",\n    value: function () {\n      var _sendDeviceRemoveRequest = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee3(registrationId) {\n        return _regeneratorRuntime__default['default'].wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3);\n      }));\n      function sendDeviceRemoveRequest(_x3) {\n        return _sendDeviceRemoveRequest.apply(this, arguments);\n      }\n      return sendDeviceRemoveRequest;\n    }()\n  }]);\n  return TwilsockConnector;\n}(Connector);\nfunction _createSuper(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct();\n  return function _createSuperInternal() {\n    var Super = _getPrototypeOf__default['default'](Derived),\n      result;\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf__default['default'](this).constructor;\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n    return _possibleConstructorReturn__default['default'](this, result);\n  };\n}\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n  try {\n    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\nvar Client_1;\nvar channelTypeRule = declarativeTypeValidator.literal(\"apn\", \"fcm\", \"twilsock\");\n/**\n * @class\n * @alias Notifications\n * @classdesc The helper library for the notification service.\n * Provides high level api for creating and managing notification subscriptions and receiving messages\n * Creates the instance of Notification helper library\n *\n * @constructor\n * @param {string} token - Twilio access token\n * @param {Notifications#ClientOptions} options - Options to customize client behavior\n *\n * @event stateChanged channelType (registered|unregistered) -- coming from connector, i.e. it's per-connector type!\n * @event transportState Forwarded from Twilsock's stateChanged event.\n * @event message Routed from twilsock as a notification event.\n */\n\nexports.Notifications = Client_1 = /*#__PURE__*/function (_EventEmitter) {\n  _inherits__default['default'](Client, _EventEmitter);\n  var _super = _createSuper(Client);\n  function Client(token) {\n    var _options$logLevel, _options$productId, _options$twilsockClie, _options$notification, _ref, _config$region;\n    var _this;\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    _classCallCheck__default['default'](this, Client);\n    _this = _super.call(this);\n    options.logLevel = (_options$logLevel = options.logLevel) !== null && _options$logLevel !== void 0 ? _options$logLevel : \"error\";\n    logInstance.setLevel(options.logLevel);\n    var productId = (_options$productId = options.productId) !== null && _options$productId !== void 0 ? _options$productId : \"notifications\";\n    var startTwilsock = !options.twilsockClient;\n    var twilsock$1 = options.twilsockClient = (_options$twilsockClie = options.twilsockClient) !== null && _options$twilsockClie !== void 0 ? _options$twilsockClie : new twilsock.TwilsockClient(token, productId, options);\n    var config = (_options$notification = options.notifications) !== null && _options$notification !== void 0 ? _options$notification : {};\n    var region = (_ref = (_config$region = config.region) !== null && _config$region !== void 0 ? _config$region : options.region) !== null && _ref !== void 0 ? _ref : \"us1\";\n    var defaultUrl = \"https://ers.\".concat(region, \".twilio.com/v1/registrations\");\n    var registrarUrl = config.ersUrl || defaultUrl;\n    _this.connectors = new Map();\n    var platform = Client_1._detectPlatform();\n    _this.connectors.set(\"apn\", new RegistrarConnector(\"apn\", {\n      protocolVersion: 4,\n      productId: productId,\n      platform: platform\n    }, twilsock$1, registrarUrl));\n    _this.connectors.set(\"fcm\", new RegistrarConnector(\"fcm\", {\n      protocolVersion: 3,\n      productId: productId,\n      platform: platform\n    }, twilsock$1, registrarUrl));\n    _this.connectors.set(\"twilsock\", new TwilsockConnector(productId, platform, twilsock$1));\n    twilsock$1.on(\"stateChanged\", function (state) {\n      return _this.emit(\"transportState\", state);\n    });\n    _this._connector(\"twilsock\").on(\"stateChanged\", function (type, value, state) {\n      return _this.emit(\"stateChanged\", type, value, state);\n    });\n    _this._connector(\"apn\").on(\"stateChanged\", function (type, value, state) {\n      return _this.emit(\"stateChanged\", type, value, state);\n    });\n    _this._connector(\"fcm\").on(\"stateChanged\", function (type, value, state) {\n      return _this.emit(\"stateChanged\", type, value, state);\n    }); // Router\n\n    twilsock$1.on(\"message\", function (type, message) {\n      return _this._routeMessage(type, message);\n    });\n    _this.updateToken(token); // Start only if we created twilsock locally,\n    // otherwise it's the responsibility of whoever created the Twilsock client.\n\n    if (startTwilsock) {\n      twilsock$1.connect();\n      _this.twilsock = twilsock$1;\n    }\n    return _this;\n  }\n  _createClass__default['default'](Client, [{\n    key: \"shutdown\",\n    value: function () {\n      var _shutdown = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee() {\n        return _regeneratorRuntime__default['default'].wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                this.connectors.clear();\n                if (!this.twilsock) {\n                  _context.next = 4;\n                  break;\n                }\n                _context.next = 4;\n                return this.twilsock.disconnect();\n              case 4:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n      function shutdown() {\n        return _shutdown.apply(this, arguments);\n      }\n      return shutdown;\n    }()\n    /**\n     * Set OS-provided APNS/FCM registration binding for the given channel type. Not used for 'twilsock'.\n     *\n     * You must call this function once you've received the ID of your device from the underlying OS.\n     *\n     * @param {ChannelType} channelType Channel type ('apn'/'fcm').\n     * @param {string} pushRegistrationId Token received from FCM/APNS system on device.\n     */\n  }, {\n    key: \"setPushRegistrationId\",\n    value: function setPushRegistrationId(channelType, pushRegistrationId) {\n      logInstance.debug(\"Set \".concat(channelType, \" push registration id '\").concat(pushRegistrationId, \"'\"));\n      this._connector(channelType).setNotificationId(pushRegistrationId);\n    }\n    /**\n     * Subscribe to a given message type for a given channel type.\n     *\n     * Creates a subscriptions to receive incoming messages according to message type.\n     * Subscription establishes a binding and you will receive a signal when a notification\n     * of this type has been received by the library.\n     *\n     * Subscribed binding is preserved for 1 year, after which time it needs to be re-subscribed.\n     * This is the responsibility of the client SDK.\n     *\n     * @param {ChannelType} channelType Supported are 'twilsock', 'apn' and 'fcm'\n     * @param {string} messageType The type of message that you want to receive\n     */\n  }, {\n    key: \"subscribe\",\n    value: function subscribe(channelType, messageType) {\n      logInstance.debug(\"Add \".concat(channelType, \" subscriptions for message type \").concat(messageType));\n      this._connector(channelType).subscribe(messageType);\n    }\n    /**\n     * Unsubscribe from a given message type.\n     *\n     * Unsubscribing breaks a binding and you will not receive more notifications for this message type.\n     * Please note that you have to call commitChanges() and receive a successful result before\n     * the subscription is actually removed.\n     *\n     * @param {ChannelType} channelType Supported are 'twilsock', 'apn' and 'fcm'\n     * @param {string} messageType The type of message that you don't want to receive anymore\n     */\n  }, {\n    key: \"unsubscribe\",\n    value: function unsubscribe(channelType, messageType) {\n      logInstance.debug(\"Remove \".concat(channelType, \" subscriptions for message type \").concat(messageType));\n      this._connector(channelType).unsubscribe(messageType);\n    }\n    /**\n     * Update subscription token. You must update the token when the old one expires.\n     *\n     * When you receive onTokenWillExpire event from twilsock, call this function with the new refreshed\n     * token _after_ you have updated twilsock and other associated objects with the new token.\n     *\n     * @param {string} token Authentication token for registrations\n     */\n  }, {\n    key: \"updateToken\",\n    value: function updateToken(token) {\n      this.connectors.forEach(function (connector) {\n        return connector.updateToken(token);\n      });\n    }\n    /**\n     * Commit all collected subscription changes as a batched update. This function tries to reduce\n     * number of network calls necessary to update bindings status.\n     */\n  }, {\n    key: \"commitChanges\",\n    value: function () {\n      var _commitChanges = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee2() {\n        var promises;\n        return _regeneratorRuntime__default['default'].wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                promises = [];\n                this.connectors.forEach(function (connector) {\n                  if (connector.isActive()) {\n                    promises.push(connector.commitChanges());\n                  }\n                });\n                _context2.next = 4;\n                return Promise.all(promises);\n              case 4:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n      function commitChanges() {\n        return _commitChanges.apply(this, arguments);\n      }\n      return commitChanges;\n    }()\n    /**\n     * Clear existing registrations directly using provided device token.\n     * This is useful to ensure stopped subscriptions without resubscribing.\n     *\n     * This function goes completely beside the state machine and removes all registrations.\n     * Use with caution: if it races with current state machine operations, madness will ensue.\n     *\n     * @param {ChannelType} channelType Channel type ('apn'/'fcm').\n     * @param {string} registrationId Token received from FCM/APNS system on device.\n     */\n  }, {\n    key: \"removeRegistrations\",\n    value: function () {\n      var _removeRegistrations = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee3(channelType, registrationId) {\n        return _regeneratorRuntime__default['default'].wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                _context3.next = 2;\n                return this._connector(channelType).sendDeviceRemoveRequest(registrationId);\n              case 2:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n      function removeRegistrations(_x, _x2) {\n        return _removeRegistrations.apply(this, arguments);\n      }\n      return removeRegistrations;\n    }()\n    /**\n     * Handle incoming push notification.\n     * Client application should call this method when it receives push notifications and pass the received data.\n     * @param {Object} message push message\n     * @return {PushNotification} A reformatted payload with extracted message type.\n     */\n  }, {\n    key: \"handlePushNotification\",\n    value: function handlePushNotification(message) {\n      return {\n        messageType: message.twi_message_type,\n        payload: message.payload\n      };\n    }\n    /**\n     * Routes messages to the external subscribers\n     */\n  }, {\n    key: \"_routeMessage\",\n    value: function _routeMessage(type, message) {\n      logInstance.debug(\"Notification message arrived: \", type, message);\n      this.emit(\"message\", type, message);\n    }\n    /**\n     * @param {String} type Channel type\n     * @throws {Error} Error with description\n     */\n  }, {\n    key: \"_connector\",\n    value: function _connector(type) {\n      var connector = this.connectors.get(type);\n      if (!connector) {\n        throw new Error(\"Unknown channel type: \".concat(type));\n      }\n      return connector;\n    }\n    /**\n     * Returns platform string limited to max 128 chars\n     */\n  }], [{\n    key: \"_detectPlatform\",\n    value: function _detectPlatform() {\n      var platform = \"\";\n      if (typeof navigator !== \"undefined\") {\n        platform = \"unknown\";\n        if (typeof navigator.product !== \"undefined\") {\n          platform = navigator.product;\n        }\n        if (typeof navigator.userAgent !== \"undefined\") {\n          platform = navigator.userAgent;\n        }\n      } else {\n        platform = \"web\";\n      }\n      return platform.substring(0, 128);\n    }\n  }]);\n  return Client;\n}(EventEmitter);\n__decorate([declarativeTypeValidator.validateTypes(channelTypeRule, declarativeTypeValidator.nonEmptyString), __metadata(\"design:type\", Function), __metadata(\"design:paramtypes\", [String, String]), __metadata(\"design:returntype\", void 0)], exports.Notifications.prototype, \"setPushRegistrationId\", null);\n__decorate([declarativeTypeValidator.validateTypes(channelTypeRule, declarativeTypeValidator.nonEmptyString), __metadata(\"design:type\", Function), __metadata(\"design:paramtypes\", [String, String]), __metadata(\"design:returntype\", void 0)], exports.Notifications.prototype, \"subscribe\", null);\n__decorate([declarativeTypeValidator.validateTypes(channelTypeRule, declarativeTypeValidator.nonEmptyString), __metadata(\"design:type\", Function), __metadata(\"design:paramtypes\", [String, String]), __metadata(\"design:returntype\", void 0)], exports.Notifications.prototype, \"unsubscribe\", null);\n__decorate([declarativeTypeValidator.validateTypes(declarativeTypeValidator.nonEmptyString), __metadata(\"design:type\", Function), __metadata(\"design:paramtypes\", [String]), __metadata(\"design:returntype\", void 0)], exports.Notifications.prototype, \"updateToken\", null);\n__decorate([declarativeTypeValidator.validateTypesAsync(channelTypeRule, declarativeTypeValidator.nonEmptyString), __metadata(\"design:type\", Function), __metadata(\"design:paramtypes\", [String, String]), __metadata(\"design:returntype\", Promise)], exports.Notifications.prototype, \"removeRegistrations\", null);\nexports.Notifications = Client_1 = __decorate([declarativeTypeValidator.validateConstructorTypes(declarativeTypeValidator.nonEmptyString, [declarativeTypeValidator.pureObject, \"undefined\", declarativeTypeValidator.literal(null)]), __metadata(\"design:paramtypes\", [String, Object])], exports.Notifications);","map":{"version":3,"sources":["../../../node_modules/tslib/tslib.es6.js","../src/logger.ts","../src/connector.ts","../src/RegistrarConnector.ts","../src/TwilsockConnector.ts","../src/client.ts"],"names":["__decorate","decorators","target","key","desc","c","arguments","length","r","Object","getOwnPropertyDescriptor","d","Reflect","decorate","i","defineProperty","__metadata","metadataKey","metadataValue","metadata","logger","AsyncRetrier","uuid","literal","validateConstructorTypes","nonEmptyString","pureObject","Client","twilsock","TwilsockClient","validateTypes","validateTypesAsync"],"mappings":"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","sourcesContent":["/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __createBinding(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (p !== \"default\" && !exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n};\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, privateMap) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to get private field on non-instance\");\r\n    }\r\n    return privateMap.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, privateMap, value) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to set private field on non-instance\");\r\n    }\r\n    privateMap.set(receiver, value);\r\n    return value;\r\n}\r\n","import * as logger from \"loglevel\";\n\nconst log = logger.getLogger(\"twilio-notificatiions\");\n\nfunction prepareLine(prefix, args) {\n  return [`${new Date().toISOString()} Twilio.Notifications ${prefix}:`].concat(\n    Array.from(args)\n  );\n}\n\nclass Logger {\n  setLevel(level: any): void {\n    log.setLevel(level as any);\n  }\n\n  trace(...args): void {\n    log.trace.apply(null, prepareLine(\"T\", args));\n  }\n  debug(...args): void {\n    log.debug.apply(null, prepareLine(\"D\", args));\n  }\n  info(...args): void {\n    log.info.apply(null, prepareLine(\"I\", args));\n  }\n  warn(...args): void {\n    log.warn.apply(null, prepareLine(\"W\", args));\n  }\n  error(...args): void {\n    log.error.apply(null, prepareLine(\"E\", args));\n  }\n}\n\nconst logInstance = new Logger();\n\nexport { Logger, logInstance as log };\n","import { EventEmitter } from \"events\";\nimport { log } from \"./logger\";\n\ntype ChannelType = \"twilsock\" | \"apn\" | \"fcm\";\n\ntype UpdateReason = \"token\" | \"notificationId\" | \"messageType\";\n\nclass RegistrationState {\n  constructor(\n    public token: string = \"\",\n    public notificationId: string = \"\",\n    public messageTypes: Set<string> = new Set<string>()\n  ) {}\n}\n\nfunction setDifference<T>(a: Set<T>, b: Set<T>): Array<T> {\n  return [\n    ...[...a].filter((x) => !b.has(x)),\n    ...[...b].filter((x) => !a.has(x)),\n  ];\n}\n\nfunction hasDifference(\n  a: RegistrationState,\n  b: RegistrationState\n): [boolean, Set<UpdateReason>] {\n  const reasons = new Set<UpdateReason>();\n  if (a.notificationId !== b.notificationId) {\n    reasons.add(\"notificationId\");\n  }\n\n  if (a.token !== b.token) {\n    reasons.add(\"token\");\n  }\n\n  if (setDifference(a.messageTypes, b.messageTypes).length > 0) {\n    reasons.add(\"messageType\");\n  }\n\n  return [reasons.size > 0, reasons];\n}\n\nabstract class Connector extends EventEmitter {\n  protected readonly desiredState: RegistrationState = new RegistrationState();\n  protected readonly currentState: RegistrationState = new RegistrationState();\n  private _hasActiveAttempt = false; // @todo replace with FSM\n\n  protected constructor(protected readonly channelType: ChannelType) {\n    super();\n  }\n\n  /**\n   * Set desired notification ID for the registration.\n   * Call commitChanges() afterwards to commit this change.\n   * @param notificationId Notification context ID to register.\n   */\n  public setNotificationId(notificationId: string): void {\n    this.desiredState.notificationId = notificationId;\n  }\n\n  /**\n   * Return true is this connector is in usable state and should be able to commit changes.\n   */\n  public isActive(): boolean {\n    return this.desiredState.notificationId !== \"\";\n  }\n\n  public subscribe(messageType: string): void {\n    if (this.desiredState.messageTypes.has(messageType)) {\n      log.debug(\n        `message type '${messageType}' for channel ${this.channelType} is already registered`\n      );\n      return;\n    }\n\n    this.desiredState.messageTypes.add(messageType);\n  }\n\n  public unsubscribe(messageType: string): void {\n    if (!this.desiredState.messageTypes.has(messageType)) {\n      return;\n    }\n\n    this.desiredState.messageTypes.delete(messageType);\n  }\n\n  public updateToken(token: string): void {\n    // @todo not entirely correct?\n    this.desiredState.token = token;\n  }\n\n  /**\n   * Perform actual registration after all required changes are settled.\n   */\n  public async commitChanges(): Promise<void> {\n    // if (!this.config.token || this.config.token.length === 0) { // @todo factor desiredState.token here?\n    //   log.trace(\"Can't persist registration: token is not set\");\n    //   return;\n    // }\n\n    if (this._hasActiveAttempt) {\n      // Concurrent access violation\n      log.error(\"One registration attempt is already in progress\");\n      throw new Error(\"One registration attempt is already in progress\");\n    }\n\n    const [needToUpdate, reasons] = hasDifference(\n      this.desiredState,\n      this.currentState\n    );\n    if (!needToUpdate) {\n      // The state did not change - complete successfully!\n      return;\n    }\n\n    if (!this.currentState.notificationId) {\n      reasons.delete(\"notificationId\");\n    }\n\n    log.trace(\n      `Persisting ${this.channelType} registration`,\n      reasons,\n      this.desiredState\n    );\n    try {\n      this._hasActiveAttempt = true;\n\n      const stateToPersist: RegistrationState = new RegistrationState();\n      stateToPersist.token = this.desiredState.token;\n      stateToPersist.notificationId = this.desiredState.notificationId;\n      stateToPersist.messageTypes = new Set(this.desiredState.messageTypes);\n\n      if (stateToPersist.messageTypes.size > 0) {\n        const persistedState = await this.updateRegistration(\n          stateToPersist,\n          reasons\n        );\n        this.currentState.token = persistedState.token;\n        this.currentState.notificationId = persistedState.notificationId;\n        this.currentState.messageTypes = new Set(persistedState.messageTypes);\n\n        // @todo twilsock emits registered(notificationContextId) when this context is reg'd\n        this.emit(\n          \"stateChanged\",\n          this.channelType,\n          \"registered\",\n          this.currentState\n        );\n      } else {\n        await this.removeRegistration();\n        this.currentState.token = stateToPersist.token;\n        this.currentState.notificationId = stateToPersist.notificationId;\n        this.currentState.messageTypes.clear();\n\n        this.emit(\n          \"stateChanged\",\n          this.channelType,\n          \"unregistered\",\n          this.currentState\n        );\n      }\n    } catch (e) {\n      throw e; // Forward any errors up\n    } finally {\n      this._hasActiveAttempt = false;\n    }\n  }\n\n  /**\n   * This one goes completely beside the state machine and removes all registrations.\n   * Use with caution: if it races with current state machine operations, madness will ensue.\n   */\n  public abstract sendDeviceRemoveRequest(\n    registrationId: string\n  ): Promise<void>;\n\n  protected abstract updateRegistration(\n    registration: RegistrationState,\n    reasons: Set<UpdateReason>\n  ): Promise<RegistrationState>;\n\n  protected abstract removeRegistration(): Promise<void>;\n}\n\nexport { UpdateReason, RegistrationState, ChannelType, Connector };\n","import { AsyncRetrier } from \"@twilio/operation-retrier\";\nimport {\n  UpdateReason,\n  RegistrationState,\n  Connector,\n  ChannelType,\n} from \"./connector\";\nimport { TwilsockClient } from \"twilsock\";\nimport { log } from \"./logger\";\n\nconst retrierConfig = {\n  min: 2000, // ms\n  max: 120000, // ms\n  randomness: 0.2,\n};\n\nexport interface RegistrarContext {\n  protocolVersion: number;\n  productId: string;\n  platform: string;\n}\n\n/**\n * Manages the registrations on ERS service.\n * Deduplicates registrations and manages them automatically.\n */\nclass RegistrarConnector extends Connector {\n  private registrationId: string | null = null;\n\n  /**\n   * Creates new instance of the ERS registrar\n   *\n   * @param channelType {string} Channel this connector will be servicing.\n   * @param context {any} productId, platform, and protocolVersion.\n   * @param twilsock {TwilsockClient} connection transport.\n   * @param registrarUrl {string}\n   */\n  constructor(\n    channelType: ChannelType,\n    private readonly context: RegistrarContext, // context is separate from config because it's not shared with other connectors\n    private readonly twilsock: TwilsockClient,\n    private readonly registrarUrl: string\n  ) {\n    super(channelType);\n  }\n\n  protected async updateRegistration(\n    registration: RegistrationState,\n    reasons: Set<UpdateReason>\n  ): Promise<RegistrationState> {\n    if (reasons.has(\"notificationId\")) {\n      await this.removeRegistration();\n    }\n\n    if (!registration.notificationId || !registration.notificationId.length) {\n      log.error(`No push notification ID for registration`);\n      throw new Error(`No push notification ID for registration`); // @todo FSM update to error perhaps\n    }\n\n    log.trace(\"Registering\", this.channelType, registration);\n\n    const registrarRequest = {\n      endpoint_platform: this.context.platform,\n      channel_type: this.channelType,\n      version: this.context.protocolVersion.toString(),\n      message_types: Array.from(registration.messageTypes),\n      data: {\n        registration_id: registration.notificationId,\n      },\n      //ttl: 'PT24H' - This is totally ignored by notify, all bindings use PT1Y ttl.\n    };\n\n    const productId = this.context.productId;\n\n    const url = `${this.registrarUrl}?productId=${productId}`;\n    const headers = {\n      \"Content-Type\": \"application/json\",\n      // 'X-Twilio-Token': registration.token\n    };\n\n    log.trace(`Creating registration for channel ${this.channelType}`);\n    try {\n      const response = (await new AsyncRetrier(retrierConfig).run(() =>\n        this.twilsock.post(url, headers, registrarRequest, productId)\n      )) as any;\n      this.registrationId = response.body.id;\n      log.debug(\"Registration created: \", response);\n    } catch (err) {\n      log.error(\"Registration failed: \", err);\n      throw err;\n    }\n\n    return registration;\n  }\n\n  protected async removeRegistration(): Promise<void> {\n    if (!this.registrationId) {\n      // No registration ID - no problem, finish successfully.\n      return;\n    }\n\n    const productId = this.context.productId;\n\n    const url = `${this.registrarUrl}/${this.registrationId}?productId=${productId}`;\n    const headers = {\n      \"Content-Type\": \"application/json\",\n      // 'X-Twilio-Token': this.config.token\n    };\n\n    log.trace(`Removing registration for ${this.channelType}`);\n    try {\n      await new AsyncRetrier(\n        Object.assign(retrierConfig, { maxAttemptsCount: 3 })\n      ).run(() => this.twilsock.delete(url, headers, {}, productId));\n      this.registrationId = null;\n      this.currentState.notificationId = \"\";\n      log.debug(`Registration removed for ${this.channelType}`);\n    } catch (err) {\n      log.error(\"Failed to remove registration \", this.channelType, err);\n      throw err;\n    }\n  }\n\n  public async sendDeviceRemoveRequest(registrationId: string): Promise<void> {\n    if (registrationId === \"\") {\n      throw new Error(\"Empty registration ID\");\n    }\n\n    const productId = this.context.productId;\n\n    const url = `${this.registrarUrl}?productId=${productId}`;\n    const headers = {\n      \"Content-Type\": \"application/json\",\n      // @todo Content-Length??\n    };\n    const payload = {\n      binding_type: this.channelType,\n      address: registrationId,\n    };\n\n    try {\n      log.trace(`Removing old registrations for ${this.channelType}`);\n      await new AsyncRetrier(\n        Object.assign(retrierConfig, { maxAttemptsCount: 3 })\n      ).run(() => this.twilsock.delete(url, headers, payload, productId));\n      this.registrationId = null;\n      this.currentState.notificationId = \"\";\n      log.debug(`Registration removed for ${this.channelType}`);\n    } catch (err) {\n      log.error(\"Failed to remove registration \", this.channelType, err);\n      throw err;\n    }\n  }\n}\n\nexport { Connector, RegistrarConnector };\n","import * as uuid from \"uuid\";\nimport { RegistrationState, UpdateReason, Connector } from \"./connector\";\nimport { TwilsockClient } from \"twilsock\";\nimport { log } from \"./logger\";\n\n/**\n * Registrar connector implementation for twilsock -- @todo Drop twilsock.connector COMPLETELY?!\n */\nclass TwilsockConnector extends Connector {\n  private readonly contextId: string = uuid.v4();\n  /**\n   * Create twilsock registration connector.\n   * @param productId product ID\n   * @param platform platform ID string\n   * @param twilsock {TwilsockClient} connection transport.\n   */\n  constructor(\n    private readonly productId: string,\n    private readonly platform: string,\n    private readonly twilsock: TwilsockClient\n  ) {\n    super(\"twilsock\");\n  }\n\n  protected async updateRegistration(\n    registration: RegistrationState,\n    reasons: Set<UpdateReason>\n  ): Promise<RegistrationState> {\n    if (!reasons.has(\"messageType\")) {\n      // No changed message types - it is fine, finish successfully.\n      return registration;\n    }\n\n    const messageTypes = Array.from(registration.messageTypes);\n\n    const context = {\n      product_id: this.productId,\n      notification_protocol_version: 4,\n      endpoint_platform: this.platform,\n      message_types: messageTypes,\n    };\n\n    try {\n      await this.twilsock.setNotificationsContext(this.contextId, context);\n    } catch (err) {\n      log.error(`Failed to update twilsock notification context: ${err}`);\n      throw err;\n    }\n\n    return registration;\n  }\n\n  protected async removeRegistration(): Promise<void> {\n    try {\n      await this.twilsock.removeNotificationsContext(this.contextId);\n    } catch (err) {\n      log.error(`Failed to remove twilsock notification context: ${err}`);\n      throw err;\n    }\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  public async sendDeviceRemoveRequest(registrationId: string): Promise<void> {\n    // no need to do anything here, twilsock backend handles it on its own\n  }\n}\n\nexport { TwilsockConnector };\n","import { EventEmitter } from \"events\";\nimport { TwilsockClient, ConnectionState } from \"twilsock\";\nimport { Connector, ChannelType } from \"./connector\";\nimport { RegistrarConnector } from \"./RegistrarConnector\";\nimport { TwilsockConnector } from \"./TwilsockConnector\";\nimport { log } from \"./logger\";\nimport {\n  validateTypesAsync,\n  validateTypes,\n  literal,\n  nonEmptyString,\n  validateConstructorTypes,\n  pureObject,\n} from \"@twilio/declarative-type-validator\";\nimport { LogLevelDesc } from \"loglevel\";\n\n// For validating Connector.ChannelType - keep synchronized!\nconst channelTypeRule = literal(\"apn\", \"fcm\", \"twilsock\");\n\ninterface PushNotification {\n  messageType: string;\n  payload: any;\n}\n\ninterface NotificationOptions {\n  region?: string;\n  ersUrl?: string;\n}\n\ninterface ClientOptions {\n  logLevel?: LogLevelDesc;\n  minTokenRefreshInterval?: number;\n  productId?: string;\n  twilsockClient?: TwilsockClient;\n  notifications?: NotificationOptions;\n  region?: string;\n}\n\n/**\n * @class\n * @alias Notifications\n * @classdesc The helper library for the notification service.\n * Provides high level api for creating and managing notification subscriptions and receiving messages\n * Creates the instance of Notification helper library\n *\n * @constructor\n * @param {string} token - Twilio access token\n * @param {Notifications#ClientOptions} options - Options to customize client behavior\n *\n * @event stateChanged channelType (registered|unregistered) -- coming from connector, i.e. it's per-connector type!\n * @event transportState Forwarded from Twilsock's stateChanged event.\n * @event message Routed from twilsock as a notification event.\n */\n@validateConstructorTypes(nonEmptyString, [\n  pureObject,\n  \"undefined\",\n  literal(null),\n])\nclass Client extends EventEmitter {\n  private readonly twilsock?: TwilsockClient;\n  private readonly connectors: Map<ChannelType, Connector>;\n\n  constructor(token: string, options: ClientOptions = {}) {\n    super();\n\n    options.logLevel = options.logLevel ?? \"error\";\n    log.setLevel(options.logLevel);\n\n    const productId = options.productId ?? \"notifications\";\n\n    const startTwilsock = !options.twilsockClient;\n\n    const twilsock = (options.twilsockClient =\n      options.twilsockClient ?? new TwilsockClient(token, productId, options));\n\n    const config = options.notifications ?? {};\n    const region = config.region ?? options.region ?? \"us1\";\n    const defaultUrl = `https://ers.${region}.twilio.com/v1/registrations`;\n    const registrarUrl = config.ersUrl || defaultUrl;\n\n    this.connectors = new Map<ChannelType, Connector>();\n\n    const platform = Client._detectPlatform();\n\n    this.connectors.set(\n      \"apn\",\n      new RegistrarConnector(\n        \"apn\",\n        { protocolVersion: 4, productId, platform },\n        twilsock,\n        registrarUrl\n      )\n    );\n    this.connectors.set(\n      \"fcm\",\n      new RegistrarConnector(\n        \"fcm\",\n        { protocolVersion: 3, productId, platform },\n        twilsock,\n        registrarUrl\n      )\n    );\n    this.connectors.set(\n      \"twilsock\",\n      new TwilsockConnector(productId, platform, twilsock)\n    );\n\n    twilsock.on(\"stateChanged\", (state) => this.emit(\"transportState\", state));\n\n    this._connector(\"twilsock\").on(\"stateChanged\", (type, value, state) =>\n      this.emit(\"stateChanged\", type, value, state)\n    );\n    this._connector(\"apn\").on(\"stateChanged\", (type, value, state) =>\n      this.emit(\"stateChanged\", type, value, state)\n    );\n    this._connector(\"fcm\").on(\"stateChanged\", (type, value, state) =>\n      this.emit(\"stateChanged\", type, value, state)\n    );\n\n    // Router\n    twilsock.on(\"message\", (type, message) =>\n      this._routeMessage(type, message)\n    );\n\n    this.updateToken(token);\n\n    // Start only if we created twilsock locally,\n    // otherwise it's the responsibility of whoever created the Twilsock client.\n    if (startTwilsock) {\n      twilsock.connect();\n      this.twilsock = twilsock;\n    }\n  }\n\n  public async shutdown(): Promise<void> {\n    this.connectors.clear();\n    if (this.twilsock) {\n      await this.twilsock.disconnect();\n    }\n  }\n\n  /**\n   * Set OS-provided APNS/FCM registration binding for the given channel type. Not used for 'twilsock'.\n   *\n   * You must call this function once you've received the ID of your device from the underlying OS.\n   *\n   * @param {ChannelType} channelType Channel type ('apn'/'fcm').\n   * @param {string} pushRegistrationId Token received from FCM/APNS system on device.\n   */\n  @validateTypes(channelTypeRule, nonEmptyString)\n  public setPushRegistrationId(\n    channelType: ChannelType,\n    pushRegistrationId: string\n  ): void {\n    log.debug(\n      `Set ${channelType} push registration id '${pushRegistrationId}'`\n    );\n    this._connector(channelType).setNotificationId(pushRegistrationId);\n  }\n\n  /**\n   * Subscribe to a given message type for a given channel type.\n   *\n   * Creates a subscriptions to receive incoming messages according to message type.\n   * Subscription establishes a binding and you will receive a signal when a notification\n   * of this type has been received by the library.\n   *\n   * Subscribed binding is preserved for 1 year, after which time it needs to be re-subscribed.\n   * This is the responsibility of the client SDK.\n   *\n   * @param {ChannelType} channelType Supported are 'twilsock', 'apn' and 'fcm'\n   * @param {string} messageType The type of message that you want to receive\n   */\n  @validateTypes(channelTypeRule, nonEmptyString)\n  public subscribe(channelType: ChannelType, messageType: string): void {\n    log.debug(\n      `Add ${channelType} subscriptions for message type ${messageType}`\n    );\n    this._connector(channelType).subscribe(messageType);\n  }\n\n  /**\n   * Unsubscribe from a given message type.\n   *\n   * Unsubscribing breaks a binding and you will not receive more notifications for this message type.\n   * Please note that you have to call commitChanges() and receive a successful result before\n   * the subscription is actually removed.\n   *\n   * @param {ChannelType} channelType Supported are 'twilsock', 'apn' and 'fcm'\n   * @param {string} messageType The type of message that you don't want to receive anymore\n   */\n  @validateTypes(channelTypeRule, nonEmptyString)\n  public unsubscribe(channelType: ChannelType, messageType: string): void {\n    log.debug(\n      `Remove ${channelType} subscriptions for message type ${messageType}`\n    );\n    this._connector(channelType).unsubscribe(messageType);\n  }\n\n  /**\n   * Update subscription token. You must update the token when the old one expires.\n   *\n   * When you receive onTokenWillExpire event from twilsock, call this function with the new refreshed\n   * token _after_ you have updated twilsock and other associated objects with the new token.\n   *\n   * @param {string} token Authentication token for registrations\n   */\n  @validateTypes(nonEmptyString)\n  public updateToken(token: string): void {\n    this.connectors.forEach((connector) => connector.updateToken(token));\n  }\n\n  /**\n   * Commit all collected subscription changes as a batched update. This function tries to reduce\n   * number of network calls necessary to update bindings status.\n   */\n  public async commitChanges(): Promise<void> {\n    const promises: Promise<void>[] = [];\n    this.connectors.forEach((connector) => {\n      if (connector.isActive()) {\n        promises.push(connector.commitChanges());\n      }\n    });\n    await Promise.all(promises);\n  }\n\n  /**\n   * Clear existing registrations directly using provided device token.\n   * This is useful to ensure stopped subscriptions without resubscribing.\n   *\n   * This function goes completely beside the state machine and removes all registrations.\n   * Use with caution: if it races with current state machine operations, madness will ensue.\n   *\n   * @param {ChannelType} channelType Channel type ('apn'/'fcm').\n   * @param {string} registrationId Token received from FCM/APNS system on device.\n   */\n  @validateTypesAsync(channelTypeRule, nonEmptyString)\n  public async removeRegistrations(\n    channelType: ChannelType,\n    registrationId: string\n  ): Promise<void> {\n    await this._connector(channelType).sendDeviceRemoveRequest(registrationId);\n  }\n\n  /**\n   * Handle incoming push notification.\n   * Client application should call this method when it receives push notifications and pass the received data.\n   * @param {Object} message push message\n   * @return {PushNotification} A reformatted payload with extracted message type.\n   */\n  public handlePushNotification(message: any): PushNotification {\n    return {\n      messageType: message.twi_message_type,\n      payload: message.payload,\n    };\n  }\n\n  /**\n   * Routes messages to the external subscribers\n   */\n  private _routeMessage(type: string, message: string): void {\n    log.debug(\"Notification message arrived: \", type, message);\n    this.emit(\"message\", type, message);\n  }\n\n  /**\n   * @param {String} type Channel type\n   * @throws {Error} Error with description\n   */\n  private _connector(type: ChannelType): Connector {\n    const connector = this.connectors.get(type);\n    if (!connector) {\n      throw new Error(`Unknown channel type: ${type}`);\n    }\n    return connector;\n  }\n\n  /**\n   * Returns platform string limited to max 128 chars\n   */\n  private static _detectPlatform(): string {\n    let platform = \"\";\n    if (typeof navigator !== \"undefined\") {\n      platform = \"unknown\";\n      if (typeof navigator.product !== \"undefined\") {\n        platform = navigator.product;\n      }\n      if (typeof navigator.userAgent !== \"undefined\") {\n        platform = navigator.userAgent;\n      }\n    } else {\n      platform = \"web\";\n    }\n\n    return platform.substring(0, 128);\n  }\n}\n\n/**\n * @event Client#message\n * Fired when a new notification message arrives.\n * @param {string} type Message type\n * @param {Object} message Message payload\n */\n\n/**\n * @event Client#stateChanged\n * Fired when the registration state changes.\n * @param {ChannelType} type Type of channel\n * @param {string} status Status of registration (registered/unregistered)\n * @param {Object} state Registration state details\n *                       (token, notificationId, currently subscribed types)\n */\n\n/**\n * @event Client#transportState\n * Fired when the twilsock connection state changes.\n * @param {string} state New transport state. Coming directly from Twilsock#ConnectionState.\n */\n\n/**\n * These options can be passed to Client constructor\n * @typedef {Object} Notifications#ClientOptions\n * @property {String} [logLevel='error'] - The level of logging to enable. Valid options\n *   (from strictest to broadest): ['silent', 'error', 'warn', 'info', 'debug', 'trace']\n */\n\nexport { ChannelType, ConnectionState, PushNotification, Client };\n"]},"metadata":{},"sourceType":"script"}