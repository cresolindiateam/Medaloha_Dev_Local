{"ast":null,"code":"/*\n@license\nThe following license applies to all parts of this software except as\ndocumented below.\n\n    Copyright (c) 2016, Twilio, inc.\n    All rights reserved.\n\n    Redistribution and use in source and binary forms, with or without\n    modification, are permitted provided that the following conditions are\n    met:\n\n      1. Redistributions of source code must retain the above copyright\n         notice, this list of conditions and the following disclaimer.\n\n      2. Redistributions in binary form must reproduce the above copyright\n         notice, this list of conditions and the following disclaimer in\n         the documentation and/or other materials provided with the\n         distribution.\n\n      3. Neither the name of Twilio nor the names of its contributors may\n         be used to endorse or promote products derived from this software\n         without specific prior written permission.\n\n    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n    \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n    LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n    A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n    HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n    SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n    LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n    DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n    (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n    OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\nThis software includes javascript-state-machine under the following license.\n\n    Copyright (c) 2012, 2013, 2014, 2015, Jake Gordon and contributors\n\n    Permission is hereby granted, free of charge, to any person obtaining a copy\n    of this software and associated documentation files (the \"Software\"), to deal\n    in the Software without restriction, including without limitation the rights\n    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n    copies of the Software, and to permit persons to whom the Software is\n    furnished to do so, subject to the following conditions:\n\n    The above copyright notice and this permission notice shall be included in all\n    copies or substantial portions of the Software.\n\n    THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n\nThis software includes loglevel under the following license.\n\n    Copyright (c) 2013 Tim Perry\n\n    Permission is hereby granted, free of charge, to any person\n    obtaining a copy of this software and associated documentation\n    files (the \"Software\"), to deal in the Software without\n    restriction, including without limitation the rights to use,\n    copy, modify, merge, publish, distribute, sublicense, and/or sell\n    copies of the Software, and to permit persons to whom the\n    Software is furnished to do so, subject to the following\n    conditions:\n\n    The above copyright notice and this permission notice shall be\n    included in all copies or substantial portions of the Software.\n\n    THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n    OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n    NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n    HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n    WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n    FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n    OTHER DEALINGS IN THE SOFTWARE.\n\n\n*/\n'use strict';\n\nvar global = typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {};\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nvar _asyncToGenerator = require('@babel/runtime/helpers/asyncToGenerator');\nvar _createClass = require('@babel/runtime/helpers/createClass');\nvar _assertThisInitialized = require('@babel/runtime/helpers/assertThisInitialized');\nvar _get = require('@babel/runtime/helpers/get');\nvar _inherits = require('@babel/runtime/helpers/inherits');\nvar _possibleConstructorReturn = require('@babel/runtime/helpers/possibleConstructorReturn');\nvar _getPrototypeOf = require('@babel/runtime/helpers/getPrototypeOf');\nvar _classCallCheck = require('@babel/runtime/helpers/classCallCheck');\nvar _defineProperty = require('@babel/runtime/helpers/defineProperty');\nvar _regeneratorRuntime = require('@babel/runtime/regenerator');\nvar _typeof = require('@babel/runtime/helpers/typeof');\nvar declarativeTypeValidator = require('@twilio/declarative-type-validator');\nvar loglevelLog = require('loglevel');\nrequire('core-js/modules/web.dom-collections.iterator.js');\nvar StateMachine = require('javascript-state-machine');\nvar uuid = require('uuid');\nrequire('core-js/modules/es.string.replace.js');\nrequire('core-js/modules/es.typed-array.uint8-array.js');\nrequire('core-js/modules/es.typed-array.fill.js');\nrequire('core-js/modules/es.typed-array.set.js');\nrequire('core-js/modules/es.typed-array.sort.js');\nvar _wrapNativeSuper = require('@babel/runtime/helpers/wrapNativeSuper');\nvar operationRetrier = require('@twilio/operation-retrier');\nvar platform = require('platform');\nfunction _interopDefaultLegacy(e) {\n  return e && typeof e === 'object' && 'default' in e ? e : {\n    'default': e\n  };\n}\nfunction _interopNamespace(e) {\n  if (e && e.__esModule) return e;\n  var n = Object.create(null);\n  if (e) {\n    Object.keys(e).forEach(function (k) {\n      if (k !== 'default') {\n        var d = Object.getOwnPropertyDescriptor(e, k);\n        Object.defineProperty(n, k, d.get ? d : {\n          enumerable: true,\n          get: function () {\n            return e[k];\n          }\n        });\n      }\n    });\n  }\n  n['default'] = e;\n  return Object.freeze(n);\n}\nvar _asyncToGenerator__default = /*#__PURE__*/_interopDefaultLegacy(_asyncToGenerator);\nvar _createClass__default = /*#__PURE__*/_interopDefaultLegacy(_createClass);\nvar _assertThisInitialized__default = /*#__PURE__*/_interopDefaultLegacy(_assertThisInitialized);\nvar _get__default = /*#__PURE__*/_interopDefaultLegacy(_get);\nvar _inherits__default = /*#__PURE__*/_interopDefaultLegacy(_inherits);\nvar _possibleConstructorReturn__default = /*#__PURE__*/_interopDefaultLegacy(_possibleConstructorReturn);\nvar _getPrototypeOf__default = /*#__PURE__*/_interopDefaultLegacy(_getPrototypeOf);\nvar _classCallCheck__default = /*#__PURE__*/_interopDefaultLegacy(_classCallCheck);\nvar _defineProperty__default = /*#__PURE__*/_interopDefaultLegacy(_defineProperty);\nvar _regeneratorRuntime__default = /*#__PURE__*/_interopDefaultLegacy(_regeneratorRuntime);\nvar _typeof__default = /*#__PURE__*/_interopDefaultLegacy(_typeof);\nvar loglevelLog__namespace = /*#__PURE__*/_interopNamespace(loglevelLog);\nvar StateMachine__namespace = /*#__PURE__*/_interopNamespace(StateMachine);\nvar _wrapNativeSuper__default = /*#__PURE__*/_interopDefaultLegacy(_wrapNativeSuper);\nvar platform__namespace = /*#__PURE__*/_interopNamespace(platform);\nfunction __decorate(decorators, target, key, desc) {\n  var c = arguments.length,\n    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n    d;\n  if ((typeof Reflect === \"undefined\" ? \"undefined\" : _typeof__default['default'](Reflect)) === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {\n    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  }\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n}\nfunction __metadata(metadataKey, metadataValue) {\n  if ((typeof Reflect === \"undefined\" ? \"undefined\" : _typeof__default['default'](Reflect)) === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\n}\nvar domain;\n\n// This constructor is used to store event handlers. Instantiating this is\n// faster than explicitly calling `Object.create(null)` to get a \"clean\" empty\n// object (tested with v8 v4.9).\nfunction EventHandlers() {}\nEventHandlers.prototype = Object.create(null);\nfunction EventEmitter() {\n  EventEmitter.init.call(this);\n}\n\n// nodejs oddity\n// require('events') === require('events').EventEmitter\nEventEmitter.EventEmitter = EventEmitter;\nEventEmitter.usingDomains = false;\nEventEmitter.prototype.domain = undefined;\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nEventEmitter.defaultMaxListeners = 10;\nEventEmitter.init = function () {\n  this.domain = null;\n  if (EventEmitter.usingDomains) {\n    // if there is an active domain, then attach to it.\n    if (domain.active) ;\n  }\n  if (!this._events || this._events === Object.getPrototypeOf(this)._events) {\n    this._events = new EventHandlers();\n    this._eventsCount = 0;\n  }\n  this._maxListeners = this._maxListeners || undefined;\n};\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\n  if (typeof n !== 'number' || n < 0 || isNaN(n)) throw new TypeError('\"n\" argument must be a positive number');\n  this._maxListeners = n;\n  return this;\n};\nfunction $getMaxListeners(that) {\n  if (that._maxListeners === undefined) return EventEmitter.defaultMaxListeners;\n  return that._maxListeners;\n}\nEventEmitter.prototype.getMaxListeners = function getMaxListeners() {\n  return $getMaxListeners(this);\n};\n\n// These standalone emit* functions are used to optimize calling of event\n// handlers for fast cases because emit() itself often has a variable number of\n// arguments and can be deoptimized because of that. These functions always have\n// the same number of arguments and thus do not get deoptimized, so the code\n// inside them can execute faster.\nfunction emitNone(handler, isFn, self) {\n  if (isFn) handler.call(self);else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i) listeners[i].call(self);\n  }\n}\nfunction emitOne(handler, isFn, self, arg1) {\n  if (isFn) handler.call(self, arg1);else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i) listeners[i].call(self, arg1);\n  }\n}\nfunction emitTwo(handler, isFn, self, arg1, arg2) {\n  if (isFn) handler.call(self, arg1, arg2);else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i) listeners[i].call(self, arg1, arg2);\n  }\n}\nfunction emitThree(handler, isFn, self, arg1, arg2, arg3) {\n  if (isFn) handler.call(self, arg1, arg2, arg3);else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i) listeners[i].call(self, arg1, arg2, arg3);\n  }\n}\nfunction emitMany(handler, isFn, self, args) {\n  if (isFn) handler.apply(self, args);else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i) listeners[i].apply(self, args);\n  }\n}\nEventEmitter.prototype.emit = function emit(type) {\n  var er, handler, len, args, i, events, domain;\n  var doError = type === 'error';\n  events = this._events;\n  if (events) doError = doError && events.error == null;else if (!doError) return false;\n  domain = this.domain;\n\n  // If there is no 'error' event listener then throw.\n  if (doError) {\n    er = arguments[1];\n    if (domain) {\n      if (!er) er = new Error('Uncaught, unspecified \"error\" event');\n      er.domainEmitter = this;\n      er.domain = domain;\n      er.domainThrown = false;\n      domain.emit('error', er);\n    } else if (er instanceof Error) {\n      throw er; // Unhandled 'error' event\n    } else {\n      // At least give some kind of context to the user\n      var err = new Error('Uncaught, unspecified \"error\" event. (' + er + ')');\n      err.context = er;\n      throw err;\n    }\n    return false;\n  }\n  handler = events[type];\n  if (!handler) return false;\n  var isFn = typeof handler === 'function';\n  len = arguments.length;\n  switch (len) {\n    // fast cases\n    case 1:\n      emitNone(handler, isFn, this);\n      break;\n    case 2:\n      emitOne(handler, isFn, this, arguments[1]);\n      break;\n    case 3:\n      emitTwo(handler, isFn, this, arguments[1], arguments[2]);\n      break;\n    case 4:\n      emitThree(handler, isFn, this, arguments[1], arguments[2], arguments[3]);\n      break;\n    // slower\n    default:\n      args = new Array(len - 1);\n      for (i = 1; i < len; i++) args[i - 1] = arguments[i];\n      emitMany(handler, isFn, this, args);\n  }\n  return true;\n};\nfunction _addListener(target, type, listener, prepend) {\n  var m;\n  var events;\n  var existing;\n  if (typeof listener !== 'function') throw new TypeError('\"listener\" argument must be a function');\n  events = target._events;\n  if (!events) {\n    events = target._events = new EventHandlers();\n    target._eventsCount = 0;\n  } else {\n    // To avoid recursion in the case that type === \"newListener\"! Before\n    // adding it to the listeners, first emit \"newListener\".\n    if (events.newListener) {\n      target.emit('newListener', type, listener.listener ? listener.listener : listener);\n\n      // Re-assign `events` because a newListener handler could have caused the\n      // this._events to be assigned to a new object\n      events = target._events;\n    }\n    existing = events[type];\n  }\n  if (!existing) {\n    // Optimize the case of one listener. Don't need the extra array object.\n    existing = events[type] = listener;\n    ++target._eventsCount;\n  } else {\n    if (typeof existing === 'function') {\n      // Adding the second element, need to change to array.\n      existing = events[type] = prepend ? [listener, existing] : [existing, listener];\n    } else {\n      // If we've already got an array, just append.\n      if (prepend) {\n        existing.unshift(listener);\n      } else {\n        existing.push(listener);\n      }\n    }\n\n    // Check for listener leak\n    if (!existing.warned) {\n      m = $getMaxListeners(target);\n      if (m && m > 0 && existing.length > m) {\n        existing.warned = true;\n        var w = new Error('Possible EventEmitter memory leak detected. ' + existing.length + ' ' + type + ' listeners added. ' + 'Use emitter.setMaxListeners() to increase limit');\n        w.name = 'MaxListenersExceededWarning';\n        w.emitter = target;\n        w.type = type;\n        w.count = existing.length;\n        emitWarning(w);\n      }\n    }\n  }\n  return target;\n}\nfunction emitWarning(e) {\n  typeof console.warn === 'function' ? console.warn(e) : console.log(e);\n}\nEventEmitter.prototype.addListener = function addListener(type, listener) {\n  return _addListener(this, type, listener, false);\n};\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\nEventEmitter.prototype.prependListener = function prependListener(type, listener) {\n  return _addListener(this, type, listener, true);\n};\nfunction _onceWrap(target, type, listener) {\n  var fired = false;\n  function g() {\n    target.removeListener(type, g);\n    if (!fired) {\n      fired = true;\n      listener.apply(target, arguments);\n    }\n  }\n  g.listener = listener;\n  return g;\n}\nEventEmitter.prototype.once = function once(type, listener) {\n  if (typeof listener !== 'function') throw new TypeError('\"listener\" argument must be a function');\n  this.on(type, _onceWrap(this, type, listener));\n  return this;\n};\nEventEmitter.prototype.prependOnceListener = function prependOnceListener(type, listener) {\n  if (typeof listener !== 'function') throw new TypeError('\"listener\" argument must be a function');\n  this.prependListener(type, _onceWrap(this, type, listener));\n  return this;\n};\n\n// emits a 'removeListener' event iff the listener was removed\nEventEmitter.prototype.removeListener = function removeListener(type, listener) {\n  var list, events, position, i, originalListener;\n  if (typeof listener !== 'function') throw new TypeError('\"listener\" argument must be a function');\n  events = this._events;\n  if (!events) return this;\n  list = events[type];\n  if (!list) return this;\n  if (list === listener || list.listener && list.listener === listener) {\n    if (--this._eventsCount === 0) this._events = new EventHandlers();else {\n      delete events[type];\n      if (events.removeListener) this.emit('removeListener', type, list.listener || listener);\n    }\n  } else if (typeof list !== 'function') {\n    position = -1;\n    for (i = list.length; i-- > 0;) {\n      if (list[i] === listener || list[i].listener && list[i].listener === listener) {\n        originalListener = list[i].listener;\n        position = i;\n        break;\n      }\n    }\n    if (position < 0) return this;\n    if (list.length === 1) {\n      list[0] = undefined;\n      if (--this._eventsCount === 0) {\n        this._events = new EventHandlers();\n        return this;\n      } else {\n        delete events[type];\n      }\n    } else {\n      spliceOne(list, position);\n    }\n    if (events.removeListener) this.emit('removeListener', type, originalListener || listener);\n  }\n  return this;\n};\n\n// Alias for removeListener added in NodeJS 10.0\n// https://nodejs.org/api/events.html#events_emitter_off_eventname_listener\nEventEmitter.prototype.off = function (type, listener) {\n  return this.removeListener(type, listener);\n};\nEventEmitter.prototype.removeAllListeners = function removeAllListeners(type) {\n  var listeners, events;\n  events = this._events;\n  if (!events) return this;\n\n  // not listening for removeListener, no need to emit\n  if (!events.removeListener) {\n    if (arguments.length === 0) {\n      this._events = new EventHandlers();\n      this._eventsCount = 0;\n    } else if (events[type]) {\n      if (--this._eventsCount === 0) this._events = new EventHandlers();else delete events[type];\n    }\n    return this;\n  }\n\n  // emit removeListener for all listeners on all events\n  if (arguments.length === 0) {\n    var keys = Object.keys(events);\n    for (var i = 0, key; i < keys.length; ++i) {\n      key = keys[i];\n      if (key === 'removeListener') continue;\n      this.removeAllListeners(key);\n    }\n    this.removeAllListeners('removeListener');\n    this._events = new EventHandlers();\n    this._eventsCount = 0;\n    return this;\n  }\n  listeners = events[type];\n  if (typeof listeners === 'function') {\n    this.removeListener(type, listeners);\n  } else if (listeners) {\n    // LIFO order\n    do {\n      this.removeListener(type, listeners[listeners.length - 1]);\n    } while (listeners[0]);\n  }\n  return this;\n};\nEventEmitter.prototype.listeners = function listeners(type) {\n  var evlistener;\n  var ret;\n  var events = this._events;\n  if (!events) ret = [];else {\n    evlistener = events[type];\n    if (!evlistener) ret = [];else if (typeof evlistener === 'function') ret = [evlistener.listener || evlistener];else ret = unwrapListeners(evlistener);\n  }\n  return ret;\n};\nEventEmitter.listenerCount = function (emitter, type) {\n  if (typeof emitter.listenerCount === 'function') {\n    return emitter.listenerCount(type);\n  } else {\n    return listenerCount.call(emitter, type);\n  }\n};\nEventEmitter.prototype.listenerCount = listenerCount;\nfunction listenerCount(type) {\n  var events = this._events;\n  if (events) {\n    var evlistener = events[type];\n    if (typeof evlistener === 'function') {\n      return 1;\n    } else if (evlistener) {\n      return evlistener.length;\n    }\n  }\n  return 0;\n}\nEventEmitter.prototype.eventNames = function eventNames() {\n  return this._eventsCount > 0 ? Reflect.ownKeys(this._events) : [];\n};\n\n// About 1.5x faster than the two-arg version of Array#splice().\nfunction spliceOne(list, index) {\n  for (var i = index, k = i + 1, n = list.length; k < n; i += 1, k += 1) list[i] = list[k];\n  list.pop();\n}\nfunction arrayClone(arr, i) {\n  var copy = new Array(i);\n  while (i--) copy[i] = arr[i];\n  return copy;\n}\nfunction unwrapListeners(arr) {\n  var ret = new Array(arr.length);\n  for (var i = 0; i < ret.length; ++i) {\n    ret[i] = arr[i].listener || arr[i];\n  }\n  return ret;\n}\nvar log = loglevelLog__namespace.getLogger(\"twilsock\"); // twilsock is used by Flex SDK. Please DO NOT change\n\nfunction prepareLine(prefix, args) {\n  return [\"\".concat(new Date().toISOString(), \" Twilsock \").concat(prefix, \":\")].concat(Array.from(args));\n}\nvar Logger = /*#__PURE__*/function () {\n  function Logger(prefix) {\n    _classCallCheck__default['default'](this, Logger);\n    _defineProperty__default['default'](this, \"prefix\", \"\");\n    this.prefix = prefix !== null && prefix !== undefined && prefix.length > 0 ? \" \" + prefix + \":\" : \"\";\n  }\n  _createClass__default['default'](Logger, [{\n    key: \"setLevel\",\n    value: function setLevel(level) {\n      log.setLevel(level);\n    }\n  }, {\n    key: \"trace\",\n    value: function trace() {\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n      log.trace.apply(null, prepareLine(\"T\", args));\n    }\n  }, {\n    key: \"debug\",\n    value: function debug() {\n      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n      }\n      log.debug.apply(null, prepareLine(\"D\", args));\n    }\n  }, {\n    key: \"info\",\n    value: function info() {\n      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n        args[_key3] = arguments[_key3];\n      }\n      log.info.apply(null, prepareLine(\"I\", args));\n    }\n  }, {\n    key: \"warn\",\n    value: function warn() {\n      for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n        args[_key4] = arguments[_key4];\n      }\n      log.warn.apply(null, prepareLine(\"W\", args));\n    }\n  }, {\n    key: \"error\",\n    value: function error() {\n      for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {\n        args[_key5] = arguments[_key5];\n      }\n      log.error.apply(null, prepareLine(\"E\", args));\n    }\n  }], [{\n    key: \"setLevel\",\n    value: function setLevel(level) {\n      log.setLevel(level);\n    }\n  }, {\n    key: \"trace\",\n    value: function trace() {\n      for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {\n        args[_key6] = arguments[_key6];\n      }\n      log.trace.apply(null, prepareLine(\"T\", args));\n    }\n  }, {\n    key: \"debug\",\n    value: function debug() {\n      for (var _len7 = arguments.length, args = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {\n        args[_key7] = arguments[_key7];\n      }\n      log.debug.apply(null, prepareLine(\"D\", args));\n    }\n  }, {\n    key: \"info\",\n    value: function info() {\n      for (var _len8 = arguments.length, args = new Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {\n        args[_key8] = arguments[_key8];\n      }\n      log.info.apply(null, prepareLine(\"I\", args));\n    }\n  }, {\n    key: \"warn\",\n    value: function warn() {\n      for (var _len9 = arguments.length, args = new Array(_len9), _key9 = 0; _key9 < _len9; _key9++) {\n        args[_key9] = arguments[_key9];\n      }\n      log.warn.apply(null, prepareLine(\"W\", args));\n    }\n  }, {\n    key: \"error\",\n    value: function error() {\n      for (var _len10 = arguments.length, args = new Array(_len10), _key10 = 0; _key10 < _len10; _key10++) {\n        args[_key10] = arguments[_key10];\n      }\n      log.error.apply(null, prepareLine(\"E\", args));\n    }\n  }]);\n  return Logger;\n}();\nvar logInstance = new Logger(\"\");\nvar version = \"0.12.2\";\n\n/**\n * Settings container for the Twilsock client library\n */\n\nvar Configuration = /*#__PURE__*/function () {\n  /**\n   * @param {String} token - authentication token\n   * @param {Object} options - options to override defaults\n   */\n  function Configuration(token, activeGrant, options) {\n    _classCallCheck__default['default'](this, Configuration);\n    _defineProperty__default['default'](this, \"confirmedCapabilities\", new Set());\n    this.activeGrant = activeGrant;\n    this._token = token;\n    var region = options.region || \"us1\";\n    var defaultTwilsockUrl = \"wss://tsock.\".concat(region, \".twilio.com/v3/wsconnect\");\n    var twilsockOptions = options.twilsock || options.Twilsock || {};\n    this.url = twilsockOptions.uri || defaultTwilsockUrl;\n    this._continuationToken = options.continuationToken ? options.continuationToken : null;\n    this.logLevel = options.logLevel ? options.logLevel : \"error\";\n    this.retryPolicy = options.retryPolicy ? options.retryPolicy : {\n      min: 1 * 1000,\n      max: 2 * 60 * 1000,\n      randomness: 0.2\n    };\n    this.clientMetadata = options.clientMetadata ? options.clientMetadata : {};\n    this.clientMetadata.ver = version;\n    this.initRegistrations = options.initRegistrations ? options.initRegistrations : null;\n    this.tweaks = options.tweaks ? options.tweaks : null;\n  }\n  _createClass__default['default'](Configuration, [{\n    key: \"token\",\n    get: function get() {\n      return this._token;\n    }\n  }, {\n    key: \"continuationToken\",\n    get: function get() {\n      return this._continuationToken;\n    }\n  }, {\n    key: \"updateToken\",\n    value: function updateToken(token) {\n      this._token = token;\n    }\n  }, {\n    key: \"updateContinuationToken\",\n    value: function updateContinuationToken(continuationToken) {\n      this._continuationToken = continuationToken;\n    }\n  }]);\n  return Configuration;\n}();\nvar AbstractMessage = function AbstractMessage(id) {\n  _classCallCheck__default['default'](this, AbstractMessage);\n  this.id = id || \"TM\".concat(uuid.v4());\n};\nfunction _createSuper$f(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct$f();\n  return function _createSuperInternal() {\n    var Super = _getPrototypeOf__default['default'](Derived),\n      result;\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf__default['default'](this).constructor;\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n    return _possibleConstructorReturn__default['default'](this, result);\n  };\n}\nfunction _isNativeReflectConstruct$f() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n  try {\n    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\nvar Init = /*#__PURE__*/function (_AbstractMessage) {\n  _inherits__default['default'](Init, _AbstractMessage);\n  var _super = _createSuper$f(Init);\n  function Init(token, continuationToken, metadata, registrations, tweaks) {\n    var _this;\n    _classCallCheck__default['default'](this, Init);\n    _this = _super.call(this);\n    _defineProperty__default['default'](_assertThisInitialized__default['default'](_this), \"method\", \"init\");\n    _this.token = token;\n    _this.continuation_token = continuationToken;\n    _this.metadata = metadata;\n    _this.registrations = registrations;\n    _this.tweaks = tweaks;\n    _this.capabilities = [\"client_update\", \"offline_storage\", \"telemetry.v1\"];\n    return _this;\n  }\n  return Init;\n}(AbstractMessage);\nfunction _createSuper$e(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct$e();\n  return function _createSuperInternal() {\n    var Super = _getPrototypeOf__default['default'](Derived),\n      result;\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf__default['default'](this).constructor;\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n    return _possibleConstructorReturn__default['default'](this, result);\n  };\n}\nfunction _isNativeReflectConstruct$e() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n  try {\n    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\nvar InitReply = /*#__PURE__*/function (_AbstractMessage) {\n  _inherits__default['default'](InitReply, _AbstractMessage);\n  var _super = _createSuper$e(InitReply);\n  function InitReply(id, continuationToken, confirmedCapabilities, continuationTokenStatus, offlineStorage, initRegistrations, debugInfo) {\n    var _this;\n    _classCallCheck__default['default'](this, InitReply);\n    _this = _super.call(this, id);\n    _this.continuationToken = continuationToken;\n    _this.continuationTokenStatus = continuationTokenStatus;\n    _this.offlineStorage = offlineStorage;\n    _this.initRegistrations = initRegistrations;\n    _this.debugInfo = debugInfo;\n    _this.confirmedCapabilities = confirmedCapabilities;\n    return _this;\n  }\n  return InitReply;\n}(AbstractMessage);\nfunction _createSuper$d(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct$d();\n  return function _createSuperInternal() {\n    var Super = _getPrototypeOf__default['default'](Derived),\n      result;\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf__default['default'](this).constructor;\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n    return _possibleConstructorReturn__default['default'](this, result);\n  };\n}\nfunction _isNativeReflectConstruct$d() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n  try {\n    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\nvar Update = /*#__PURE__*/function (_AbstractMessage) {\n  _inherits__default['default'](Update, _AbstractMessage);\n  var _super = _createSuper$d(Update);\n  function Update(token) {\n    var _this;\n    _classCallCheck__default['default'](this, Update);\n    _this = _super.call(this);\n    _defineProperty__default['default'](_assertThisInitialized__default['default'](_this), \"method\", \"update\");\n    _this.token = token;\n    return _this;\n  }\n  return Update;\n}(AbstractMessage);\nfunction _createSuper$c(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct$c();\n  return function _createSuperInternal() {\n    var Super = _getPrototypeOf__default['default'](Derived),\n      result;\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf__default['default'](this).constructor;\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n    return _possibleConstructorReturn__default['default'](this, result);\n  };\n}\nfunction _isNativeReflectConstruct$c() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n  try {\n    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\nvar Message = /*#__PURE__*/function (_AbstractMessage) {\n  _inherits__default['default'](Message, _AbstractMessage);\n  var _super = _createSuper$c(Message);\n  function Message(grant, contentType, request) {\n    var _this;\n    _classCallCheck__default['default'](this, Message);\n    _this = _super.call(this);\n    _defineProperty__default['default'](_assertThisInitialized__default['default'](_this), \"method\", \"message\");\n    _this.active_grant = grant;\n    _this.payload_type = contentType;\n    _this.http_request = request;\n    return _this;\n  }\n  return Message;\n}(AbstractMessage);\nfunction _createSuper$b(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct$b();\n  return function _createSuperInternal() {\n    var Super = _getPrototypeOf__default['default'](Derived),\n      result;\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf__default['default'](this).constructor;\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n    return _possibleConstructorReturn__default['default'](this, result);\n  };\n}\nfunction _isNativeReflectConstruct$b() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n  try {\n    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\nvar Reply = /*#__PURE__*/function (_AbstractMessage) {\n  _inherits__default['default'](Reply, _AbstractMessage);\n  var _super = _createSuper$b(Reply);\n  function Reply(id) {\n    var _this;\n    _classCallCheck__default['default'](this, Reply);\n    _this = _super.call(this, id);\n    _defineProperty__default['default'](_assertThisInitialized__default['default'](_this), \"method\", \"reply\");\n    _defineProperty__default['default'](_assertThisInitialized__default['default'](_this), \"payload_type\", \"application/json\");\n    _defineProperty__default['default'](_assertThisInitialized__default['default'](_this), \"status\", {\n      code: 200,\n      status: \"OK\"\n    });\n    return _this;\n  }\n  return Reply;\n}(AbstractMessage);\nfunction _createSuper$a(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct$a();\n  return function _createSuperInternal() {\n    var Super = _getPrototypeOf__default['default'](Derived),\n      result;\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf__default['default'](this).constructor;\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n    return _possibleConstructorReturn__default['default'](this, result);\n  };\n}\nfunction _isNativeReflectConstruct$a() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n  try {\n    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\nvar Close = /*#__PURE__*/function (_AbstractMessage) {\n  _inherits__default['default'](Close, _AbstractMessage);\n  var _super = _createSuper$a(Close);\n  function Close() {\n    var _this;\n    _classCallCheck__default['default'](this, Close);\n    _this = _super.call(this);\n    _defineProperty__default['default'](_assertThisInitialized__default['default'](_this), \"method\", \"close\");\n    return _this;\n  }\n  return Close;\n}(AbstractMessage);\nfunction _createSuper$9(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct$9();\n  return function _createSuperInternal() {\n    var Super = _getPrototypeOf__default['default'](Derived),\n      result;\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf__default['default'](this).constructor;\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n    return _possibleConstructorReturn__default['default'](this, result);\n  };\n}\nfunction _isNativeReflectConstruct$9() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n  try {\n    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\nvar TelemetryEvent = function TelemetryEvent(start,\n// relative to event send time\nend,\n// relative to event send time\ntitle, details, id,\n// optional, default will be random assigned by backend\ntype) {\n  _classCallCheck__default['default'](this, TelemetryEvent);\n  this.start = start;\n  this.end = end;\n  this.title = title;\n  this.details = details;\n  this.id = id;\n  this.type = type;\n} // optional, default will be \"SDK\" assigned by backend\n;\nvar Telemetry = /*#__PURE__*/function (_AbstractMessage) {\n  _inherits__default['default'](Telemetry, _AbstractMessage);\n  var _super = _createSuper$9(Telemetry);\n  function Telemetry(events) {\n    var _this;\n    _classCallCheck__default['default'](this, Telemetry);\n    _this = _super.call(this);\n    _defineProperty__default['default'](_assertThisInitialized__default['default'](_this), \"method\", \"telemetry.v1\");\n    _this.events = events;\n    return _this;\n  }\n  return Telemetry;\n}(AbstractMessage);\nfunction byteLength(s) {\n  var escstr = encodeURIComponent(s);\n  var binstr = escstr.replace(/%([0-9A-F]{2})/g, function (match, p1) {\n    return String.fromCharCode(Number(\"0x\" + p1));\n  });\n  return binstr.length;\n}\nfunction stringToUint8Array(s) {\n  var escstr = encodeURIComponent(s);\n  var binstr = escstr.replace(/%([0-9A-F]{2})/g, function (match, p1) {\n    return String.fromCharCode(Number(\"0x\" + p1));\n  });\n  var ua = new Uint8Array(binstr.length);\n  Array.prototype.forEach.call(binstr, function (ch, i) {\n    ua[i] = ch.charCodeAt(0);\n  });\n  return ua;\n}\nfunction uint8ArrayToString(ua) {\n  var binstr = Array.prototype.map.call(ua, function (ch) {\n    return String.fromCharCode(ch);\n  }).join(\"\");\n  var escstr = binstr.replace(/(.)/g, function (m, p) {\n    var code = p.charCodeAt(0).toString(16).toUpperCase();\n    if (code.length < 2) {\n      code = \"0\" + code;\n    }\n    return \"%\" + code;\n  });\n  return decodeURIComponent(escstr);\n}\nfunction getJsonObject(array) {\n  return JSON.parse(uint8ArrayToString(array));\n}\nfunction getMagic(buffer) {\n  var strMagic = \"\";\n  var idx = 0;\n  for (; idx < buffer.length; ++idx) {\n    var chr = String.fromCharCode(buffer[idx]);\n    strMagic += chr;\n    if (chr === \"\\r\") {\n      idx += 2;\n      break;\n    }\n  }\n  var magics = strMagic.split(\" \");\n  return {\n    size: idx,\n    protocol: magics[0],\n    version: magics[1],\n    headerSize: Number(magics[2])\n  };\n}\nvar Parser = /*#__PURE__*/function () {\n  function Parser() {\n    _classCallCheck__default['default'](this, Parser);\n  }\n  _createClass__default['default'](Parser, null, [{\n    key: \"parse\",\n    value: function parse(message) {\n      var fieldMargin = 2;\n      var dataView = new Uint8Array(message);\n      var magic = getMagic(dataView);\n      if (magic.protocol !== \"TWILSOCK\" || magic.version !== \"V3.0\") {\n        logInstance.error(\"unsupported protocol: \".concat(magic.protocol, \" ver \").concat(magic.version)); //throw new Error('Unsupported protocol');\n        //this.fsm.unsupportedProtocol();\n\n        return null;\n      }\n      var header;\n      try {\n        header = getJsonObject(dataView.subarray(magic.size, magic.size + magic.headerSize));\n      } catch (e) {\n        logInstance.error(\"failed to parse message header\", e, message); //throw new Error('Failed to parse message');\n        //this.fsm.protocolError();\n\n        return null;\n      }\n      logInstance.debug(\"message received: \", header.method);\n      logInstance.trace(\"message received: \", header);\n      var payload;\n      if (header.payload_size > 0) {\n        var payloadOffset = fieldMargin + magic.size + magic.headerSize;\n        var payloadSize = header.payload_size;\n        if (!header.hasOwnProperty(\"payload_type\") || header.payload_type.indexOf(\"application/json\") === 0) {\n          try {\n            payload = getJsonObject(dataView.subarray(payloadOffset, payloadOffset + payloadSize));\n          } catch (e) {\n            logInstance.error(\"failed to parse message body\", e, message); //this.fsm.protocolError();\n\n            return null;\n          }\n        } else if (header.payload_type.indexOf(\"text/plain\") === 0) {\n          payload = uint8ArrayToString(dataView.subarray(payloadOffset, payloadOffset + payloadSize));\n        }\n      }\n      return {\n        method: header.method,\n        header: header,\n        payload: payload\n      };\n    }\n  }, {\n    key: \"createPacket\",\n    value: function createPacket(header) {\n      var payloadString = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"\";\n      header.payload_size = byteLength(payloadString); // eslint-disable-line camelcase\n\n      var headerString = JSON.stringify(header);\n      var magicString = \"TWILSOCK V3.0 \" + byteLength(headerString);\n      logInstance.debug(\"send request:\", magicString + headerString + payloadString);\n      var message = stringToUint8Array(magicString + \"\\r\\n\" + headerString + \"\\r\\n\" + payloadString);\n      return message.buffer;\n    }\n  }]);\n  return Parser;\n}();\nfunction _createSuper$8(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct$8();\n  return function _createSuperInternal() {\n    var Super = _getPrototypeOf__default['default'](Derived),\n      result;\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf__default['default'](this).constructor;\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n    return _possibleConstructorReturn__default['default'](this, result);\n  };\n}\nfunction _isNativeReflectConstruct$8() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n  try {\n    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\nvar TwilsockError = /*#__PURE__*/function (_Error) {\n  _inherits__default['default'](TwilsockError, _Error);\n  var _super = _createSuper$8(TwilsockError);\n  function TwilsockError(description) {\n    _classCallCheck__default['default'](this, TwilsockError);\n    return _super.call(this, description);\n  }\n  return TwilsockError;\n}( /*#__PURE__*/_wrapNativeSuper__default['default'](Error));\nfunction _createSuper$7(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct$7();\n  return function _createSuperInternal() {\n    var Super = _getPrototypeOf__default['default'](Derived),\n      result;\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf__default['default'](this).constructor;\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n    return _possibleConstructorReturn__default['default'](this, result);\n  };\n}\nfunction _isNativeReflectConstruct$7() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n  try {\n    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\nvar TwilsockReplyError = /*#__PURE__*/function (_TwilsockError) {\n  _inherits__default['default'](TwilsockReplyError, _TwilsockError);\n  var _super = _createSuper$7(TwilsockReplyError);\n  function TwilsockReplyError(description, reply) {\n    var _this;\n    _classCallCheck__default['default'](this, TwilsockReplyError);\n    _this = _super.call(this, description);\n    _this.reply = reply;\n    return _this;\n  }\n  return TwilsockReplyError;\n}(TwilsockError);\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) {\n      symbols = symbols.filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n      });\n    }\n    keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty__default['default'](target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n  return target;\n}\nfunction _createSuper$6(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct$6();\n  return function _createSuperInternal() {\n    var Super = _getPrototypeOf__default['default'](Derived),\n      result;\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf__default['default'](this).constructor;\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n    return _possibleConstructorReturn__default['default'](this, result);\n  };\n}\nfunction _isNativeReflectConstruct$6() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n  try {\n    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\nvar BackoffRetrier = /*#__PURE__*/function (_EventEmitter) {\n  _inherits__default['default'](BackoffRetrier, _EventEmitter);\n  var _super = _createSuper$6(BackoffRetrier);\n  function BackoffRetrier(options) {\n    var _this;\n    _classCallCheck__default['default'](this, BackoffRetrier);\n    _this = _super.call(this);\n    _defineProperty__default['default'](_assertThisInitialized__default['default'](_this), \"newBackoff\", null);\n    _defineProperty__default['default'](_assertThisInitialized__default['default'](_this), \"usedBackoff\", null);\n    _defineProperty__default['default'](_assertThisInitialized__default['default'](_this), \"retrier\", null);\n    _this.options = options ? _objectSpread({}, options) : {};\n    return _this;\n  }\n  /**\n   * Should be called once per attempt series to start retrier.\n   */\n\n  _createClass__default['default'](BackoffRetrier, [{\n    key: \"inProgress\",\n    get: function get() {\n      return !!this.retrier;\n    }\n  }, {\n    key: \"start\",\n    value: function start() {\n      if (this.inProgress) {\n        throw new Error(\"Already waiting for next attempt, call finishAttempt(success : boolean) to finish it\");\n      }\n      this.createRetrier();\n    }\n    /**\n     * Should be called to stop retrier entirely.\n     */\n  }, {\n    key: \"stop\",\n    value: function stop() {\n      this.cleanRetrier();\n      this.newBackoff = null;\n      this.usedBackoff = null;\n    }\n    /**\n     * Modifies backoff for next attempt.\n     * Expected behavior:\n     * - If there was no backoff passed previously reschedulling next attempt to given backoff\n     * - If previous backoff was longer then ignoring this one.\n     * - If previous backoff was shorter then reschedulling with this one.\n     * With or without backoff retrier will keep growing normally.\n     * @param delay delay of next attempts in ms.\n     */\n  }, {\n    key: \"modifyBackoff\",\n    value: function modifyBackoff(delay) {\n      this.newBackoff = delay;\n    }\n    /**\n     * Mark last emmited attempt as failed, initiating either next of fail if limits were hit.\n     */\n  }, {\n    key: \"attemptFailed\",\n    value: function attemptFailed() {\n      if (!this.inProgress) {\n        throw new Error(\"No attempt is in progress\");\n      }\n      if (this.newBackoff) {\n        var shouldUseNewBackoff = !this.usedBackoff || this.usedBackoff < this.newBackoff;\n        if (shouldUseNewBackoff) {\n          this.createRetrier();\n        } else {\n          var _this$retrier;\n          (_this$retrier = this.retrier) === null || _this$retrier === void 0 ? void 0 : _this$retrier.failed(new Error());\n        }\n      } else {\n        var _this$retrier2;\n        (_this$retrier2 = this.retrier) === null || _this$retrier2 === void 0 ? void 0 : _this$retrier2.failed(new Error());\n      }\n    }\n  }, {\n    key: \"cancel\",\n    value: function cancel() {\n      var _this$retrier3;\n      (_this$retrier3 = this.retrier) === null || _this$retrier3 === void 0 ? void 0 : _this$retrier3.cancel();\n    }\n  }, {\n    key: \"cleanRetrier\",\n    value: function cleanRetrier() {\n      var _this$retrier4, _this$retrier5;\n      (_this$retrier4 = this.retrier) === null || _this$retrier4 === void 0 ? void 0 : _this$retrier4.removeAllListeners();\n      (_this$retrier5 = this.retrier) === null || _this$retrier5 === void 0 ? void 0 : _this$retrier5.cancel();\n      this.retrier = null;\n    }\n  }, {\n    key: \"getRetryPolicy\",\n    value: function getRetryPolicy() {\n      var clone = _objectSpread({}, this.options);\n      if (this.newBackoff) {\n        clone.min = this.newBackoff;\n        clone.max = this.options.max && this.options.max > this.newBackoff ? this.options.max : this.newBackoff;\n      } // As we're always skipping first attempt we should add one extra if limit is present\n\n      clone.maxAttemptsCount = this.options.maxAttemptsCount ? this.options.maxAttemptsCount + 1 : undefined;\n      return clone;\n    }\n  }, {\n    key: \"createRetrier\",\n    value: function createRetrier() {\n      var _this2 = this;\n      this.cleanRetrier();\n      var retryPolicy = this.getRetryPolicy();\n      this.retrier = new operationRetrier.Retrier(retryPolicy);\n      this.retrier.once(\"attempt\", function () {\n        var _this2$retrier, _this2$retrier2;\n        (_this2$retrier = _this2.retrier) === null || _this2$retrier === void 0 ? void 0 : _this2$retrier.on(\"attempt\", function () {\n          return _this2.emit(\"attempt\");\n        });\n        (_this2$retrier2 = _this2.retrier) === null || _this2$retrier2 === void 0 ? void 0 : _this2$retrier2.failed(new Error(\"Skipping first attempt\"));\n      });\n      this.retrier.on(\"failed\", function (err) {\n        return _this2.emit(\"failed\", err);\n      });\n      this.usedBackoff = this.newBackoff;\n      this.newBackoff = null;\n      this.retrier.start(); // .catch(err => {});\n    }\n  }]);\n  return BackoffRetrier;\n}(EventEmitter);\nfunction _createSuper$5(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct$5();\n  return function _createSuperInternal() {\n    var Super = _getPrototypeOf__default['default'](Derived),\n      result;\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf__default['default'](this).constructor;\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n    return _possibleConstructorReturn__default['default'](this, result);\n  };\n}\nfunction _isNativeReflectConstruct$5() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n  try {\n    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\nvar DISCONNECTING_TIMEOUT = 3000; // Wraps asynchronous rescheduling\n// Just makes it simpler to find these hacks over the code\n// Currently there's exactly one instance of this in closeSocket()\n\nfunction trampoline(f) {\n  setTimeout(f, 0);\n}\n/**\n * Twilsock channel level protocol implementation\n */\n\nvar TwilsockChannel = /*#__PURE__*/function (_EventEmitter) {\n  _inherits__default['default'](TwilsockChannel, _EventEmitter);\n  var _super = _createSuper$5(TwilsockChannel);\n  function TwilsockChannel(websocket, transport, config) {\n    var _this;\n    _classCallCheck__default['default'](this, TwilsockChannel);\n    _this = _super.call(this);\n    _defineProperty__default['default'](_assertThisInitialized__default['default'](_this), \"disconnectingTimer\", null);\n    _defineProperty__default['default'](_assertThisInitialized__default['default'](_this), \"disconnectedPromiseResolve\", null);\n    _defineProperty__default['default'](_assertThisInitialized__default['default'](_this), \"terminalStates\", [\"disconnected\", \"rejected\"]);\n    _defineProperty__default['default'](_assertThisInitialized__default['default'](_this), \"tokenExpiredSasCode\", 20104);\n    _defineProperty__default['default'](_assertThisInitialized__default['default'](_this), \"terminationReason\", \"Connection is not initialized\");\n    _this.websocket = websocket;\n    _this.websocket.on(\"connected\", function () {\n      return _this.fsm.socketConnected();\n    });\n    _this.websocket.on(\"disconnected\", function () {\n      return _this.fsm.socketClosed();\n    });\n    _this.websocket.on(\"message\", function (message) {\n      return _this.onIncomingMessage(message);\n    });\n    _this.websocket.on(\"socketError\", function (e) {\n      return _this.emit(\"connectionError\", {\n        terminal: false,\n        message: \"Socket error: \".concat(e.message),\n        httpStatusCode: null,\n        errorCode: null\n      });\n    });\n    _this.transport = transport;\n    _this.config = config;\n    _this.retrier = new BackoffRetrier(config.retryPolicy);\n    _this.retrier.on(\"attempt\", function () {\n      return _this.retry();\n    });\n    _this.retrier.on(\"failed\", function (err) {\n      logInstance.warn(\"Retrying failed: \".concat(err.message));\n      _this.disconnect();\n    });\n    if (typeof window !== \"undefined\" && typeof window.addEventListener !== \"undefined\") {\n      window.addEventListener(\"online\", function () {\n        logInstance.debug(\"Browser reported connectivity state: online\");\n        _this.resetBackoff();\n        _this.fsm.systemOnline();\n      });\n      window.addEventListener(\"offline\", function () {\n        logInstance.debug(\"Browser reported connectivity state: offline\");\n        _this.websocket.close();\n        _this.fsm.socketClosed();\n      });\n    } // We have to use a factory function in here because using the default\n    // StateMachine constructor would cause an error for the consumers of the\n    // rollup bundles. This is a quirk unique to the javascript-state-machine\n    // library.\n\n    var TwilsockStateMachine = StateMachine__namespace.factory({\n      init: \"disconnected\",\n      transitions: [{\n        name: \"userConnect\",\n        from: [\"disconnected\", \"rejected\"],\n        to: \"connecting\"\n      }, {\n        name: \"userConnect\",\n        from: [\"connecting\", \"connected\"]\n      }, {\n        name: \"userDisconnect\",\n        from: [\"connecting\", \"initialising\", \"connected\", \"updating\", \"retrying\", \"rejected\", \"waitSocketClosed\", \"waitOffloadSocketClosed\"],\n        to: \"disconnecting\"\n      }, {\n        name: \"userRetry\",\n        from: [\"retrying\"],\n        to: \"connecting\"\n      }, {\n        name: \"socketConnected\",\n        from: [\"connecting\"],\n        to: \"initialising\"\n      }, {\n        name: \"socketClosed\",\n        from: [\"connecting\", \"initialising\", \"connected\", \"updating\", \"error\", \"waitOffloadSocketClosed\"],\n        to: \"retrying\"\n      }, {\n        name: \"socketClosed\",\n        from: [\"disconnecting\"],\n        to: \"disconnected\"\n      }, {\n        name: \"socketClosed\",\n        from: [\"waitSocketClosed\"],\n        to: \"disconnected\"\n      }, {\n        name: \"socketClosed\",\n        from: [\"rejected\"],\n        to: \"rejected\"\n      }, {\n        name: \"initSuccess\",\n        from: [\"initialising\"],\n        to: \"connected\"\n      }, {\n        name: \"initError\",\n        from: [\"initialising\"],\n        to: \"error\"\n      }, {\n        name: \"tokenRejected\",\n        from: [\"initialising\", \"updating\"],\n        to: \"rejected\"\n      }, {\n        name: \"protocolError\",\n        from: [\"initialising\", \"connected\", \"updating\"],\n        to: \"error\"\n      }, {\n        name: \"receiveClose\",\n        from: [\"initialising\", \"connected\", \"updating\"],\n        to: \"waitSocketClosed\"\n      }, {\n        name: \"receiveOffload\",\n        from: [\"initialising\", \"connected\", \"updating\"],\n        to: \"waitOffloadSocketClosed\"\n      }, {\n        name: \"unsupportedProtocol\",\n        from: [\"initialising\", \"connected\", \"updating\"],\n        to: \"unsupported\"\n      }, {\n        name: \"receiveFatalClose\",\n        from: [\"initialising\", \"connected\", \"updating\"],\n        to: \"unsupported\"\n      }, {\n        name: \"userUpdateToken\",\n        from: [\"disconnected\", \"rejected\", \"connecting\", \"retrying\"],\n        to: \"connecting\"\n      }, {\n        name: \"userUpdateToken\",\n        from: [\"connected\"],\n        to: \"updating\"\n      }, {\n        name: \"updateSuccess\",\n        from: [\"updating\"],\n        to: \"connected\"\n      }, {\n        name: \"updateError\",\n        from: [\"updating\"],\n        to: \"error\"\n      }, {\n        name: \"userSend\",\n        from: [\"connected\"],\n        to: \"connected\"\n      }, {\n        name: \"systemOnline\",\n        from: [\"retrying\"],\n        to: \"connecting\"\n      }],\n      methods: {\n        onConnecting: function onConnecting() {\n          _this.setupSocket();\n          _this.emit(\"connecting\");\n        },\n        onEnterInitialising: function onEnterInitialising() {\n          _this.sendInit();\n        },\n        onLeaveInitialising: function onLeaveInitialising() {\n          _this.cancelInit();\n        },\n        onEnterUpdating: function onEnterUpdating() {\n          _this.sendUpdate();\n        },\n        onLeaveUpdating: function onLeaveUpdating() {\n          _this.cancelUpdate();\n        },\n        onEnterRetrying: function onEnterRetrying() {\n          _this.initRetry();\n          _this.emit(\"connecting\");\n        },\n        onEnterConnected: function onEnterConnected() {\n          _this.resetBackoff();\n          _this.onConnected();\n        },\n        onUserUpdateToken: function onUserUpdateToken() {\n          _this.resetBackoff();\n        },\n        onTokenRejected: function onTokenRejected() {\n          _this.resetBackoff();\n          _this.closeSocket(true);\n          _this.finalizeSocket();\n        },\n        onUserDisconnect: function onUserDisconnect() {\n          _this.closeSocket(true);\n        },\n        onEnterDisconnecting: function onEnterDisconnecting() {\n          _this.startDisconnectTimer();\n        },\n        onLeaveDisconnecting: function onLeaveDisconnecting() {\n          _this.cancelDisconnectTimer();\n        },\n        onEnterWaitSocketClosed: function onEnterWaitSocketClosed() {\n          _this.startDisconnectTimer();\n        },\n        onLeaveWaitSocketClosed: function onLeaveWaitSocketClosed() {\n          _this.cancelDisconnectTimer();\n        },\n        onEnterWaitOffloadSocketClosed: function onEnterWaitOffloadSocketClosed() {\n          _this.startDisconnectTimer();\n        },\n        onLeaveWaitOffloadSocketClosed: function onLeaveWaitOffloadSocketClosed() {\n          _this.cancelDisconnectTimer();\n        },\n        onDisconnected: function onDisconnected() {\n          _this.resetBackoff();\n          _this.finalizeSocket();\n        },\n        onReceiveClose: function onReceiveClose() {\n          _this.onCloseReceived();\n        },\n        onReceiveOffload: function onReceiveOffload(event, args) {\n          logInstance.debug(\"onreceiveoffload: \", args);\n          _this.modifyBackoff(args.body);\n          _this.onCloseReceived();\n        },\n        onUnsupported: function onUnsupported() {\n          _this.closeSocket(true);\n          _this.finalizeSocket();\n        },\n        onError: function onError(lifecycle, graceful) {\n          _this.closeSocket(graceful);\n          _this.finalizeSocket();\n        },\n        onEnterState: function onEnterState(event) {\n          if (event.from !== \"none\") {\n            _this.changeState(event);\n          }\n        },\n        onInvalidTransition: function onInvalidTransition(transition, from, to) {\n          logInstance.warn(\"FSM: unexpected transition\", from, to);\n        }\n      }\n    });\n    _this.fsm = new TwilsockStateMachine();\n    return _this;\n  }\n  _createClass__default['default'](TwilsockChannel, [{\n    key: \"changeState\",\n    value: function changeState(event) {\n      logInstance.debug(\"FSM: \".concat(event.transition, \": \").concat(event.from, \" --> \").concat(event.to));\n      if (this.lastEmittedState !== this.state) {\n        this.lastEmittedState = this.state;\n        this.emit(\"stateChanged\", this.state);\n      }\n    }\n  }, {\n    key: \"resetBackoff\",\n    value: function resetBackoff() {\n      logInstance.trace(\"resetBackoff\");\n      this.retrier.stop();\n    }\n  }, {\n    key: \"modifyBackoff\",\n    value: function modifyBackoff(body) {\n      logInstance.trace(\"modifyBackoff\", body);\n      var backoffPolicy = body ? body.backoff_policy : null;\n      if (backoffPolicy && typeof backoffPolicy.reconnect_min_ms === \"number\") {\n        this.retrier.modifyBackoff(backoffPolicy.reconnect_min_ms);\n      }\n    }\n  }, {\n    key: \"startDisconnectTimer\",\n    value: function startDisconnectTimer() {\n      var _this2 = this;\n      logInstance.trace(\"startDisconnectTimer\");\n      if (this.disconnectingTimer) {\n        clearTimeout(this.disconnectingTimer);\n        this.disconnectingTimer = null;\n      }\n      this.disconnectingTimer = setTimeout(function () {\n        logInstance.debug(\"disconnecting is timed out\");\n        _this2.closeSocket(true);\n      }, DISCONNECTING_TIMEOUT);\n    }\n  }, {\n    key: \"cancelDisconnectTimer\",\n    value: function cancelDisconnectTimer() {\n      logInstance.trace(\"cancelDisconnectTimer\");\n      if (this.disconnectingTimer) {\n        clearTimeout(this.disconnectingTimer);\n        this.disconnectingTimer = null;\n      }\n    }\n  }, {\n    key: \"isConnected\",\n    get: function get() {\n      return this.state === \"connected\" && this.websocket.isConnected;\n    }\n  }, {\n    key: \"state\",\n    get: function get() {\n      switch (this.fsm.state) {\n        case \"connecting\":\n        case \"initialising\":\n        case \"retrying\":\n        case \"error\":\n          return \"connecting\";\n        case \"updating\":\n        case \"connected\":\n          return \"connected\";\n        case \"rejected\":\n          return \"denied\";\n        case \"disconnecting\":\n        case \"waitSocketClosed\":\n        case \"waitOffloadSocketClosed\":\n          return \"disconnecting\";\n        case \"disconnected\":\n        default:\n          return \"disconnected\";\n      }\n    }\n  }, {\n    key: \"initRetry\",\n    value: function initRetry() {\n      logInstance.debug(\"initRetry\");\n      if (this.retrier.inProgress) {\n        this.retrier.attemptFailed();\n      } else {\n        this.retrier.start();\n      }\n    }\n  }, {\n    key: \"retry\",\n    value: function retry() {\n      if (this.fsm.state != \"connecting\") {\n        logInstance.trace(\"retry\");\n        this.websocket.close();\n        this.fsm.userRetry();\n      } else {\n        logInstance.trace(\"can\\t retry as already connecting\");\n      }\n    }\n  }, {\n    key: \"onConnected\",\n    value: function onConnected() {\n      this.emit(\"connected\");\n    }\n  }, {\n    key: \"finalizeSocket\",\n    value: function finalizeSocket() {\n      logInstance.trace(\"finalizeSocket\");\n      this.websocket.close();\n      this.emit(\"disconnected\");\n      if (this.disconnectedPromiseResolve) {\n        this.disconnectedPromiseResolve();\n        this.disconnectedPromiseResolve = null;\n      }\n    }\n  }, {\n    key: \"setupSocket\",\n    value: function setupSocket() {\n      logInstance.trace(\"setupSocket:\", this.config.token);\n      this.emit(\"beforeConnect\"); // This is used by client to record startup telemetry event\n\n      this.websocket.connect();\n    }\n  }, {\n    key: \"onIncomingMessage\",\n    value: function onIncomingMessage(message) {\n      var parsedMessage = Parser.parse(message);\n      if (!parsedMessage) {\n        return;\n      }\n      var method = parsedMessage.method,\n        header = parsedMessage.header,\n        payload = parsedMessage.payload;\n      if (method !== \"reply\") {\n        this.confirmReceiving(header);\n      }\n      if (method === \"notification\") {\n        this.emit(\"message\", header.message_type, payload);\n      } else if (header.method === \"reply\") {\n        this.transport.processReply({\n          id: header.id,\n          status: header.status,\n          header: header,\n          body: payload\n        });\n      } else if (header.method === \"client_update\") {\n        if (header.client_update_type === \"token_about_to_expire\") {\n          this.emit(\"tokenAboutToExpire\");\n        }\n      } else if (header.method === \"close\") {\n        if (header.status.code === 308) {\n          logInstance.debug(\"Connection has been offloaded\");\n          this.fsm.receiveOffload({\n            status: header.status.status,\n            body: payload\n          });\n        } else if (header.status.code === 406) {\n          // Not acceptable message\n          var _message = \"Server closed connection because can't parse protocol: \".concat(JSON.stringify(header.status));\n          this.emitReplyConnectionError(_message, header, true);\n          logInstance.error(_message);\n          this.fsm.receiveFatalClose();\n        } else if (header.status.code === 417) {\n          // Protocol error\n          logInstance.error(\"Server closed connection because can't parse client reply: \".concat(JSON.stringify(header.status)));\n          this.fsm.receiveFatalClose(header.status.status);\n        } else if (header.status.code === 410) {\n          // Expired token\n          logInstance.warn(\"Server closed connection: \".concat(JSON.stringify(header.status)));\n          this.fsm.receiveClose(header.status.status);\n          this.emit(\"tokenExpired\");\n        } else if (header.status.code === 401) {\n          // Authentication fail\n          logInstance.error(\"Server closed connection: \".concat(JSON.stringify(header.status)));\n          this.fsm.receiveClose(header.status.status);\n        } else {\n          logInstance.warn(\"unexpected message: \", header.status); // Try to reconnect\n\n          this.fsm.receiveOffload({\n            status: header.status.status,\n            body: null\n          });\n        }\n      }\n    }\n  }, {\n    key: \"sendInit\",\n    value: function () {\n      var _sendInit = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee() {\n        var reply, isTerminalError;\n        return _regeneratorRuntime__default['default'].wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                logInstance.trace(\"sendInit\");\n                _context.prev = 1;\n                this.emit(\"beforeSendInit\"); // This is used by client to record startup telemetry event\n\n                _context.next = 5;\n                return this.transport.sendInit();\n              case 5:\n                reply = _context.sent;\n                this.config.updateContinuationToken(reply.continuationToken);\n                this.config.confirmedCapabilities = reply.confirmedCapabilities;\n                this.fsm.initSuccess(reply);\n                this.emit(\"initialized\", reply);\n                this.emit(\"tokenUpdated\");\n                _context.next = 17;\n                break;\n              case 13:\n                _context.prev = 13;\n                _context.t0 = _context[\"catch\"](1);\n                if (_context.t0 instanceof TwilsockReplyError) {\n                  isTerminalError = false;\n                  logInstance.warn(\"Init rejected by server: \".concat(JSON.stringify(_context.t0.reply.status)));\n                  this.emit(\"sendInitFailed\"); // This is used by client to record startup telemetry event\n                  // @todo emit telemetry from inside \"if\" below for more granularity...\n\n                  if (_context.t0.reply.status.code === 401 || _context.t0.reply.status.code === 403) {\n                    isTerminalError = true;\n                    this.fsm.tokenRejected(_context.t0.reply.status);\n                    if (_context.t0.reply.status.errorCode === this.tokenExpiredSasCode) {\n                      this.emit(\"tokenExpired\");\n                    }\n                  } else if (_context.t0.reply.status.code === 429) {\n                    this.modifyBackoff(_context.t0.reply.body);\n                    this.fsm.initError(true);\n                  } else if (_context.t0.reply.status.code === 500) {\n                    this.fsm.initError(false);\n                  } else {\n                    this.fsm.initError(true);\n                  }\n                  this.emitReplyConnectionError(_context.t0.message, _context.t0.reply, isTerminalError);\n                } else {\n                  this.terminationReason = _context.t0.message;\n                  this.emit(\"connectionError\", {\n                    terminal: true,\n                    message: \"Unknown error during connection initialisation: \".concat(_context.t0.message, \"\\n\").concat(JSON.stringify(_context.t0, null, 2)),\n                    httpStatusCode: null,\n                    errorCode: null\n                  });\n                  this.fsm.initError(true);\n                }\n                this.emit(\"tokenUpdated\", _context.t0);\n              case 17:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this, [[1, 13]]);\n      }));\n      function sendInit() {\n        return _sendInit.apply(this, arguments);\n      }\n      return sendInit;\n    }()\n  }, {\n    key: \"sendUpdate\",\n    value: function () {\n      var _sendUpdate = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee2() {\n        var message, reply, isTerminalError;\n        return _regeneratorRuntime__default['default'].wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                logInstance.trace(\"sendUpdate\");\n                message = new Update(this.config.token);\n                _context2.prev = 2;\n                _context2.next = 5;\n                return this.transport.sendWithReply(message);\n              case 5:\n                reply = _context2.sent;\n                this.fsm.updateSuccess(reply.body);\n                this.emit(\"tokenUpdated\");\n                _context2.next = 14;\n                break;\n              case 10:\n                _context2.prev = 10;\n                _context2.t0 = _context2[\"catch\"](2);\n                if (_context2.t0 instanceof TwilsockReplyError) {\n                  isTerminalError = false;\n                  logInstance.warn(\"Token update rejected by server: \".concat(JSON.stringify(_context2.t0.reply.status)));\n                  if (_context2.t0.reply.status.code === 401 || _context2.t0.reply.status.code === 403) {\n                    isTerminalError = true;\n                    this.fsm.tokenRejected(_context2.t0.reply.status);\n                    if (_context2.t0.reply.status.errorCode === this.tokenExpiredSasCode) {\n                      this.emit(\"tokenExpired\");\n                    }\n                  } else if (_context2.t0.reply.status.code === 429) {\n                    this.modifyBackoff(_context2.t0.reply.body);\n                    this.fsm.updateError(_context2.t0.reply.status);\n                  } else {\n                    this.fsm.updateError(_context2.t0.reply.status);\n                  }\n                  this.emitReplyConnectionError(_context2.t0.message, _context2.t0.reply, isTerminalError);\n                } else {\n                  this.emit(\"error\", false, _context2.t0.message, null, null);\n                  this.fsm.updateError(_context2.t0);\n                }\n                this.emit(\"tokenUpdated\", _context2.t0);\n              case 14:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this, [[2, 10]]);\n      }));\n      function sendUpdate() {\n        return _sendUpdate.apply(this, arguments);\n      }\n      return sendUpdate;\n    }()\n  }, {\n    key: \"emitReplyConnectionError\",\n    value: function emitReplyConnectionError(message, header, terminal) {\n      var description = header.status && header.status.description ? header.status.description : message;\n      var httpStatusCode = header.status.code;\n      var errorCode = header.status && header.status.errorCode ? header.status.errorCode : null;\n      if (terminal) {\n        this.terminationReason = description;\n      }\n      this.emit(\"connectionError\", {\n        terminal: terminal,\n        message: \"Connection error: \".concat(description),\n        httpStatusCode: httpStatusCode,\n        errorCode: errorCode\n      });\n    }\n  }, {\n    key: \"cancelInit\",\n    value: function cancelInit() {\n      logInstance.trace(\"cancelInit\"); // TODO: implement\n    }\n  }, {\n    key: \"cancelUpdate\",\n    value: function cancelUpdate() {\n      logInstance.trace(\"cancelUpdate\"); // TODO: implement\n    }\n    /**\n     * Should be called for each message to confirm it received\n     */\n  }, {\n    key: \"confirmReceiving\",\n    value: function confirmReceiving(messageHeader) {\n      logInstance.trace(\"confirmReceiving\");\n      try {\n        //@todo send telemetry events AnyEvents\n        this.transport.send(new Reply(messageHeader.id));\n      } catch (e) {\n        logInstance.debug(\"failed to confirm packet receiving\", e);\n      }\n    }\n    /**\n     * Shutdown connection\n     */\n  }, {\n    key: \"closeSocket\",\n    value: function closeSocket(graceful) {\n      var _this3 = this;\n      logInstance.trace(\"closeSocket (graceful: \".concat(graceful, \")\"));\n      if (graceful && this.transport.isConnected) {\n        this.transport.sendClose();\n      }\n      this.websocket.close();\n      trampoline(function () {\n        return _this3.fsm.socketClosed();\n      });\n    }\n    /**\n     * Initiate the twilsock connection\n     * If already connected, it does nothing\n     */\n  }, {\n    key: \"connect\",\n    value: function connect() {\n      logInstance.trace(\"connect\");\n      this.fsm.userConnect();\n    }\n    /**\n     * Close twilsock connection\n     * If already disconnected, it does nothing\n     */\n  }, {\n    key: \"disconnect\",\n    value: function disconnect() {\n      var _this4 = this;\n      logInstance.trace(\"disconnect\");\n      if (this.fsm.is(\"disconnected\")) {\n        return Promise.resolve();\n      }\n      return new Promise(function (resolve) {\n        _this4.disconnectedPromiseResolve = resolve;\n        _this4.fsm.userDisconnect();\n      });\n    }\n    /**\n     * Update fpa token for twilsock connection\n     */\n  }, {\n    key: \"updateToken\",\n    value: function updateToken(token) {\n      var _this5 = this;\n      logInstance.trace(\"updateToken:\", token);\n      return new Promise(function (resolve, reject) {\n        _this5.once(\"tokenUpdated\", function (e) {\n          if (e) {\n            reject(e);\n          } else {\n            resolve();\n          }\n        });\n        _this5.fsm.userUpdateToken();\n      });\n    }\n  }, {\n    key: \"isTerminalState\",\n    get: function get() {\n      return this.terminalStates.indexOf(this.fsm.state) !== -1;\n    }\n  }, {\n    key: \"getTerminationReason\",\n    get: function get() {\n      return this.terminationReason;\n    }\n  }, {\n    key: \"onCloseReceived\",\n    value: function onCloseReceived() {\n      this.websocket.close();\n    }\n  }]);\n  return TwilsockChannel;\n}(EventEmitter);\nvar Metadata = /*#__PURE__*/function () {\n  function Metadata() {\n    _classCallCheck__default['default'](this, Metadata);\n  }\n  _createClass__default['default'](Metadata, null, [{\n    key: \"getMetadata\",\n    value: function getMetadata(options) {\n      var _platform$name, _platform$version, _platform$os$family, _platform$os, _platform$os$version, _platform$os2, _platform$os$architec, _platform$os3;\n      var overrides = options && options.clientMetadata ? options.clientMetadata : {};\n      var fieldNames = [\"ver\", \"env\", \"envv\", \"os\", \"osv\", \"osa\", \"type\", \"sdk\", \"sdkv\", \"dev\", \"devv\", \"devt\", \"app\", \"appv\"];\n      var defaults = {\n        env: (_platform$name = platform__namespace.name) !== null && _platform$name !== void 0 ? _platform$name : \"unknown\",\n        envv: (_platform$version = platform__namespace.version) !== null && _platform$version !== void 0 ? _platform$version : \"unknown\",\n        os: (_platform$os$family = (_platform$os = platform__namespace.os) === null || _platform$os === void 0 ? void 0 : _platform$os.family) !== null && _platform$os$family !== void 0 ? _platform$os$family : \"unknown\",\n        osv: (_platform$os$version = (_platform$os2 = platform__namespace.os) === null || _platform$os2 === void 0 ? void 0 : _platform$os2.version) !== null && _platform$os$version !== void 0 ? _platform$os$version : \"unknown\",\n        osa: (_platform$os$architec = (_platform$os3 = platform__namespace.os) === null || _platform$os3 === void 0 ? void 0 : _platform$os3.architecture) !== null && _platform$os$architec !== void 0 ? _platform$os$architec : \"unknown\",\n        sdk: \"js-default\"\n      };\n      var finalClientMetadata = {};\n      fieldNames.filter(function (key) {\n        return key in overrides || key in defaults;\n      }).forEach(function (key) {\n        return finalClientMetadata[key] = key in overrides ? overrides[key] : defaults[key];\n      });\n      return finalClientMetadata;\n    }\n  }]);\n  return Metadata;\n}();\nvar REQUEST_TIMEOUT$1 = 30000;\nfunction isHttpSuccess$1(code) {\n  return code >= 200 && code < 300;\n}\n/**\n * Makes sure that body is properly stringified\n */\n\nfunction preparePayload(payload) {\n  switch (_typeof__default['default'](payload)) {\n    case \"undefined\":\n      return \"\";\n    case \"object\":\n      return JSON.stringify(payload);\n    default:\n      return payload;\n  }\n}\nvar PacketInterface = /*#__PURE__*/function () {\n  function PacketInterface(channel, config) {\n    var _this = this;\n    _classCallCheck__default['default'](this, PacketInterface);\n    this.config = config;\n    this.activeRequests = new Map();\n    this.channel = channel;\n    this.channel.on(\"reply\", function (reply) {\n      return _this.processReply(reply);\n    });\n    this.channel.on(\"disconnected\", function () {\n      _this.activeRequests.forEach(function (descriptor) {\n        clearTimeout(descriptor.timeout);\n        descriptor.reject(new TwilsockError(\"disconnected\"));\n      });\n      _this.activeRequests.clear();\n    });\n  }\n  _createClass__default['default'](PacketInterface, [{\n    key: \"isConnected\",\n    get: function get() {\n      return this.channel.isConnected;\n    }\n  }, {\n    key: \"processReply\",\n    value: function processReply(reply) {\n      var request = this.activeRequests.get(reply.id);\n      if (request) {\n        clearTimeout(request.timeout);\n        this.activeRequests.delete(reply.id);\n        if (!isHttpSuccess$1(reply.status.code)) {\n          request.reject(new TwilsockReplyError(\"Transport failure: \" + reply.status.status, reply));\n          logInstance.trace(\"message rejected\");\n        } else {\n          request.resolve(reply);\n        }\n      }\n    }\n  }, {\n    key: \"storeRequest\",\n    value: function storeRequest(id, resolve, reject) {\n      var requestDescriptor = {\n        resolve: resolve,\n        reject: reject,\n        timeout: setTimeout(function () {\n          logInstance.trace(\"request\", id, \"is timed out\");\n          reject(new TwilsockError(\"Twilsock: request timeout: \" + id));\n        }, REQUEST_TIMEOUT$1)\n      };\n      this.activeRequests.set(id, requestDescriptor);\n    }\n  }, {\n    key: \"shutdown\",\n    value: function shutdown() {\n      this.activeRequests.forEach(function (descriptor) {\n        clearTimeout(descriptor.timeout);\n        descriptor.reject(new TwilsockError(\"Twilsock: request cancelled by user\"));\n      });\n      this.activeRequests.clear();\n    }\n  }, {\n    key: \"sendInit\",\n    value: function () {\n      var _sendInit = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee() {\n        var metadata, message, response;\n        return _regeneratorRuntime__default['default'].wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                logInstance.trace(\"sendInit\");\n                metadata = Metadata.getMetadata(this.config);\n                message = new Init(this.config.token, this.config.continuationToken, metadata, this.config.initRegistrations, this.config.tweaks);\n                _context.next = 5;\n                return this.sendWithReply(message);\n              case 5:\n                response = _context.sent;\n                return _context.abrupt(\"return\", new InitReply(response.id, response.header.continuation_token, new Set(response.header.capabilities), response.header.continuation_token_status, response.header.offline_storage, response.header.init_registrations, response.header.debug_info));\n              case 7:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n      function sendInit() {\n        return _sendInit.apply(this, arguments);\n      }\n      return sendInit;\n    }()\n  }, {\n    key: \"sendClose\",\n    value: function sendClose() {\n      var message = new Close(); //@todo send telemetry AnyEventsIncludingUnfinished\n\n      this.send(message);\n    }\n  }, {\n    key: \"sendWithReply\",\n    value: function sendWithReply(header, payload) {\n      var _this2 = this;\n      return new Promise(function (resolve, reject) {\n        var id = _this2.send(header, payload);\n        _this2.storeRequest(id, resolve, reject);\n      });\n    }\n  }, {\n    key: \"send\",\n    value: function send(header, payload) {\n      header.id = header.id || \"TM\".concat(uuid.v4());\n      var message = Parser.createPacket(header, preparePayload(payload));\n      try {\n        this.channel.send(message);\n        return header.id;\n      } catch (e) {\n        logInstance.debug(\"failed to send \", header, e);\n        logInstance.trace(e.stack);\n        throw e;\n      }\n    }\n  }]);\n  return PacketInterface;\n}();\nfunction _createSuper$4(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct$4();\n  return function _createSuperInternal() {\n    var Super = _getPrototypeOf__default['default'](Derived),\n      result;\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf__default['default'](this).constructor;\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n    return _possibleConstructorReturn__default['default'](this, result);\n  };\n}\nfunction _isNativeReflectConstruct$4() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n  try {\n    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\nvar WebSocketChannel = /*#__PURE__*/function (_EventEmitter) {\n  _inherits__default['default'](WebSocketChannel, _EventEmitter);\n  var _super = _createSuper$4(WebSocketChannel);\n  function WebSocketChannel(url) {\n    var _this;\n    _classCallCheck__default['default'](this, WebSocketChannel);\n    _this = _super.call(this);\n    _defineProperty__default['default'](_assertThisInitialized__default['default'](_this), \"socket\", null);\n    _this.url = url;\n    _this.url = url;\n    _this.WebSocket = global[\"WebSocket\"] || global[\"MozWebSocket\"] || {};\n    return _this;\n  }\n  _createClass__default['default'](WebSocketChannel, [{\n    key: \"isConnected\",\n    get: function get() {\n      return !!this.socket && this.socket.readyState === 1;\n    }\n  }, {\n    key: \"connect\",\n    value: function connect() {\n      var _this2 = this;\n      logInstance.trace(\"connecting to socket\");\n      var socket;\n      try {\n        socket = new this.WebSocket(this.url);\n      } catch (e) {\n        logInstance.debug(\"Socket error: \".concat(this.url));\n        this.emit(\"socketError\", e);\n        return;\n      }\n      socket.binaryType = \"arraybuffer\";\n      socket.onopen = function () {\n        logInstance.debug(\"socket opened \".concat(_this2.url));\n        _this2.emit(\"connected\");\n      };\n      socket.onclose = function (e) {\n        logInstance.debug(\"socket closed\", e);\n        _this2.emit(\"disconnected\", e);\n      };\n      socket.onerror = function (e) {\n        logInstance.debug(\"Socket error:\", e);\n        _this2.emit(\"socketError\", e);\n      };\n      socket.onmessage = function (message) {\n        _this2.emit(\"message\", message.data);\n      };\n      this.socket = socket;\n    }\n  }, {\n    key: \"send\",\n    value: function send(message) {\n      return this.socket && this.socket.send(message);\n    }\n  }, {\n    key: \"close\",\n    value: function close() {\n      logInstance.trace(\"closing socket\");\n      if (this.socket) {\n        this.socket.onopen = null;\n        this.socket.onclose = null;\n        this.socket.onerror = null;\n        this.socket.onmessage = null;\n        try {\n          this.socket.close();\n        } finally {}\n      }\n    }\n  }]);\n  return WebSocketChannel;\n}(EventEmitter);\nfunction _createSuper$3(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct$3();\n  return function _createSuperInternal() {\n    var Super = _getPrototypeOf__default['default'](Derived),\n      result;\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf__default['default'](this).constructor;\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n    return _possibleConstructorReturn__default['default'](this, result);\n  };\n}\nfunction _isNativeReflectConstruct$3() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n  try {\n    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n/**\n * Registrations module handles all operations with registration contexts through twilsock.\n * Main role: it automatically refreshes all registrations after reconnect.\n */\n\nvar Registrations = /*#__PURE__*/function (_EventEmitter) {\n  _inherits__default['default'](Registrations, _EventEmitter);\n  var _super = _createSuper$3(Registrations);\n  function Registrations(transport) {\n    var _this;\n    _classCallCheck__default['default'](this, Registrations);\n    _this = _super.call(this);\n    _this.transport = transport;\n    _this.registrations = new Map();\n    _this.registrationsInProgress = new Map();\n    return _this;\n  }\n  _createClass__default['default'](Registrations, [{\n    key: \"putNotificationContext\",\n    value: function () {\n      var _putNotificationContext = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee(contextId, context) {\n        var header;\n        return _regeneratorRuntime__default['default'].wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                header = {\n                  method: \"put_notification_ctx\",\n                  notification_ctx_id: contextId\n                };\n                _context.next = 3;\n                return this.transport.sendWithReply(header, context);\n              case 3:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n      function putNotificationContext(_x, _x2) {\n        return _putNotificationContext.apply(this, arguments);\n      }\n      return putNotificationContext;\n    }()\n  }, {\n    key: \"deleteNotificationContext\",\n    value: function () {\n      var _deleteNotificationContext = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee2(contextId) {\n        var message;\n        return _regeneratorRuntime__default['default'].wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                message = {\n                  method: \"delete_notification_ctx\",\n                  notification_ctx_id: contextId\n                };\n                _context2.next = 3;\n                return this.transport.sendWithReply(message);\n              case 3:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n      function deleteNotificationContext(_x3) {\n        return _deleteNotificationContext.apply(this, arguments);\n      }\n      return deleteNotificationContext;\n    }()\n  }, {\n    key: \"updateRegistration\",\n    value: function () {\n      var _updateRegistration = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee3(contextId, context) {\n        var registrationAttempts, attemptId;\n        return _regeneratorRuntime__default['default'].wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                logInstance.debug(\"update registration for context\", contextId);\n                registrationAttempts = this.registrationsInProgress.get(contextId);\n                if (!registrationAttempts) {\n                  registrationAttempts = new Set();\n                  this.registrationsInProgress.set(contextId, registrationAttempts);\n                }\n                attemptId = uuid.v4();\n                registrationAttempts.add(attemptId);\n                _context3.prev = 5;\n                _context3.next = 8;\n                return this.putNotificationContext(contextId, context);\n              case 8:\n                logInstance.debug(\"registration attempt succeeded for context\", context);\n                registrationAttempts.delete(attemptId);\n                if (registrationAttempts.size === 0) {\n                  this.registrationsInProgress.delete(contextId);\n                  this.emit(\"registered\", contextId);\n                }\n                _context3.next = 19;\n                break;\n              case 13:\n                _context3.prev = 13;\n                _context3.t0 = _context3[\"catch\"](5);\n                logInstance.warn(\"registration attempt failed for context\", context);\n                logInstance.debug(_context3.t0);\n                registrationAttempts.delete(attemptId);\n                if (registrationAttempts.size === 0) {\n                  this.registrationsInProgress.delete(contextId);\n                  this.emit(\"registrationFailed\", contextId, _context3.t0);\n                }\n              case 19:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this, [[5, 13]]);\n      }));\n      function updateRegistration(_x4, _x5) {\n        return _updateRegistration.apply(this, arguments);\n      }\n      return updateRegistration;\n    }()\n  }, {\n    key: \"updateRegistrations\",\n    value: function () {\n      var _updateRegistrations = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee4() {\n        var _this2 = this;\n        var promises;\n        return _regeneratorRuntime__default['default'].wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                logInstance.trace(\"refreshing \".concat(this.registrations.size, \" registrations\"));\n                promises = [];\n                this.registrations.forEach(function (context, id) {\n                  promises.push(_this2.updateRegistration(id, context));\n                });\n                _context4.next = 5;\n                return Promise.all(promises);\n              case 5:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n      function updateRegistrations() {\n        return _updateRegistrations.apply(this, arguments);\n      }\n      return updateRegistrations;\n    }()\n  }, {\n    key: \"setNotificationsContext\",\n    value: function () {\n      var _setNotificationsContext = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee5(contextId, context) {\n        return _regeneratorRuntime__default['default'].wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                if (!(!contextId || !context)) {\n                  _context5.next = 2;\n                  break;\n                }\n                throw new TwilsockError(\"Invalid arguments provided\");\n              case 2:\n                this.registrations.set(contextId, context);\n                _context5.next = 5;\n                return this.updateRegistration(contextId, context);\n              case 5:\n                return _context5.abrupt(\"return\", _context5.sent);\n              case 6:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this);\n      }));\n      function setNotificationsContext(_x6, _x7) {\n        return _setNotificationsContext.apply(this, arguments);\n      }\n      return setNotificationsContext;\n    }()\n  }, {\n    key: \"removeNotificationsContext\",\n    value: function () {\n      var _removeNotificationsContext = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee6(contextId) {\n        return _regeneratorRuntime__default['default'].wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                if (this.registrations.has(contextId)) {\n                  _context6.next = 2;\n                  break;\n                }\n                return _context6.abrupt(\"return\");\n              case 2:\n                _context6.next = 4;\n                return this.deleteNotificationContext(contextId);\n              case 4:\n                if (this.transport.isConnected) {\n                  this.registrations.delete(contextId);\n                }\n              case 5:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6, this);\n      }));\n      function removeNotificationsContext(_x8) {\n        return _removeNotificationsContext.apply(this, arguments);\n      }\n      return removeNotificationsContext;\n    }()\n  }]);\n  return Registrations;\n}(EventEmitter);\nfunction _createSuper$2(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct$2();\n  return function _createSuperInternal() {\n    var Super = _getPrototypeOf__default['default'](Derived),\n      result;\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf__default['default'](this).constructor;\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n    return _possibleConstructorReturn__default['default'](this, result);\n  };\n}\nfunction _isNativeReflectConstruct$2() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n  try {\n    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\nvar TwilsockUpstreamError = /*#__PURE__*/function (_TwilsockError) {\n  _inherits__default['default'](TwilsockUpstreamError, _TwilsockError);\n  var _super = _createSuper$2(TwilsockUpstreamError);\n  function TwilsockUpstreamError(status, description, body) {\n    var _this;\n    _classCallCheck__default['default'](this, TwilsockUpstreamError);\n    _this = _super.call(this, description);\n    _this.status = status;\n    _this.description = description;\n    _this.body = body;\n    return _this;\n  }\n  return TwilsockUpstreamError;\n}(TwilsockError);\nfunction _createSuper$1(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct$1();\n  return function _createSuperInternal() {\n    var Super = _getPrototypeOf__default['default'](Derived),\n      result;\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf__default['default'](this).constructor;\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n    return _possibleConstructorReturn__default['default'](this, result);\n  };\n}\nfunction _isNativeReflectConstruct$1() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n  try {\n    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\nvar TransportUnavailableError = /*#__PURE__*/function (_TwilsockError) {\n  _inherits__default['default'](TransportUnavailableError, _TwilsockError);\n  var _super = _createSuper$1(TransportUnavailableError);\n  function TransportUnavailableError(description) {\n    _classCallCheck__default['default'](this, TransportUnavailableError);\n    return _super.call(this, description);\n  }\n  return TransportUnavailableError;\n}(TwilsockError);\nvar REQUEST_TIMEOUT = 20000;\nfunction isHttpSuccess(code) {\n  return code >= 200 && code < 300;\n}\nfunction isHttpReply(packet) {\n  return packet && packet.header && packet.header.http_status;\n}\nfunction parseUri(uri) {\n  var match = uri.match(/^(https?\\:)\\/\\/(([^:\\/?#]*)(?:\\:([0-9]+))?)(\\/[^?#]*)(\\?[^#]*|)(#.*|)$/);\n  if (match) {\n    var uriStruct = {\n      protocol: match[1],\n      host: match[2],\n      hostname: match[3],\n      port: match[4],\n      pathname: match[5],\n      search: match[6],\n      hash: match[7],\n      params: {}\n    };\n    if (uriStruct.search.length > 0) {\n      var paramsString = uriStruct.search.substring(1);\n      uriStruct.params = paramsString.split(\"&\").map(function (el) {\n        return el.split(\"=\");\n      }).reduce(function (prev, curr) {\n        if (!prev.hasOwnProperty(curr[0])) {\n          prev[curr[0]] = curr[1];\n        } else if (Array.isArray(prev[curr[0]])) {\n          prev[curr[0]].push(curr[1]);\n        } else {\n          prev[curr[0]] = [prev[curr[0]], curr[1]];\n        }\n        return prev;\n      }, {});\n    }\n    return uriStruct;\n  }\n  throw new TwilsockError(\"Incorrect URI: \" + uri);\n}\nfunction twilsockAddress(method, uri) {\n  var parsedUri = parseUri(uri);\n  var to = {\n    method: method,\n    host: parsedUri.host,\n    path: parsedUri.pathname\n  };\n  if (parsedUri.params) {\n    to.params = parsedUri.params;\n  }\n  return to;\n}\nfunction twilsockParams(method, uri, headers, body, grant) {\n  return {\n    to: twilsockAddress(method, uri),\n    headers: headers,\n    body: body,\n    grant: grant\n  };\n}\nvar Upstream = /*#__PURE__*/function () {\n  function Upstream(transport, twilsock, config) {\n    _classCallCheck__default['default'](this, Upstream);\n    this.config = config;\n    this.transport = transport;\n    this.pendingMessages = [];\n    this.twilsock = twilsock;\n  }\n  _createClass__default['default'](Upstream, [{\n    key: \"saveMessage\",\n    value: function saveMessage(message) {\n      var _this = this;\n      return new Promise(function (resolve, reject) {\n        var requestDescriptor = {\n          message: message,\n          resolve: resolve,\n          reject: reject,\n          alreadyRejected: false,\n          timeout: setTimeout(function () {\n            logInstance.debug(\"request is timed out\");\n            reject(new TwilsockError(\"request '\".concat(message.to.method, \"' to '\").concat(message.to.host, \"' timed out\")));\n            requestDescriptor.alreadyRejected = true;\n          }, REQUEST_TIMEOUT)\n        };\n        _this.pendingMessages.push(requestDescriptor);\n      });\n    }\n  }, {\n    key: \"sendPendingMessages\",\n    value: function sendPendingMessages() {\n      var _this2 = this;\n      var _loop = function _loop() {\n        var request = _this2.pendingMessages[0]; // Do not send message if we've rejected its promise already\n\n        if (!request.alreadyRejected) {\n          try {\n            var message = request.message;\n            _this2.actualSend(message).then(function (response) {\n              return request.resolve(response);\n            }).catch(function (e) {\n              return request.reject(e);\n            });\n            clearTimeout(request.timeout);\n          } catch (e) {\n            logInstance.debug(\"Failed to send pending message\", e);\n            return \"break\";\n          }\n        }\n        _this2.pendingMessages.splice(0, 1);\n      };\n      while (this.pendingMessages.length > 0) {\n        var _ret = _loop();\n        if (_ret === \"break\") break;\n      }\n    }\n  }, {\n    key: \"rejectPendingMessages\",\n    value: function rejectPendingMessages() {\n      var _this3 = this;\n      this.pendingMessages.forEach(function (message) {\n        message.reject(new TransportUnavailableError(\n        // @todo Error Unhandled promise rejection!\n        \"Unable to connect: \" + _this3.twilsock.getTerminationReason));\n        message.alreadyRejected = true;\n        clearTimeout(message.timeout);\n      });\n      this.pendingMessages.splice(0, this.pendingMessages.length);\n    }\n  }, {\n    key: \"actualSend\",\n    value: function () {\n      var _actualSend = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee(message) {\n        var _message$grant;\n        var address, headers, body, grant, httpRequest, upstreamMessage, reply;\n        return _regeneratorRuntime__default['default'].wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                address = message.to;\n                headers = message.headers;\n                body = message.body;\n                grant = (_message$grant = message.grant) !== null && _message$grant !== void 0 ? _message$grant : this.config.activeGrant;\n                httpRequest = {\n                  host: address.host,\n                  path: address.path,\n                  method: address.method,\n                  params: address.params,\n                  headers: headers\n                };\n                upstreamMessage = new Message(grant, headers[\"Content-Type\"] || \"application/json\", httpRequest);\n                logInstance.trace(\"Sending upstream message\", upstreamMessage);\n                _context.next = 9;\n                return this.transport.sendWithReply(upstreamMessage, body);\n              case 9:\n                reply = _context.sent;\n                logInstance.trace(\"Received upstream message response\", reply);\n                if (!(isHttpReply(reply) && !isHttpSuccess(reply.header.http_status.code))) {\n                  _context.next = 13;\n                  break;\n                }\n                throw new TwilsockUpstreamError(reply.header.http_status.code, reply.header.http_status.status, reply.body);\n              case 13:\n                return _context.abrupt(\"return\", {\n                  status: reply.header.http_status,\n                  headers: reply.header.http_headers,\n                  body: reply.body\n                });\n              case 14:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n      function actualSend(_x) {\n        return _actualSend.apply(this, arguments);\n      }\n      return actualSend;\n    }()\n    /**\n     * Send an upstream message\n     * @param {string} method The upstream method\n     * @param {string} url URL to send the message to\n     * @param {object} [headers] The message headers\n     * @param {any} [body] The message body\n     * @param {string} [grant] The product grant\n     * @returns {Promise<Result>} Result from remote side\n     */\n  }, {\n    key: \"send\",\n    value: function send(method, url) {\n      var headers = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      var body = arguments.length > 3 ? arguments[3] : undefined;\n      var grant = arguments.length > 4 ? arguments[4] : undefined;\n      if (this.twilsock.isTerminalState) {\n        return Promise.reject(new TransportUnavailableError(\"Unable to connect: \" + this.twilsock.getTerminationReason));\n      }\n      var twilsockMessage = twilsockParams(method, url, headers, body, grant);\n      if (!this.twilsock.isConnected) {\n        return this.saveMessage(twilsockMessage);\n      }\n      return this.actualSend(twilsockMessage);\n    }\n  }]);\n  return Upstream;\n}();\nvar Deferred = /*#__PURE__*/function () {\n  function Deferred() {\n    var _this = this;\n    _classCallCheck__default['default'](this, Deferred);\n    this._promise = new Promise(function (resolve, reject) {\n      _this._resolve = resolve;\n      _this._reject = reject;\n    });\n  }\n  _createClass__default['default'](Deferred, [{\n    key: \"promise\",\n    get: function get() {\n      return this._promise;\n    }\n  }, {\n    key: \"update\",\n    value: function update(value) {\n      this._resolve(value);\n    }\n  }, {\n    key: \"set\",\n    value: function set(value) {\n      this._resolve(value);\n    }\n  }, {\n    key: \"fail\",\n    value: function fail(e) {\n      this._reject(e);\n    }\n  }]);\n  return Deferred;\n}();\nvar OfflineProductStorage = /*#__PURE__*/function () {\n  function OfflineProductStorage(id) {\n    _classCallCheck__default['default'](this, OfflineProductStorage);\n    this.id = id;\n  }\n  _createClass__default['default'](OfflineProductStorage, null, [{\n    key: \"create\",\n    value: function create(productPayload) {\n      if (productPayload instanceof Object && \"storage_id\" in productPayload) {\n        return new OfflineProductStorage(productPayload.storage_id);\n      } else {\n        throw new TwilsockError('Field \"storage_id\" is missing');\n      }\n    }\n  }]);\n  return OfflineProductStorage;\n}();\nvar TokenStorage = /*#__PURE__*/function () {\n  function TokenStorage() {\n    _classCallCheck__default['default'](this, TokenStorage);\n    _defineProperty__default['default'](this, \"initializedFlag\", \"twilio_twilsock_token_storage\");\n    _defineProperty__default['default'](this, \"tokenStoragePrefix\", \"twilio_continuation_token_\");\n    if (!TokenStorage._instance) {\n      this.initialize();\n      TokenStorage._instance = this;\n    }\n    return TokenStorage._instance;\n  }\n  _createClass__default['default'](TokenStorage, [{\n    key: \"sessionStorage\",\n    value: function sessionStorage() {\n      try {\n        return global[\"sessionStorage\"];\n      } catch (err) {\n        return null;\n      }\n    }\n  }, {\n    key: \"window\",\n    value: function window() {\n      try {\n        return global[\"window\"];\n      } catch (err) {\n        return null;\n      }\n    }\n  }, {\n    key: \"storeToken\",\n    value: function storeToken(continuationToken, productId) {\n      if (this.canStore()) {\n        this.sessionStorage.setItem(this.getKeyName(productId), continuationToken);\n      }\n    }\n  }, {\n    key: \"getStoredToken\",\n    value: function getStoredToken(productId) {\n      if (!this.canStore()) {\n        return null;\n      }\n      return this.sessionStorage.getItem(this.getKeyName(productId));\n    }\n  }, {\n    key: \"initialize\",\n    value: function initialize() {\n      var _this = this;\n      if (this.canStore()) {\n        var flag = this.sessionStorage.getItem(this.initializedFlag); // Duplicated tab, cleaning up all stored keys\n\n        if (flag) {\n          this.clear();\n        }\n        this.sessionStorage.setItem(this.initializedFlag, \"true\"); // When leaving page or refreshing\n\n        var removeStorageItem = this.sessionStorage.removeItem;\n        this.window.addEventListener(\"unload\", function () {\n          removeStorageItem(_this.initializedFlag);\n        });\n      }\n    }\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      if (this.canStore()) {\n        var keyToDelete = [];\n        for (var i = 0; i < this.sessionStorage.length; i++) {\n          var key = this.sessionStorage.key(i); // We manually removed startsWith here due to some problems with babel polyfill setup.\n          // Restore it when we figure out what's wrong.\n          //if (key.startsWith(TokenStorage.tokenStoragePrefix)) {\n\n          if (key && key.indexOf(this.tokenStoragePrefix) === 0) {\n            keyToDelete.push(key);\n          }\n        }\n        var removeStorageItem = this.sessionStorage.removeItem;\n        keyToDelete.forEach(function (key) {\n          return removeStorageItem(key);\n        });\n        removeStorageItem(this.initializedFlag);\n      }\n    }\n  }, {\n    key: \"getKeyName\",\n    value: function getKeyName(productId) {\n      return \"\".concat(this.tokenStoragePrefix).concat(productId);\n    }\n  }, {\n    key: \"canStore\",\n    value: function canStore() {\n      return !!(this.sessionStorage && this.sessionStorage.length && this.window);\n    }\n  }]);\n  return TokenStorage;\n}();\n_defineProperty__default['default'](TokenStorage, \"_instance\", null);\nvar TokenStorage$1 = new TokenStorage();\nvar TelemetryEventDescription = /*#__PURE__*/function () {\n  function TelemetryEventDescription(title, details, start, end, type, id) {\n    _classCallCheck__default['default'](this, TelemetryEventDescription);\n    this.title = title;\n    this.details = details;\n    this.start = start;\n    this.type = type;\n    this.id = id;\n    this.end = end;\n  } // Prepare telemetry event right before sending it.\n  // Convert times to relative.\n\n  _createClass__default['default'](TelemetryEventDescription, [{\n    key: \"toTelemetryEvent\",\n    value: function toTelemetryEvent() {\n      // Fix dates\n      var now = new Date();\n      var actualStart = this.start;\n      var actualEnd = this.end ? this.end : now;\n      if (actualEnd < actualStart) {\n        var tmp = actualEnd;\n        actualEnd = actualStart;\n        actualStart = tmp;\n      } // Converting dates to relative offset from current moment in ms\n\n      var startOffset = actualStart.getTime() - now.getTime();\n      var endOffset = actualEnd.getTime() - now.getTime();\n      var result = new TelemetryEvent(startOffset, endOffset, this.title, this.details, this.id, this.type);\n      return result;\n    }\n  }]);\n  return TelemetryEventDescription;\n}();\nexports.TelemetryPoint = void 0;\n(function (TelemetryPoint) {\n  TelemetryPoint[TelemetryPoint[\"Start\"] = 0] = \"Start\";\n  TelemetryPoint[TelemetryPoint[\"End\"] = 1] = \"End\";\n})(exports.TelemetryPoint || (exports.TelemetryPoint = {}));\nexports.EventSendingLimitation = void 0;\n(function (EventSendingLimitation) {\n  EventSendingLimitation[EventSendingLimitation[\"MinEventsPortion\"] = 0] = \"MinEventsPortion\";\n  EventSendingLimitation[EventSendingLimitation[\"AnyEvents\"] = 1] = \"AnyEvents\";\n  EventSendingLimitation[EventSendingLimitation[\"AnyEventsIncludingUnfinished\"] = 2] = \"AnyEventsIncludingUnfinished\";\n})(exports.EventSendingLimitation || (exports.EventSendingLimitation = {}));\nvar TelemetryTracker = /*#__PURE__*/function () {\n  // accumulated events count that is big enough to be sent out of schedule (not on timer but on new event registration)\n  // max events batch size to be sent in a single Telemetry message\n  // started events: have TelemetryEvent::startTime only\n  // events ready to send\n  function TelemetryTracker(config, packetInterface) {\n    _classCallCheck__default['default'](this, TelemetryTracker);\n    _defineProperty__default['default'](this, \"minEventsPortionToSend\", 50);\n    _defineProperty__default['default'](this, \"maxEventsPortionToSend\", 100);\n    _defineProperty__default['default'](this, \"pendingEvents\", new Map());\n    _defineProperty__default['default'](this, \"readyEvents\", []);\n    _defineProperty__default['default'](this, \"hasInitializationFinished\", false);\n    _defineProperty__default['default'](this, \"_canSendTelemetry\", false);\n    this.config = config;\n    this.packetInterface = packetInterface;\n  } // Keeping this private prevents the type declaration from being generated properly.\n  // Ideally, this should be private.\n\n  _createClass__default['default'](TelemetryTracker, [{\n    key: \"isTelemetryEnabled\",\n    get: function get() {\n      return this.config.confirmedCapabilities.has(\"telemetry.v1\");\n    }\n  }, {\n    key: \"canSendTelemetry\",\n    get: function get() {\n      return this._canSendTelemetry && this.isTelemetryEnabled;\n    },\n    set: function set(enable) {\n      logInstance.debug(\"TelemetryTracker.canSendTelemetry: \".concat(enable, \" TelemetryTracker.isTelemetryEnabled: \").concat(this.isTelemetryEnabled)); // We want to keep telemetry events added in advance but\n      // we need to purge events from previous connection when being disconnected\n\n      if (this._canSendTelemetry && !enable) {\n        this.pendingEvents.clear();\n        this.readyEvents = [];\n      }\n      this._canSendTelemetry = enable;\n      if (enable) {\n        this.sendTelemetry(exports.EventSendingLimitation.AnyEvents);\n      }\n      if (enable && !this.hasInitializationFinished) {\n        this.hasInitializationFinished = true;\n      }\n    } // Add complete event\n  }, {\n    key: \"addTelemetryEvent\",\n    value: function addTelemetryEvent(event) {\n      // Allow adding events before initialization.\n      if (!this.canSendTelemetry && this.hasInitializationFinished) {\n        return;\n      }\n      this.readyEvents.push(event);\n    } // Add incomplete event (with either starting or ending time point)\n  }, {\n    key: \"addPartialEvent\",\n    value: function addPartialEvent(incompleteEvent, eventKey, point) {\n      logInstance.debug(\"Adding \".concat(point === exports.TelemetryPoint.Start ? \"starting\" : \"ending\", \" timepoint for '\").concat(eventKey, \"' event\"));\n      var exists = this.pendingEvents.has(eventKey);\n      if (point === exports.TelemetryPoint.Start) {\n        if (exists) {\n          logInstance.debug(\"Overwriting starting point for '\".concat(eventKey, \"' event\"));\n        }\n        this.pendingEvents.set(eventKey, incompleteEvent);\n      } else {\n        if (!exists) {\n          logInstance.info(\"Could not find started event for '\".concat(eventKey, \"' event\"));\n          return;\n        }\n        this.addTelemetryEvent(this.merge(this.pendingEvents.get(eventKey), incompleteEvent));\n        this.pendingEvents.delete(eventKey);\n      }\n    }\n  }, {\n    key: \"getTelemetryToSend\",\n    value: function getTelemetryToSend(sendingLimit) {\n      if (!this.canSendTelemetry || this.readyEvents.length == 0) {\n        return []; // Events are collected but not sent until telemetry is enabled\n      }\n      if (sendingLimit == exports.EventSendingLimitation.MinEventsPortion && this.readyEvents.length < this.minEventsPortionToSend) {\n        return [];\n      }\n      return this.getTelemetryPortion(sendingLimit == exports.EventSendingLimitation.AnyEventsIncludingUnfinished);\n    }\n  }, {\n    key: \"getTelemetryPortion\",\n    value: function getTelemetryPortion(includeUnfinished) {\n      var _this = this;\n      var eventsPortionToSend = Math.min(this.readyEvents.length, this.maxEventsPortionToSend);\n      var res = this.readyEvents.splice(0, eventsPortionToSend);\n      if (includeUnfinished && res.length < this.maxEventsPortionToSend) {\n        this.pendingEvents.forEach(function (value, key) {\n          if (res.length >= _this.maxEventsPortionToSend) {\n            return; // @fixme does not end the loop early\n          }\n          var event = _this.pendingEvents.get(key);\n          _this.pendingEvents.delete(key);\n          res.push(new TelemetryEventDescription(\"[UNFINISHED] \".concat(event.title),\n          // add prefix title to mark unfinished events for CleanSock\n          event.details, event.start, null,\n          // Not ended, on sending will be replaced with now\n          event.type, event.id));\n        });\n      }\n      return res;\n    } // Merging 2 partial events:\n    //   use start.startTime & end.endTime.\n    // For other fields,\n    //   if there are values in end, use them,\n    //   else use values from start.\n  }, {\n    key: \"merge\",\n    value: function merge(start, end) {\n      return new TelemetryEventDescription(end.title ? end.title : start.title, end.details ? end.details : start.details, start.start, end.end, end.type ? end.type : start.type, end.id ? end.id : start.id);\n    }\n  }, {\n    key: \"sendTelemetryIfMinimalPortionCollected\",\n    value: function sendTelemetryIfMinimalPortionCollected() {\n      this.sendTelemetry(exports.EventSendingLimitation.MinEventsPortion);\n    } // NB: getTelemetryToSend will return non-empty array only if we have already received initReply\n    // and telemetry.v1 capability is enabled there.\n  }, {\n    key: \"sendTelemetry\",\n    value: function sendTelemetry(limit) {\n      var events = this.getTelemetryToSend(limit);\n      if (events.length === 0) {\n        return; // not enough telemetry data collected\n      }\n      try {\n        this.packetInterface.send(new Telemetry(events.map(function (e) {\n          return e.toTelemetryEvent();\n        })));\n      } catch (err) {\n        logInstance.debug(\"Error while sending \".concat(events.length, \" telemetry events due to \").concat(err, \"; they will be resubmitted\"));\n        this.readyEvents = this.readyEvents.concat(events);\n      }\n    }\n  }]);\n  return TelemetryTracker;\n}();\nfunction _createSuper(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct();\n  return function _createSuperInternal() {\n    var Super = _getPrototypeOf__default['default'](Derived),\n      result;\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf__default['default'](this).constructor;\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n    return _possibleConstructorReturn__default['default'](this, result);\n  };\n}\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n  try {\n    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\nvar TelemetryEvents = function TelemetryEvents() {\n  _classCallCheck__default['default'](this, TelemetryEvents);\n};\n/**\n * @alias Twilsock\n * @classdesc Client library for the Twilsock service\n * It allows to recevie service-generated updates as well as bi-directional transport\n * @fires Twilsock#message\n * @fires Twilsock#connected\n * @fires Twilsock#disconnected\n * @fires Twilsock#tokenAboutToExpire\n * @fires Twilsock#tokenExpired\n * @fires Twilsock#stateChanged\n * @fires Twilsock#connectionError\n */\n\n_defineProperty__default['default'](TelemetryEvents, \"TWILSOCK_CONNECT\", \"twilsock.sdk.connect\");\n_defineProperty__default['default'](TelemetryEvents, \"TWILSOCK_INIT\", \"twilsock.sdk.init\");\nexports.TwilsockClient = /*#__PURE__*/function (_EventEmitter) {\n  _inherits__default['default'](TwilsockClient, _EventEmitter);\n  var _super = _createSuper(TwilsockClient);\n\n  /**\n   * @param {string} token Twilio access token\n   * @param {string} productId Product identifier. Should be the same as a grant name in token\n   * @param {object} options Twilsock configuration options\n   */\n  function TwilsockClient(token, productId, options) {\n    var _this;\n    _classCallCheck__default['default'](this, TwilsockClient);\n    _this = _super.call(this);\n    _defineProperty__default['default'](_assertThisInitialized__default['default'](_this), \"version\", version);\n    _defineProperty__default['default'](_assertThisInitialized__default['default'](_this), \"offlineStorageDeferred\", new Deferred());\n    options.continuationToken = options.continuationToken ? options.continuationToken : TokenStorage$1.getStoredToken(productId);\n    var config = _this.config = new Configuration(token, productId, options);\n    logInstance.setLevel(config.logLevel);\n    var websocket = new WebSocketChannel(config.url);\n    var transport = new PacketInterface(websocket, config);\n    _this.channel = new TwilsockChannel(websocket, transport, config);\n    _this.registrations = new Registrations(transport);\n    _this.upstream = new Upstream(transport, _this.channel, config); // Send telemetry only when connected and initialised\n\n    _this.telemetryTracker = new TelemetryTracker(config, transport);\n    _this.channel.on(\"initialized\", function () {\n      return _this.telemetryTracker.canSendTelemetry = true;\n    });\n    websocket.on(\"disconnected\", function () {\n      return _this.telemetryTracker.canSendTelemetry = false;\n    });\n    _this.registrations.on(\"registered\", function (id) {\n      return _this.emit(\"registered\", id);\n    });\n    _this.channel.on(\"message\", function (type, message) {\n      return setTimeout(function () {\n        return _this.emit(\"message\", type, message);\n      }, 0);\n    });\n    _this.channel.on(\"stateChanged\", function (state) {\n      return setTimeout(function () {\n        return _this.emit(\"stateChanged\", state);\n      }, 0);\n    });\n    _this.channel.on(\"connectionError\", function (connectionError) {\n      return setTimeout(function () {\n        return _this.emit(\"connectionError\", connectionError);\n      }, 0);\n    });\n    _this.channel.on(\"tokenAboutToExpire\", function () {\n      return setTimeout(function () {\n        return _this.emit(\"tokenAboutToExpire\");\n      }, 0);\n    });\n    _this.channel.on(\"tokenExpired\", function () {\n      return setTimeout(function () {\n        return _this.emit(\"tokenExpired\");\n      }, 0);\n    });\n    _this.channel.on(\"connected\", function () {\n      return _this.registrations.updateRegistrations();\n    });\n    _this.channel.on(\"connected\", function () {\n      return _this.upstream.sendPendingMessages();\n    });\n    _this.channel.on(\"connected\", function () {\n      return setTimeout(function () {\n        return _this.emit(\"connected\");\n      }, 0);\n    }); // Twilsock telemetry events\n\n    _this.channel.on(\"beforeConnect\", function () {\n      return _this.telemetryTracker.addPartialEvent(new TelemetryEventDescription(\"Establish WebSocket connection\", \"\", new Date()), TelemetryEvents.TWILSOCK_CONNECT, exports.TelemetryPoint.Start);\n    });\n    _this.channel.on(\"connected\", function () {\n      return _this.telemetryTracker.addPartialEvent(new TelemetryEventDescription(\"Establish WebSocket connection\", \"\", new Date(), new Date()), TelemetryEvents.TWILSOCK_CONNECT, exports.TelemetryPoint.End);\n    });\n    _this.channel.on(\"beforeSendInit\", function () {\n      return _this.telemetryTracker.addPartialEvent(new TelemetryEventDescription(\"Send Twilsock init\", \"\", new Date()), TelemetryEvents.TWILSOCK_INIT, exports.TelemetryPoint.Start);\n    });\n    _this.channel.on(\"initialized\", function () {\n      return _this.telemetryTracker.addPartialEvent(new TelemetryEventDescription(\"Send Twilsock init\", \"Succeeded\", new Date(), new Date()), TelemetryEvents.TWILSOCK_INIT, exports.TelemetryPoint.End);\n    });\n    _this.channel.on(\"sendInitFailed\", function () {\n      return _this.telemetryTracker.addPartialEvent(new TelemetryEventDescription(\"Send Twilsock init\", \"Failed\", new Date(), new Date()), TelemetryEvents.TWILSOCK_INIT, exports.TelemetryPoint.End);\n    });\n    _this.channel.on(\"initialized\", function (initReply) {\n      _this.handleStorageId(productId, initReply);\n      TokenStorage$1.storeToken(initReply.continuationToken, productId);\n      setTimeout(function () {\n        return _this.emit(\"initialized\", initReply);\n      }, 0);\n    });\n    _this.channel.on(\"disconnected\", function () {\n      return setTimeout(function () {\n        return _this.emit(\"disconnected\");\n      }, 0);\n    });\n    _this.channel.on(\"disconnected\", function () {\n      return _this.upstream.rejectPendingMessages();\n    });\n    _this.channel.on(\"disconnected\", function () {\n      return _this.offlineStorageDeferred.fail(new TwilsockError(\"Client disconnected\"));\n    });\n    _this.offlineStorageDeferred.promise.catch(function () {\n      return void 0;\n    });\n    return _this;\n  }\n  _createClass__default['default'](TwilsockClient, [{\n    key: \"emit\",\n    value: function emit(event) {\n      var _get2;\n      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        args[_key - 1] = arguments[_key];\n      }\n      logInstance.debug(\"Emitting \".concat(event.toString(), \"(\").concat(args.map(function (a) {\n        return JSON.stringify(a);\n      }).join(\", \"), \")\"));\n      return (_get2 = _get__default['default'](_getPrototypeOf__default['default'](TwilsockClient.prototype), \"emit\", this)).call.apply(_get2, [this, event].concat(args));\n    }\n  }, {\n    key: \"handleStorageId\",\n    value: function handleStorageId(productId, initReply) {\n      if (!initReply.offlineStorage) {\n        this.offlineStorageDeferred.fail(new TwilsockError(\"No offline storage id\"));\n      } else if (initReply.offlineStorage.hasOwnProperty(productId)) {\n        try {\n          this.offlineStorageDeferred.set(OfflineProductStorage.create(initReply.offlineStorage[productId]));\n          logInstance.debug(\"Offline storage for '\".concat(productId, \"' product: \").concat(JSON.stringify(initReply.offlineStorage[productId]), \".\"));\n        } catch (e) {\n          this.offlineStorageDeferred.fail(new TwilsockError(\"Failed to parse offline storage for \".concat(productId, \" \").concat(JSON.stringify(initReply.offlineStorage[productId]), \". \").concat(e, \".\")));\n        }\n      } else {\n        this.offlineStorageDeferred.fail(new TwilsockError(\"No offline storage id for '\".concat(productId, \"' product: \").concat(JSON.stringify(initReply.offlineStorage))));\n      }\n    }\n    /**\n     * Get offline storage ID\n     * @returns {Promise}\n     */\n  }, {\n    key: \"storageId\",\n    value: function storageId() {\n      return this.offlineStorageDeferred.promise;\n    }\n    /**\n     * Indicates if twilsock is connected now\n     * @returns {Boolean}\n     */\n  }, {\n    key: \"isConnected\",\n    get: function get() {\n      return this.channel.isConnected;\n    }\n    /**\n     * Current state\n     * @returns {ConnectionState}\n     */\n  }, {\n    key: \"state\",\n    get: function get() {\n      return this.channel.state;\n    }\n    /**\n     * Update token\n     * @param {String} token\n     * @returns {Promise}\n     */\n  }, {\n    key: \"updateToken\",\n    value: function () {\n      var _updateToken = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee(token) {\n        return _regeneratorRuntime__default['default'].wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                logInstance.trace(\"updating token '\".concat(token, \"'\"));\n                if (!(this.config.token === token)) {\n                  _context.next = 3;\n                  break;\n                }\n                return _context.abrupt(\"return\");\n              case 3:\n                this.config.updateToken(token);\n                _context.next = 6;\n                return this.channel.updateToken(token);\n              case 6:\n                return _context.abrupt(\"return\", _context.sent);\n              case 7:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n      function updateToken(_x) {\n        return _updateToken.apply(this, arguments);\n      }\n      return updateToken;\n    }()\n    /**\n     * Updates notification context.\n     * This method shouldn't be used anyone except twilio notifications library\n     * @param contextId id of notification context\n     * @param context value of notification context\n     * @private\n     */\n  }, {\n    key: \"setNotificationsContext\",\n    value: function () {\n      var _setNotificationsContext = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee2(contextId, context) {\n        return _regeneratorRuntime__default['default'].wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                _context2.next = 2;\n                return this.registrations.setNotificationsContext(contextId, context);\n              case 2:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n      function setNotificationsContext(_x2, _x3) {\n        return _setNotificationsContext.apply(this, arguments);\n      }\n      return setNotificationsContext;\n    }()\n    /**\n     * Remove notification context.\n     * This method shouldn't be used anyone except twilio notifications library\n     * @param contextId id of notification context\n     * @private\n     */\n  }, {\n    key: \"removeNotificationsContext\",\n    value: function () {\n      var _removeNotificationsContext = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee3(contextId) {\n        return _regeneratorRuntime__default['default'].wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                _context3.next = 2;\n                return this.registrations.removeNotificationsContext(contextId);\n              case 2:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n      function removeNotificationsContext(_x4) {\n        return _removeNotificationsContext.apply(this, arguments);\n      }\n      return removeNotificationsContext;\n    }()\n    /**\n     * Connect to the server\n     * @fires Twilsock#connected\n     * @public\n     * @returns {void}\n     */\n  }, {\n    key: \"connect\",\n    value: function connect() {\n      return this.channel.connect();\n    }\n    /**\n     * Disconnect from the server\n     * @fires Twilsock#disconnected\n     * @public\n     * @returns {Promise}\n     */\n  }, {\n    key: \"disconnect\",\n    value: function () {\n      var _disconnect = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee4() {\n        return _regeneratorRuntime__default['default'].wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                this.telemetryTracker.sendTelemetry(exports.EventSendingLimitation.AnyEventsIncludingUnfinished);\n                _context4.next = 3;\n                return this.channel.disconnect();\n              case 3:\n                return _context4.abrupt(\"return\", _context4.sent);\n              case 4:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n      function disconnect() {\n        return _disconnect.apply(this, arguments);\n      }\n      return disconnect;\n    }()\n    /**\n     * Get HTTP request to upstream service\n     * @param {string} url Upstream service url\n     * @param {headers} headers Set of custom headers\n     * @param {string} [grant] The product grant\n     * @returns {Promise}\n     */\n  }, {\n    key: \"get\",\n    value: function () {\n      var _get3 = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee5(url, headers, grant) {\n        return _regeneratorRuntime__default['default'].wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                this.telemetryTracker.sendTelemetry(exports.EventSendingLimitation.AnyEvents); // send collected telemetry (if any) before upstream message shipment\n\n                _context5.next = 3;\n                return this.upstream.send(\"GET\", url, headers, undefined, grant);\n              case 3:\n                return _context5.abrupt(\"return\", _context5.sent);\n              case 4:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this);\n      }));\n      function get(_x5, _x6, _x7) {\n        return _get3.apply(this, arguments);\n      }\n      return get;\n    }()\n    /**\n     * Post HTTP request to upstream service\n     * @param {string} url Upstream service url\n     * @param {headers} headers Set of custom headers\n     * @param {body} body Body to send\n     * @param {string} [grant] The product grant\n     * @returns {Promise}\n     */\n  }, {\n    key: \"post\",\n    value: function () {\n      var _post = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee6(url, headers, body, grant) {\n        return _regeneratorRuntime__default['default'].wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                this.telemetryTracker.sendTelemetry(exports.EventSendingLimitation.AnyEvents); // send collected telemetry (if any) before upstream message shipment\n\n                _context6.next = 3;\n                return this.upstream.send(\"POST\", url, headers, body, grant);\n              case 3:\n                return _context6.abrupt(\"return\", _context6.sent);\n              case 4:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6, this);\n      }));\n      function post(_x8, _x9, _x10, _x11) {\n        return _post.apply(this, arguments);\n      }\n      return post;\n    }()\n    /**\n     * Put HTTP request to upstream service\n     * @param {string} url Upstream service url\n     * @param {headers} headers Set of custom headers\n     * @param {body} body Body to send\n     * @param {string} [grant] The product grant\n     * @returns {Promise}\n     */\n  }, {\n    key: \"put\",\n    value: function () {\n      var _put = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee7(url, headers, body, grant) {\n        return _regeneratorRuntime__default['default'].wrap(function _callee7$(_context7) {\n          while (1) {\n            switch (_context7.prev = _context7.next) {\n              case 0:\n                this.telemetryTracker.sendTelemetry(exports.EventSendingLimitation.AnyEvents); // send collected telemetry (if any) before upstream message shipment\n\n                _context7.next = 3;\n                return this.upstream.send(\"PUT\", url, headers, body, grant);\n              case 3:\n                return _context7.abrupt(\"return\", _context7.sent);\n              case 4:\n              case \"end\":\n                return _context7.stop();\n            }\n          }\n        }, _callee7, this);\n      }));\n      function put(_x12, _x13, _x14, _x15) {\n        return _put.apply(this, arguments);\n      }\n      return put;\n    }()\n    /**\n     * Delete HTTP request to upstream service\n     * @param {string} url Upstream service url\n     * @param {headers} headers Set of custom headers\n     * @param {body} body Body to send\n     * @param {string} [grant] The product grant\n     * @returns {Promise}\n     */\n  }, {\n    key: \"delete\",\n    value: function () {\n      var _delete2 = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee8(url, headers, body, grant) {\n        return _regeneratorRuntime__default['default'].wrap(function _callee8$(_context8) {\n          while (1) {\n            switch (_context8.prev = _context8.next) {\n              case 0:\n                this.telemetryTracker.sendTelemetry(exports.EventSendingLimitation.AnyEvents); // send collected telemetry (if any) before upstream message shipment\n\n                _context8.next = 3;\n                return this.upstream.send(\"DELETE\", url, headers, body, grant);\n              case 3:\n                return _context8.abrupt(\"return\", _context8.sent);\n              case 4:\n              case \"end\":\n                return _context8.stop();\n            }\n          }\n        }, _callee8, this);\n      }));\n      function _delete(_x16, _x17, _x18, _x19) {\n        return _delete2.apply(this, arguments);\n      }\n      return _delete;\n    }()\n    /**\n     * Submits internal telemetry event. Not to be used for any customer and/or sensitive data.\n     * @param {TelemetryEventDescription} event Event details.\n     * @returns {void}\n     */\n  }, {\n    key: \"addTelemetryEvent\",\n    value: function addTelemetryEvent(event) {\n      this.telemetryTracker.addTelemetryEvent(event);\n      this.telemetryTracker.sendTelemetryIfMinimalPortionCollected(); // send telemetry if need\n    }\n    /**\n     * Submits internal telemetry event. Not to be used for any customer and/or sensitive data.\n     * @param {TelemetryEventDescription} event Event details.\n     * @param {string} eventKey Unique event key.\n     * @param {TelemetryPoint} point Is this partial event for start or end of measurement.\n     * @returns {void}\n     */\n  }, {\n    key: \"addPartialTelemetryEvent\",\n    value: function addPartialTelemetryEvent(event, eventKey, point) {\n      this.telemetryTracker.addPartialEvent(event, eventKey, point);\n      if (point === exports.TelemetryPoint.End) {\n        // this telemetry event is complete, so minimal portion could become ready to send\n        this.telemetryTracker.sendTelemetryIfMinimalPortionCollected(); // send telemetry if need\n      }\n    }\n  }]);\n  return TwilsockClient;\n}(EventEmitter);\nexports.TwilsockClient = __decorate([declarativeTypeValidator.validateConstructorTypes(declarativeTypeValidator.nonEmptyString, declarativeTypeValidator.nonEmptyString, [declarativeTypeValidator.pureObject, \"undefined\", declarativeTypeValidator.literal(null)]), __metadata(\"design:paramtypes\", [String, String, Object])], exports.TwilsockClient);\n/**\n * Twilsock destination address descriptor\n * @typedef {Object} Twilsock#Address\n * @property {String} method - HTTP method. (POST, PUT, etc)\n * @property {String} host - host name without path. (e.g. my.company.com)\n * @property {String} path - path on the host (e.g. /my/app/to/call.php)\n */\n\n/**\n * Twilsock upstream message\n * @typedef {Object} Twilsock#Message\n * @property {Twilsock#Address} to - destination address\n * @property {Object} headers - HTTP headers\n * @property {Object} body - Body\n */\n\n/**\n * Fired when new message received\n * @param {Twilsock#Message} message\n * @event Twilsock#message\n */\n\n/**\n * Fired when socket connected\n * @param {String} URI of endpoint\n * @event Twilsock#connected\n */\n\n/**\n * Fired when socket disconnected\n * @event Twilsock#disconnected\n */\n\n/**\n * Fired when token is about to expire and should be updated\n * @event Twilsock#tokenAboutToExpire\n */\n\n/**\n * Fired when token has expired and connection is aborted\n * @event Twilsock#tokenExpired\n */\n\n/**\n * Fired when socket connected\n * @param ConnectionState state - general twilsock state\n * @event Twilsock#stateChanged\n */\n\n/**\n * Fired when connection is interrupted by unexpected reason\n * @type {Object}\n * @property {Boolean} terminal - twilsock will stop connection attempts\n * @property {String} message - root cause\n * @property {Number} [httpStatusCode] - http status code if available\n * @property {Number} [errorCode] - Twilio public error code if available\n * @event Twilsock#connectionError\n */\n\nvar InitRegistration = /*#__PURE__*/function () {\n  // It's a Set<string> but TS cannot serialize Sets properly.\n  function InitRegistration(product) {\n    _classCallCheck__default['default'](this, InitRegistration);\n    this.product = product;\n    this.type = \"ers\";\n    this.notification_protocol_version = 0;\n    this.message_types = [];\n  }\n  /*\n   * @internal\n   *\n   * Populate init registrations section in the Twilsock configuration generically with\n   * passed-in list of types to register.\n   *\n   * Used only by the SDK, ignore.\n   *\n   * @param {string[]} types List of types to add to init registrations in options.\n   * @param {object} options Twilsock options object to update. Omit to create a new one.\n   */\n\n  _createClass__default['default'](InitRegistration, [{\n    key: \"populateInitRegistrations\",\n    value: function populateInitRegistrations(types) {\n      var s = new Set(this.message_types); // Update options reference in place\n\n      for (var idx in types) {\n        s.add(types[idx]);\n      }\n      this.message_types = Array.from(s);\n    }\n  }]);\n  return InitRegistration;\n}();\nexports.InitRegistration = InitRegistration;\nexports.TelemetryEventDescription = TelemetryEventDescription;\nexports.TelemetryTracker = TelemetryTracker;\nexports.TransportUnavailableError = TransportUnavailableError;\nexports.Twilsock = exports.TwilsockClient;\nexports.TwilsockError = TwilsockError;","map":{"version":3,"sources":["../../../node_modules/tslib/tslib.es6.js","../src/logger.ts","../src/configuration.ts","../src/protocol/messages/abstractmessage.ts","../src/protocol/messages/init.ts","../src/protocol/messages/initReply.ts","../src/protocol/messages/update.ts","../src/protocol/messages/message.ts","../src/protocol/messages/reply.ts","../src/protocol/messages/close.ts","../src/protocol/messages/telemetry.ts","../src/parser.ts","../src/error/twilsockerror.ts","../src/error/twilsockreplyerror.ts","../src/backoffretrier.ts","../src/twilsock.ts","../src/metadata.ts","../src/packetinterface.ts","../src/websocketchannel.ts","../src/services/registrations.ts","../src/error/twilsockupstreamerror.ts","../src/error/transportunavailableerror.ts","../src/services/upstream.ts","../src/deferred.ts","../src/offlinestorage.ts","../src/tokenStorage.ts","../src/services/telemetrytracker.ts","../src/client.ts","../src/protocol/initregistration.ts"],"names":["__decorate","decorators","target","key","desc","c","arguments","length","r","Object","getOwnPropertyDescriptor","d","Reflect","decorate","i","defineProperty","__metadata","metadataKey","metadataValue","metadata","loglevelLog","uuid","Retrier","Messages.Update","Messages.Reply","platform","REQUEST_TIMEOUT","isHttpSuccess","Messages.Init","Messages.InitReply","Messages.Close","Messages.Message","TelemetryPoint","EventSendingLimitation","validateConstructorTypes","nonEmptyString","pureObject","literal","TwilsockClient","TokenStorage"],"mappings":"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","sourcesContent":["/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __createBinding(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (p !== \"default\" && !exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n};\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, privateMap) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to get private field on non-instance\");\r\n    }\r\n    return privateMap.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, privateMap, value) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to set private field on non-instance\");\r\n    }\r\n    privateMap.set(receiver, value);\r\n    return value;\r\n}\r\n","import * as loglevelLog from \"loglevel\";\nimport { LogLevelDesc } from \"loglevel\";\n\ntype ArgumentsType = unknown[];\n\nconst log: loglevelLog.Logger = loglevelLog.getLogger(\"twilsock\"); // twilsock is used by Flex SDK. Please DO NOT change\n\nfunction prepareLine(prefix, args) {\n  return [`${new Date().toISOString()} Twilsock ${prefix}:`].concat(\n    Array.from(args)\n  );\n}\n\nclass Logger {\n  private prefix = \"\";\n\n  constructor(prefix: string) {\n    this.prefix =\n      prefix !== null && prefix !== undefined && prefix.length > 0\n        ? \" \" + prefix + \":\"\n        : \"\";\n  }\n\n  setLevel(level: LogLevelDesc): void {\n    log.setLevel(level);\n  }\n\n  static setLevel(level: LogLevelDesc): void {\n    log.setLevel(level);\n  }\n\n  trace(...args: ArgumentsType): void {\n    log.trace.apply(null, prepareLine(\"T\", args));\n  }\n  debug(...args: ArgumentsType): void {\n    log.debug.apply(null, prepareLine(\"D\", args));\n  }\n  info(...args: ArgumentsType): void {\n    log.info.apply(null, prepareLine(\"I\", args));\n  }\n  warn(...args: ArgumentsType): void {\n    log.warn.apply(null, prepareLine(\"W\", args));\n  }\n  error(...args: ArgumentsType): void {\n    log.error.apply(null, prepareLine(\"E\", args));\n  }\n\n  static trace(...args: ArgumentsType): void {\n    log.trace.apply(null, prepareLine(\"T\", args));\n  }\n  static debug(...args: ArgumentsType): void {\n    log.debug.apply(null, prepareLine(\"D\", args));\n  }\n  static info(...args: ArgumentsType): void {\n    log.info.apply(null, prepareLine(\"I\", args));\n  }\n  static warn(...args: ArgumentsType): void {\n    log.warn.apply(null, prepareLine(\"W\", args));\n  }\n  static error(...args: ArgumentsType): void {\n    log.error.apply(null, prepareLine(\"E\", args));\n  }\n}\n\nconst logInstance = new Logger(\"\");\n\nexport { Logger, logInstance as log };\n","import { LogLevelDesc } from \"loglevel\";\nimport { version } from \"../package.json\";\nimport type { ClientOptionsType } from \"./client\";\nimport { InitRegistration } from \"./protocol/initregistration\";\n\nexport type RetryPolicyType = {\n  min: number;\n  max: number;\n  initial?: number;\n  maxAttemptsCount?: number;\n  maxAttemptsTime?: number;\n  randomness?: number;\n};\n\n/**\n * Settings container for the Twilsock client library\n */\nclass Configuration {\n  private _token: string;\n  private _continuationToken: string | null;\n  public confirmedCapabilities: Set<string> = new Set<string>();\n\n  public readonly retryPolicy: RetryPolicyType;\n  public readonly url: string;\n  public readonly activeGrant: string;\n  public readonly logLevel: LogLevelDesc;\n  public readonly clientMetadata: Record<string, unknown>;\n  public readonly initRegistrations: InitRegistration[] | null;\n  public readonly tweaks: Record<string, unknown> | null;\n\n  /**\n   * @param {String} token - authentication token\n   * @param {Object} options - options to override defaults\n   */\n  constructor(\n    token: string,\n    activeGrant: string,\n    options: Partial<ClientOptionsType>\n  ) {\n    this.activeGrant = activeGrant;\n    this._token = token;\n\n    const region = options.region || \"us1\";\n    const defaultTwilsockUrl = `wss://tsock.${region}.twilio.com/v3/wsconnect`;\n\n    const twilsockOptions = options.twilsock || options.Twilsock || {};\n    this.url = twilsockOptions.uri || defaultTwilsockUrl;\n\n    this._continuationToken = options.continuationToken\n      ? options.continuationToken\n      : null;\n\n    this.logLevel = options.logLevel ? options.logLevel : \"error\";\n\n    this.retryPolicy = options.retryPolicy\n      ? options.retryPolicy\n      : {\n          min: 1 * 1000,\n          max: 2 * 60 * 1000,\n          randomness: 0.2,\n        };\n\n    this.clientMetadata = options.clientMetadata ? options.clientMetadata : {};\n    this.clientMetadata.ver = version;\n\n    this.initRegistrations = options.initRegistrations\n      ? options.initRegistrations\n      : null;\n\n    this.tweaks = options.tweaks ? options.tweaks : null;\n  }\n\n  public get token(): string {\n    return this._token;\n  }\n\n  public get continuationToken(): string | null {\n    return this._continuationToken;\n  }\n\n  public updateToken(token: string): void {\n    this._token = token;\n  }\n\n  public updateContinuationToken(continuationToken: string): void {\n    this._continuationToken = continuationToken;\n  }\n}\n\nexport { Configuration };\n","import { v4 as uuid } from \"uuid\";\n\nclass AbstractMessage {\n  public readonly id: string;\n\n  constructor(id?: string) {\n    this.id = id || `TM${uuid()}`;\n  }\n}\n\nexport { AbstractMessage };\n","import type { MessageType } from \"../protocol\";\nimport { AbstractMessage } from \"./abstractmessage\";\nimport { InitRegistration } from \"../initregistration\";\n\nclass Init extends AbstractMessage {\n  public readonly method = \"init\" as MessageType;\n  public readonly token: string;\n  public readonly continuation_token: string | null;\n  public readonly capabilities: string[];\n  public readonly metadata?: Record<string, unknown>;\n  public readonly registrations?: InitRegistration[] | null;\n  public readonly tweaks?: Record<string, unknown> | null;\n\n  constructor(\n    token: string,\n    continuationToken: string | null,\n    metadata?: Record<string, unknown>,\n    registrations?: InitRegistration[] | null,\n    tweaks?: Record<string, unknown> | null\n  ) {\n    super();\n    this.token = token;\n    this.continuation_token = continuationToken;\n    this.metadata = metadata;\n    this.registrations = registrations;\n    this.tweaks = tweaks;\n    this.capabilities = [\"client_update\", \"offline_storage\", \"telemetry.v1\"];\n  }\n}\n\nexport { Init };\n","import { AbstractMessage } from \"./abstractmessage\";\n\ninterface ContinuationTokenStatus {\n  reissued: boolean;\n  reissue_message: string;\n}\n\nclass InitReply extends AbstractMessage {\n  public readonly continuationToken: string;\n  public readonly continuationTokenStatus?: ContinuationTokenStatus;\n  public readonly offlineStorage?: string;\n  public readonly initRegistrations?: string;\n  public readonly debugInfo?: string;\n  public readonly confirmedCapabilities: Set<string>;\n\n  constructor(\n    id: string,\n    continuationToken: string,\n    confirmedCapabilities: Set<string>,\n    continuationTokenStatus?: ContinuationTokenStatus,\n    offlineStorage?: string,\n    initRegistrations?: string,\n    debugInfo?: string\n  ) {\n    super(id);\n    this.continuationToken = continuationToken;\n    this.continuationTokenStatus = continuationTokenStatus;\n    this.offlineStorage = offlineStorage;\n    this.initRegistrations = initRegistrations;\n    this.debugInfo = debugInfo;\n    this.confirmedCapabilities = confirmedCapabilities;\n  }\n}\n\nexport { ContinuationTokenStatus, InitReply };\n","import type { MessageType } from \"../protocol\";\nimport { AbstractMessage } from \"./abstractmessage\";\n\nclass Update extends AbstractMessage {\n  public readonly method = \"update\" as MessageType;\n  public readonly token: string;\n\n  constructor(token: string) {\n    super();\n    this.token = token;\n  }\n}\n\nexport { Update };\n","import type { MessageType, Request } from \"../protocol\";\nimport { AbstractMessage } from \"./abstractmessage\";\n\nclass Message extends AbstractMessage {\n  public readonly method = \"message\" as MessageType;\n  public readonly active_grant: string;\n  public readonly payload_type: string;\n  public readonly http_request: Request;\n\n  constructor(grant: string, contentType: string, request: Request) {\n    super();\n\n    this.active_grant = grant;\n    this.payload_type = contentType;\n    this.http_request = request;\n  }\n}\n\nexport { Message };\n","import { MessageType, Header } from \"../protocol\";\nimport { AbstractMessage } from \"./abstractmessage\";\n\nexport type ReplyType = {\n  id: string;\n  method?: MessageType;\n  payload_type?: string;\n  status: {\n    status: string;\n    code: number;\n    errorCode?: number;\n    description?: string;\n  };\n  header: Header;\n  body: string;\n};\n\nclass Reply extends AbstractMessage {\n  public readonly method = \"reply\";\n  public readonly payload_type = \"application/json\";\n  public readonly status = { code: 200, status: \"OK\" };\n\n  public readonly header;\n  public readonly body;\n\n  constructor(id: string) {\n    super(id);\n  }\n}\n\nexport { Reply };\n","import type { MessageType } from \"../protocol\";\nimport { AbstractMessage } from \"./abstractmessage\";\n\nclass Close extends AbstractMessage {\n  public readonly method = \"close\" as MessageType;\n\n  constructor() {\n    super();\n  }\n}\n\nexport { Close };\n","import { MessageType } from \"../protocol\";\nimport { AbstractMessage } from \"./abstractmessage\";\n\nclass TelemetryEvent {\n  constructor(\n    readonly start: number, // relative to event send time\n    readonly end: number, // relative to event send time\n    readonly title: string,\n    readonly details: string,\n    readonly id?: string, // optional, default will be random assigned by backend\n    readonly type?: string\n  ) {} // optional, default will be \"SDK\" assigned by backend\n}\n\nclass Telemetry extends AbstractMessage {\n  public readonly method = \"telemetry.v1\" as MessageType;\n  public events: TelemetryEvent[];\n\n  constructor(events: TelemetryEvent[]) {\n    super();\n    this.events = events;\n  }\n}\n\nexport { Telemetry, TelemetryEvent };\n","import type { Header } from \"./protocol/protocol\";\nimport { log } from \"./logger\";\n\nexport type ParsedMessageType = {\n  method: string;\n  header: Header;\n  payload: string;\n};\n\nfunction byteLength(s: string): number {\n  const escstr = encodeURIComponent(s);\n  const binstr = escstr.replace(/%([0-9A-F]{2})/g, (match, p1) =>\n    String.fromCharCode(Number(\"0x\" + p1))\n  );\n  return binstr.length;\n}\n\nfunction stringToUint8Array(s: string): Uint8Array {\n  const escstr = encodeURIComponent(s);\n  const binstr = escstr.replace(/%([0-9A-F]{2})/g, (match, p1) =>\n    String.fromCharCode(Number(\"0x\" + p1))\n  );\n  const ua = new Uint8Array(binstr.length);\n  Array.prototype.forEach.call(binstr, (ch, i) => {\n    ua[i] = ch.charCodeAt(0);\n  });\n  return ua;\n}\n\nfunction uint8ArrayToString(ua: Uint8Array): string {\n  const binstr = Array.prototype.map\n    .call(ua, (ch) => String.fromCharCode(ch))\n    .join(\"\");\n  const escstr = binstr.replace(/(.)/g, (m, p) => {\n    let code = p.charCodeAt(0).toString(16).toUpperCase();\n    if (code.length < 2) {\n      code = \"0\" + code;\n    }\n    return \"%\" + code;\n  });\n  return decodeURIComponent(escstr);\n}\n\nfunction getJsonObject(array: Uint8Array): Record<string, unknown> {\n  return JSON.parse(uint8ArrayToString(array));\n}\n\nfunction getMagic(buffer: Uint8Array) {\n  let strMagic = \"\";\n  let idx = 0;\n  for (; idx < buffer.length; ++idx) {\n    const chr = String.fromCharCode(buffer[idx]);\n    strMagic += chr;\n    if (chr === \"\\r\") {\n      idx += 2;\n      break;\n    }\n  }\n\n  const magics = strMagic.split(\" \");\n  return {\n    size: idx,\n    protocol: magics[0],\n    version: magics[1],\n    headerSize: Number(magics[2]),\n  };\n}\n\nclass Parser {\n  static parse(message: ArrayBufferLike): ParsedMessageType | null {\n    const fieldMargin = 2;\n\n    const dataView = new Uint8Array(message);\n    const magic = getMagic(dataView);\n    if (magic.protocol !== \"TWILSOCK\" || magic.version !== \"V3.0\") {\n      log.error(`unsupported protocol: ${magic.protocol} ver ${magic.version}`);\n      //throw new Error('Unsupported protocol');\n      //this.fsm.unsupportedProtocol();\n      return null;\n    }\n\n    let header;\n    try {\n      header = getJsonObject(\n        dataView.subarray(magic.size, magic.size + magic.headerSize)\n      );\n    } catch (e) {\n      log.error(\"failed to parse message header\", e, message);\n      //throw new Error('Failed to parse message');\n      //this.fsm.protocolError();\n      return null;\n    }\n\n    log.debug(\"message received: \", header.method);\n    log.trace(\"message received: \", header);\n\n    let payload;\n    if (header.payload_size > 0) {\n      const payloadOffset = fieldMargin + magic.size + magic.headerSize;\n      const payloadSize = header.payload_size;\n\n      if (\n        !header.hasOwnProperty(\"payload_type\") ||\n        header.payload_type.indexOf(\"application/json\") === 0\n      ) {\n        try {\n          payload = getJsonObject(\n            dataView.subarray(payloadOffset, payloadOffset + payloadSize)\n          );\n        } catch (e) {\n          log.error(\"failed to parse message body\", e, message);\n          //this.fsm.protocolError();\n          return null;\n        }\n      } else if (header.payload_type.indexOf(\"text/plain\") === 0) {\n        payload = uint8ArrayToString(\n          dataView.subarray(payloadOffset, payloadOffset + payloadSize)\n        );\n      }\n    }\n\n    return { method: header.method, header, payload };\n  }\n\n  static createPacket(\n    header: Partial<Header>,\n    payloadString = \"\"\n  ): ArrayBuffer {\n    header.payload_size = byteLength(payloadString); // eslint-disable-line camelcase\n\n    const headerString = JSON.stringify(header);\n    const magicString = \"TWILSOCK V3.0 \" + byteLength(headerString);\n\n    log.debug(\"send request:\", magicString + headerString + payloadString);\n\n    const message = stringToUint8Array(\n      magicString + \"\\r\\n\" + headerString + \"\\r\\n\" + payloadString\n    );\n    return message.buffer as ArrayBuffer;\n  }\n}\n\nexport { Parser };\n","class TwilsockError extends Error {\n  constructor(description: string) {\n    super(description);\n  }\n}\n\nexport { TwilsockError };\n","import { TwilsockError } from \"./twilsockerror\";\nimport type { ReplyType } from \"../protocol/messages/reply\";\n\nclass TwilsockReplyError extends TwilsockError {\n  public readonly reply: ReplyType;\n\n  constructor(description: string, reply: ReplyType) {\n    super(description);\n    this.reply = reply;\n  }\n}\n\nexport { TwilsockReplyError };\n","import { EventEmitter } from \"events\";\nimport { Retrier } from \"@twilio/operation-retrier\";\n\n/**\n * Retrier with backoff override capability\n */\ntype RetrierOptionsType = {\n  min: number;\n  max: number;\n  initial?: number;\n  maxAttemptsCount?: number;\n  maxAttemptsTime?: number;\n  randomness?: number;\n};\n\nclass BackoffRetrier extends EventEmitter {\n  private readonly options;\n  private newBackoff: number | null = null;\n  private usedBackoff: number | null = null;\n\n  private retrier: Retrier | null = null;\n\n  public get inProgress(): boolean {\n    return !!this.retrier;\n  }\n\n  constructor(options: RetrierOptionsType) {\n    super();\n    this.options = options ? { ...options } : {};\n  }\n\n  /**\n   * Should be called once per attempt series to start retrier.\n   */\n  public start(): void {\n    if (this.inProgress) {\n      throw new Error(\n        \"Already waiting for next attempt, call finishAttempt(success : boolean) to finish it\"\n      );\n    }\n    this.createRetrier();\n  }\n\n  /**\n   * Should be called to stop retrier entirely.\n   */\n  public stop(): void {\n    this.cleanRetrier();\n    this.newBackoff = null;\n    this.usedBackoff = null;\n  }\n\n  /**\n   * Modifies backoff for next attempt.\n   * Expected behavior:\n   * - If there was no backoff passed previously reschedulling next attempt to given backoff\n   * - If previous backoff was longer then ignoring this one.\n   * - If previous backoff was shorter then reschedulling with this one.\n   * With or without backoff retrier will keep growing normally.\n   * @param delay delay of next attempts in ms.\n   */\n  public modifyBackoff(delay: number): void {\n    this.newBackoff = delay;\n  }\n\n  /**\n   * Mark last emmited attempt as failed, initiating either next of fail if limits were hit.\n   */\n  public attemptFailed(): void {\n    if (!this.inProgress) {\n      throw new Error(\"No attempt is in progress\");\n    }\n\n    if (this.newBackoff) {\n      const shouldUseNewBackoff =\n        !this.usedBackoff || this.usedBackoff < this.newBackoff;\n      if (shouldUseNewBackoff) {\n        this.createRetrier();\n      } else {\n        this.retrier?.failed(new Error());\n      }\n    } else {\n      this.retrier?.failed(new Error());\n    }\n  }\n\n  public cancel(): void {\n    this.retrier?.cancel();\n  }\n\n  private cleanRetrier(): void {\n    this.retrier?.removeAllListeners();\n    this.retrier?.cancel();\n    this.retrier = null;\n  }\n\n  private getRetryPolicy(): RetrierOptionsType {\n    const clone = { ...this.options };\n\n    if (this.newBackoff) {\n      clone.min = this.newBackoff;\n      clone.max =\n        this.options.max && this.options.max > this.newBackoff\n          ? this.options.max\n          : this.newBackoff;\n    }\n\n    // As we're always skipping first attempt we should add one extra if limit is present\n    clone.maxAttemptsCount = this.options.maxAttemptsCount\n      ? this.options.maxAttemptsCount + 1\n      : undefined;\n\n    return clone;\n  }\n\n  private createRetrier(): void {\n    this.cleanRetrier();\n    const retryPolicy = this.getRetryPolicy();\n    this.retrier = new Retrier(retryPolicy);\n\n    this.retrier.once(\"attempt\", () => {\n      this.retrier?.on(\"attempt\", () => this.emit(\"attempt\"));\n      this.retrier?.failed(new Error(\"Skipping first attempt\"));\n    });\n\n    this.retrier.on(\"failed\", (err) => this.emit(\"failed\", err));\n\n    this.usedBackoff = this.newBackoff;\n    this.newBackoff = null;\n\n    this.retrier.start();\n    // .catch(err => {});\n  }\n}\n\nexport { BackoffRetrier };\n","import { EventEmitter } from \"events\";\nimport * as StateMachine from \"javascript-state-machine\";\nimport { Configuration } from \"./configuration\";\nimport { log } from \"./logger\";\nimport { ConnectionState } from \"./client\";\nimport type { Header } from \"./protocol/protocol\";\nimport * as Messages from \"./protocol/messages\";\nimport { Parser } from \"./parser\";\nimport { PacketInterface } from \"./packetinterface\";\nimport { WebSocketChannel } from \"./websocketchannel\";\nimport { TwilsockReplyError } from \"./error/twilsockreplyerror\";\nimport { BackoffRetrier } from \"./backoffretrier\";\nimport type { ReplyType } from \"./protocol/messages/reply\";\n\nconst DISCONNECTING_TIMEOUT = 3000;\n\n// Wraps asynchronous rescheduling\n// Just makes it simpler to find these hacks over the code\n// Currently there's exactly one instance of this in closeSocket()\nfunction trampoline(f: () => void) {\n  setTimeout(f, 0);\n}\n\nclass Response {}\n\n/**\n * Twilsock channel level protocol implementation\n */\nclass TwilsockChannel extends EventEmitter {\n  private readonly config: Configuration;\n\n  private readonly fsm: StateMachine;\n\n  private disconnectingTimer: ReturnType<typeof setTimeout> | null = null;\n\n  private disconnectedPromiseResolve: (() => void) | null = null;\n  private retrier: BackoffRetrier;\n\n  private websocket: WebSocketChannel;\n  private transport: PacketInterface;\n\n  private readonly terminalStates: Array<string> = [\"disconnected\", \"rejected\"];\n  private lastEmittedState;\n  private readonly tokenExpiredSasCode = 20104;\n\n  private terminationReason = \"Connection is not initialized\";\n\n  constructor(\n    websocket: WebSocketChannel,\n    transport: PacketInterface,\n    config: Configuration\n  ) {\n    super();\n\n    this.websocket = websocket;\n    this.websocket.on(\"connected\", () => this.fsm.socketConnected());\n    this.websocket.on(\"disconnected\", () => this.fsm.socketClosed());\n    this.websocket.on(\"message\", (message) => this.onIncomingMessage(message));\n    this.websocket.on(\"socketError\", (e) =>\n      this.emit(\"connectionError\", {\n        terminal: false,\n        message: `Socket error: ${e.message}`,\n        httpStatusCode: null,\n        errorCode: null,\n      })\n    );\n\n    this.transport = transport;\n    this.config = config;\n\n    this.retrier = new BackoffRetrier(config.retryPolicy);\n    this.retrier.on(\"attempt\", () => this.retry());\n    this.retrier.on(\"failed\", (err) => {\n      log.warn(`Retrying failed: ${err.message}`);\n      this.disconnect();\n    });\n\n    if (\n      typeof window !== \"undefined\" &&\n      typeof window.addEventListener !== \"undefined\"\n    ) {\n      window.addEventListener(\"online\", () => {\n        log.debug(\"Browser reported connectivity state: online\");\n        this.resetBackoff();\n        this.fsm.systemOnline();\n      });\n\n      window.addEventListener(\"offline\", () => {\n        log.debug(\"Browser reported connectivity state: offline\");\n        this.websocket.close();\n        this.fsm.socketClosed();\n      });\n    }\n\n    // We have to use a factory function in here because using the default\n    // StateMachine constructor would cause an error for the consumers of the\n    // rollup bundles. This is a quirk unique to the javascript-state-machine\n    // library.\n\n    const TwilsockStateMachine: StateMachine = StateMachine.factory({\n      init: \"disconnected\",\n      transitions: [\n        {\n          name: \"userConnect\",\n          from: [\"disconnected\", \"rejected\"],\n          to: \"connecting\",\n        },\n        { name: \"userConnect\", from: [\"connecting\", \"connected\"] }, // ignore event\n        {\n          name: \"userDisconnect\",\n          from: [\n            \"connecting\",\n            \"initialising\",\n            \"connected\",\n            \"updating\",\n            \"retrying\",\n            \"rejected\",\n            \"waitSocketClosed\",\n            \"waitOffloadSocketClosed\",\n          ],\n          to: \"disconnecting\",\n        },\n        { name: \"userRetry\", from: [\"retrying\"], to: \"connecting\" },\n        { name: \"socketConnected\", from: [\"connecting\"], to: \"initialising\" },\n        {\n          name: \"socketClosed\",\n          from: [\n            \"connecting\",\n            \"initialising\",\n            \"connected\",\n            \"updating\",\n            \"error\",\n            \"waitOffloadSocketClosed\",\n          ],\n          to: \"retrying\",\n        },\n        { name: \"socketClosed\", from: [\"disconnecting\"], to: \"disconnected\" },\n        {\n          name: \"socketClosed\",\n          from: [\"waitSocketClosed\"],\n          to: \"disconnected\",\n        },\n        { name: \"socketClosed\", from: [\"rejected\"], to: \"rejected\" },\n        { name: \"initSuccess\", from: [\"initialising\"], to: \"connected\" },\n        { name: \"initError\", from: [\"initialising\"], to: \"error\" },\n        {\n          name: \"tokenRejected\",\n          from: [\"initialising\", \"updating\"],\n          to: \"rejected\",\n        },\n        {\n          name: \"protocolError\",\n          from: [\"initialising\", \"connected\", \"updating\"],\n          to: \"error\",\n        },\n        {\n          name: \"receiveClose\",\n          from: [\"initialising\", \"connected\", \"updating\"],\n          to: \"waitSocketClosed\",\n        },\n        {\n          name: \"receiveOffload\",\n          from: [\"initialising\", \"connected\", \"updating\"],\n          to: \"waitOffloadSocketClosed\",\n        },\n        {\n          name: \"unsupportedProtocol\",\n          from: [\"initialising\", \"connected\", \"updating\"],\n          to: \"unsupported\",\n        },\n        {\n          name: \"receiveFatalClose\",\n          from: [\"initialising\", \"connected\", \"updating\"],\n          to: \"unsupported\",\n        },\n        {\n          name: \"userUpdateToken\",\n          from: [\"disconnected\", \"rejected\", \"connecting\", \"retrying\"],\n          to: \"connecting\",\n        },\n        { name: \"userUpdateToken\", from: [\"connected\"], to: \"updating\" },\n        { name: \"updateSuccess\", from: [\"updating\"], to: \"connected\" },\n        { name: \"updateError\", from: [\"updating\"], to: \"error\" },\n        { name: \"userSend\", from: [\"connected\"], to: \"connected\" },\n        { name: \"systemOnline\", from: [\"retrying\"], to: \"connecting\" },\n      ],\n      methods: {\n        onConnecting: () => {\n          this.setupSocket();\n          this.emit(\"connecting\");\n        },\n        onEnterInitialising: () => {\n          this.sendInit();\n        },\n        onLeaveInitialising: () => {\n          this.cancelInit();\n        },\n        onEnterUpdating: () => {\n          this.sendUpdate();\n        },\n        onLeaveUpdating: () => {\n          this.cancelUpdate();\n        },\n        onEnterRetrying: () => {\n          this.initRetry();\n          this.emit(\"connecting\");\n        },\n        onEnterConnected: () => {\n          this.resetBackoff();\n          this.onConnected();\n        },\n        onUserUpdateToken: () => {\n          this.resetBackoff();\n        },\n        onTokenRejected: () => {\n          this.resetBackoff();\n          this.closeSocket(true);\n          this.finalizeSocket();\n        },\n        onUserDisconnect: () => {\n          this.closeSocket(true);\n        },\n        onEnterDisconnecting: () => {\n          this.startDisconnectTimer();\n        },\n        onLeaveDisconnecting: () => {\n          this.cancelDisconnectTimer();\n        },\n        onEnterWaitSocketClosed: () => {\n          this.startDisconnectTimer();\n        },\n        onLeaveWaitSocketClosed: () => {\n          this.cancelDisconnectTimer();\n        },\n        onEnterWaitOffloadSocketClosed: () => {\n          this.startDisconnectTimer();\n        },\n        onLeaveWaitOffloadSocketClosed: () => {\n          this.cancelDisconnectTimer();\n        },\n        onDisconnected: () => {\n          this.resetBackoff();\n          this.finalizeSocket();\n        },\n        onReceiveClose: () => {\n          this.onCloseReceived();\n        },\n        onReceiveOffload: (event, args) => {\n          log.debug(\"onreceiveoffload: \", args);\n          this.modifyBackoff(args.body);\n          this.onCloseReceived();\n        },\n        onUnsupported: () => {\n          this.closeSocket(true);\n          this.finalizeSocket();\n        },\n        onError: (lifecycle, graceful: boolean) => {\n          this.closeSocket(graceful);\n          this.finalizeSocket();\n        },\n        onEnterState: (event) => {\n          if (event.from !== \"none\") {\n            this.changeState(event);\n          }\n        },\n        onInvalidTransition: (transition, from, to) => {\n          log.warn(\"FSM: unexpected transition\", from, to);\n        },\n      },\n    });\n    this.fsm = new TwilsockStateMachine();\n  }\n\n  private changeState(event: {\n    transition: unknown;\n    from: string;\n    to: string;\n  }): void {\n    log.debug(`FSM: ${event.transition}: ${event.from} --> ${event.to}`);\n\n    if (this.lastEmittedState !== this.state) {\n      this.lastEmittedState = this.state;\n      this.emit(\"stateChanged\", this.state);\n    }\n  }\n\n  private resetBackoff(): void {\n    log.trace(\"resetBackoff\");\n    this.retrier.stop();\n  }\n\n  private modifyBackoff(body): void {\n    log.trace(\"modifyBackoff\", body);\n\n    const backoffPolicy = body ? body.backoff_policy : null;\n\n    if (backoffPolicy && typeof backoffPolicy.reconnect_min_ms === \"number\") {\n      this.retrier.modifyBackoff(backoffPolicy.reconnect_min_ms);\n    }\n  }\n\n  private startDisconnectTimer(): void {\n    log.trace(\"startDisconnectTimer\");\n\n    if (this.disconnectingTimer) {\n      clearTimeout(this.disconnectingTimer);\n      this.disconnectingTimer = null;\n    }\n\n    this.disconnectingTimer = setTimeout(() => {\n      log.debug(\"disconnecting is timed out\");\n      this.closeSocket(true);\n    }, DISCONNECTING_TIMEOUT);\n  }\n\n  private cancelDisconnectTimer(): void {\n    log.trace(\"cancelDisconnectTimer\");\n\n    if (this.disconnectingTimer) {\n      clearTimeout(this.disconnectingTimer);\n      this.disconnectingTimer = null;\n    }\n  }\n\n  public get isConnected(): boolean {\n    return this.state === \"connected\" && this.websocket.isConnected;\n  }\n\n  public get state(): ConnectionState {\n    switch (this.fsm.state) {\n      case \"connecting\":\n      case \"initialising\":\n      case \"retrying\":\n      case \"error\":\n        return \"connecting\";\n      case \"updating\":\n      case \"connected\":\n        return \"connected\";\n      case \"rejected\":\n        return \"denied\";\n      case \"disconnecting\":\n      case \"waitSocketClosed\":\n      case \"waitOffloadSocketClosed\":\n        return \"disconnecting\";\n      case \"disconnected\":\n      default:\n        return \"disconnected\";\n    }\n  }\n\n  private initRetry() {\n    log.debug(\"initRetry\");\n    if (this.retrier.inProgress) {\n      this.retrier.attemptFailed();\n    } else {\n      this.retrier.start();\n    }\n  }\n\n  private retry(): void {\n    if (this.fsm.state != \"connecting\") {\n      log.trace(\"retry\");\n      this.websocket.close();\n      this.fsm.userRetry();\n    } else {\n      log.trace(\"can\\t retry as already connecting\");\n    }\n  }\n\n  private onConnected(): void {\n    this.emit(\"connected\");\n  }\n\n  private finalizeSocket(): void {\n    log.trace(\"finalizeSocket\");\n\n    this.websocket.close();\n    this.emit(\"disconnected\");\n\n    if (this.disconnectedPromiseResolve) {\n      this.disconnectedPromiseResolve();\n      this.disconnectedPromiseResolve = null;\n    }\n  }\n\n  private setupSocket(): void {\n    log.trace(\"setupSocket:\", this.config.token);\n    this.emit(\"beforeConnect\"); // This is used by client to record startup telemetry event\n    this.websocket.connect();\n  }\n\n  private onIncomingMessage(message: ArrayBuffer): void {\n    const parsedMessage = Parser.parse(message);\n    if (!parsedMessage) {\n      return;\n    }\n    const { method, header, payload } = parsedMessage;\n\n    if (method !== \"reply\") {\n      this.confirmReceiving(header);\n    }\n\n    if (method === \"notification\") {\n      this.emit(\"message\", header.message_type, payload);\n    } else if (header.method === \"reply\") {\n      this.transport.processReply({\n        id: header.id,\n        status: header.status,\n        header: header,\n        body: payload,\n      });\n    } else if (header.method === \"client_update\") {\n      if (header.client_update_type === \"token_about_to_expire\") {\n        this.emit(\"tokenAboutToExpire\");\n      }\n    } else if (header.method === \"close\") {\n      if (header.status.code === 308) {\n        log.debug(\"Connection has been offloaded\");\n        this.fsm.receiveOffload({\n          status: header.status.status,\n          body: payload,\n        });\n      } else if (header.status.code === 406) {\n        // Not acceptable message\n        const message = `Server closed connection because can't parse protocol: ${JSON.stringify(\n          header.status\n        )}`;\n        this.emitReplyConnectionError(message, header, true);\n        log.error(message);\n        this.fsm.receiveFatalClose();\n      } else if (header.status.code === 417) {\n        // Protocol error\n        log.error(\n          `Server closed connection because can't parse client reply: ${JSON.stringify(\n            header.status\n          )}`\n        );\n        this.fsm.receiveFatalClose(header.status.status);\n      } else if (header.status.code === 410) {\n        // Expired token\n        log.warn(`Server closed connection: ${JSON.stringify(header.status)}`);\n        this.fsm.receiveClose(header.status.status);\n        this.emit(\"tokenExpired\");\n      } else if (header.status.code === 401) {\n        // Authentication fail\n        log.error(`Server closed connection: ${JSON.stringify(header.status)}`);\n        this.fsm.receiveClose(header.status.status);\n      } else {\n        log.warn(\"unexpected message: \", header.status);\n        // Try to reconnect\n        this.fsm.receiveOffload({ status: header.status.status, body: null });\n      }\n    }\n  }\n\n  private async sendInit(): Promise<void> {\n    log.trace(\"sendInit\");\n\n    try {\n      this.emit(\"beforeSendInit\"); // This is used by client to record startup telemetry event\n      const reply = await this.transport.sendInit();\n      this.config.updateContinuationToken(reply.continuationToken);\n      this.config.confirmedCapabilities = reply.confirmedCapabilities;\n      this.fsm.initSuccess(reply);\n      this.emit(\"initialized\", reply);\n      this.emit(\"tokenUpdated\");\n    } catch (ex) {\n      if (ex instanceof TwilsockReplyError) {\n        let isTerminalError = false;\n\n        log.warn(`Init rejected by server: ${JSON.stringify(ex.reply.status)}`);\n        this.emit(\"sendInitFailed\"); // This is used by client to record startup telemetry event\n        // @todo emit telemetry from inside \"if\" below for more granularity...\n\n        if (ex.reply.status.code === 401 || ex.reply.status.code === 403) {\n          isTerminalError = true;\n          this.fsm.tokenRejected(ex.reply.status);\n          if (ex.reply.status.errorCode === this.tokenExpiredSasCode) {\n            this.emit(\"tokenExpired\");\n          }\n        } else if (ex.reply.status.code === 429) {\n          this.modifyBackoff(ex.reply.body);\n          this.fsm.initError(true);\n        } else if (ex.reply.status.code === 500) {\n          this.fsm.initError(false);\n        } else {\n          this.fsm.initError(true);\n        }\n\n        this.emitReplyConnectionError(ex.message, ex.reply, isTerminalError);\n      } else {\n        this.terminationReason = ex.message;\n        this.emit(\"connectionError\", {\n          terminal: true,\n          message: `Unknown error during connection initialisation: ${\n            ex.message\n          }\\n${JSON.stringify(ex, null, 2)}`,\n          httpStatusCode: null,\n          errorCode: null,\n        });\n        this.fsm.initError(true);\n      }\n      this.emit(\"tokenUpdated\", ex);\n    }\n  }\n\n  private async sendUpdate(): Promise<void> {\n    log.trace(\"sendUpdate\");\n\n    const message = new Messages.Update(this.config.token);\n\n    try {\n      const reply = await this.transport.sendWithReply(message);\n      this.fsm.updateSuccess(reply.body);\n      this.emit(\"tokenUpdated\");\n    } catch (ex) {\n      if (ex instanceof TwilsockReplyError) {\n        let isTerminalError = false;\n        log.warn(\n          `Token update rejected by server: ${JSON.stringify(ex.reply.status)}`\n        );\n        if (ex.reply.status.code === 401 || ex.reply.status.code === 403) {\n          isTerminalError = true;\n          this.fsm.tokenRejected(ex.reply.status);\n          if (ex.reply.status.errorCode === this.tokenExpiredSasCode) {\n            this.emit(\"tokenExpired\");\n          }\n        } else if (ex.reply.status.code === 429) {\n          this.modifyBackoff(ex.reply.body);\n          this.fsm.updateError(ex.reply.status);\n        } else {\n          this.fsm.updateError(ex.reply.status);\n        }\n        this.emitReplyConnectionError(ex.message, ex.reply, isTerminalError);\n      } else {\n        this.emit(\"error\", false, ex.message, null, null);\n        this.fsm.updateError(ex);\n      }\n      this.emit(\"tokenUpdated\", ex);\n    }\n  }\n\n  private emitReplyConnectionError(\n    message: string,\n    header: Header | ReplyType,\n    terminal: boolean\n  ) {\n    const description =\n      header.status && header.status.description\n        ? header.status.description\n        : message;\n\n    const httpStatusCode = header.status.code;\n\n    const errorCode =\n      header.status && header.status.errorCode ? header.status.errorCode : null;\n\n    if (terminal) {\n      this.terminationReason = description;\n    }\n\n    this.emit(\"connectionError\", {\n      terminal: terminal,\n      message: `Connection error: ${description}`,\n      httpStatusCode: httpStatusCode,\n      errorCode: errorCode,\n    });\n  }\n\n  private cancelInit(): void {\n    log.trace(\"cancelInit\");\n    // TODO: implement\n  }\n\n  private cancelUpdate(): void {\n    log.trace(\"cancelUpdate\");\n    // TODO: implement\n  }\n\n  /**\n   * Should be called for each message to confirm it received\n   */\n\n  private confirmReceiving(messageHeader: Header) {\n    log.trace(\"confirmReceiving\");\n\n    try {\n      //@todo send telemetry events AnyEvents\n      this.transport.send(new Messages.Reply(messageHeader.id));\n    } catch (e) {\n      log.debug(\"failed to confirm packet receiving\", e);\n    }\n  }\n\n  /**\n   * Shutdown connection\n   */\n  private closeSocket(graceful: boolean): void {\n    log.trace(`closeSocket (graceful: ${graceful})`);\n\n    if (graceful && this.transport.isConnected) {\n      this.transport.sendClose();\n    }\n    this.websocket.close();\n\n    trampoline(() => this.fsm.socketClosed());\n  }\n\n  /**\n   * Initiate the twilsock connection\n   * If already connected, it does nothing\n   */\n  connect(): void {\n    log.trace(\"connect\");\n    this.fsm.userConnect();\n  }\n\n  /**\n   * Close twilsock connection\n   * If already disconnected, it does nothing\n   */\n  disconnect(): Promise<void> {\n    log.trace(\"disconnect\");\n\n    if (this.fsm.is(\"disconnected\")) {\n      return Promise.resolve();\n    }\n\n    return new Promise((resolve) => {\n      this.disconnectedPromiseResolve = resolve;\n      this.fsm.userDisconnect();\n    });\n  }\n\n  /**\n   * Update fpa token for twilsock connection\n   */\n  public updateToken(token: string): Promise<void> {\n    log.trace(\"updateToken:\", token);\n\n    return new Promise((resolve, reject) => {\n      this.once(\"tokenUpdated\", (e) => {\n        if (e) {\n          reject(e);\n        } else {\n          resolve();\n        }\n      });\n\n      this.fsm.userUpdateToken();\n    });\n  }\n\n  public get isTerminalState(): boolean {\n    return this.terminalStates.indexOf(this.fsm.state) !== -1;\n  }\n\n  public get getTerminationReason(): string {\n    return this.terminationReason;\n  }\n\n  private onCloseReceived(): void {\n    this.websocket.close();\n  }\n}\n\nexport { Response, TwilsockChannel };\n","import * as platform from \"platform\";\n\nclass Metadata {\n  public static getMetadata(options: {\n    clientMetadata: Metadata;\n  }): Record<string, unknown> {\n    const overrides =\n      options && options.clientMetadata ? options.clientMetadata : {};\n\n    const fieldNames = [\n      \"ver\",\n      \"env\",\n      \"envv\",\n      \"os\",\n      \"osv\",\n      \"osa\",\n      \"type\",\n      \"sdk\",\n      \"sdkv\",\n      \"dev\",\n      \"devv\",\n      \"devt\",\n      \"app\",\n      \"appv\",\n    ];\n    const defaults = {\n      env: platform.name ?? \"unknown\",\n      envv: platform.version ?? \"unknown\",\n      os: platform.os?.family ?? \"unknown\",\n      osv: platform.os?.version ?? \"unknown\",\n      osa: platform.os?.architecture ?? \"unknown\",\n      sdk: \"js-default\",\n    };\n\n    const finalClientMetadata = {};\n    fieldNames\n      .filter((key) => key in overrides || key in defaults)\n      .forEach(\n        (key) =>\n          (finalClientMetadata[key] =\n            key in overrides ? overrides[key] : defaults[key])\n      );\n\n    return finalClientMetadata;\n  }\n}\n\nexport { Metadata };\n","import { log } from \"./logger\";\n\nimport { v4 as uuid } from \"uuid\";\n\nimport { TwilsockError } from \"./error/twilsockerror\";\nimport { TwilsockReplyError } from \"./error/twilsockreplyerror\";\nimport { Configuration } from \"./configuration\";\nimport { Parser } from \"./parser\";\n\nimport * as Messages from \"./protocol/messages\";\n\nimport { Metadata } from \"./metadata\";\n\nconst REQUEST_TIMEOUT = 30000;\n\nfunction isHttpSuccess(code: number): boolean {\n  return code >= 200 && code < 300;\n}\n\n/**\n * Makes sure that body is properly stringified\n */\nfunction preparePayload(payload): string {\n  switch (typeof payload) {\n    case \"undefined\":\n      return \"\";\n    case \"object\":\n      return JSON.stringify(payload);\n    default:\n      return payload;\n  }\n}\n\ninterface PacketRequest {\n  timeout: ReturnType<typeof setTimeout>;\n  reject: (reason?: TwilsockReplyError | TwilsockError) => void;\n  resolve: (value?: unknown | PromiseLike<unknown>) => void;\n}\n\ninterface PacketResponse {\n  id: string;\n  header: {\n    continuation_token: string;\n    continuation_token_status?: ContinuationTokenStatus;\n    offline_storage: string;\n    init_registrations: string;\n    debug_info: string;\n    capabilities: string[];\n    http_status: {\n      status: string;\n      code: number;\n      errorCode?: string;\n    };\n    http_headers: Headers;\n  };\n  body: Context;\n}\n\nimport type { Headers, Header, Context } from \"./protocol/protocol\";\nimport { Channel } from \"./interfaces/channel\";\nimport { ContinuationTokenStatus } from \"./protocol/messages/initReply\";\nimport { ReplyType } from \"./protocol/messages/reply\";\n\nclass PacketInterface {\n  private readonly config: Configuration;\n  private readonly activeRequests: Map<string, PacketRequest>;\n  private readonly channel: Channel;\n\n  constructor(channel: Channel, config: Configuration) {\n    this.config = config;\n    this.activeRequests = new Map<string, PacketRequest>();\n\n    this.channel = channel;\n    this.channel.on(\"reply\", (reply) => this.processReply(reply));\n    this.channel.on(\"disconnected\", () => {\n      this.activeRequests.forEach((descriptor) => {\n        clearTimeout(descriptor.timeout);\n        descriptor.reject(new TwilsockError(\"disconnected\"));\n      });\n      this.activeRequests.clear();\n    });\n  }\n\n  public get isConnected(): boolean {\n    return this.channel.isConnected;\n  }\n\n  public processReply(reply: ReplyType): void {\n    const request = this.activeRequests.get(reply.id);\n    if (request) {\n      clearTimeout(request.timeout);\n      this.activeRequests.delete(reply.id);\n\n      if (!isHttpSuccess(reply.status.code)) {\n        request.reject(\n          new TwilsockReplyError(\n            \"Transport failure: \" + reply.status.status,\n            reply\n          )\n        );\n        log.trace(\"message rejected\");\n      } else {\n        request.resolve(reply);\n      }\n    }\n  }\n\n  private storeRequest(id: string, resolve, reject): void {\n    const requestDescriptor = {\n      resolve: resolve,\n      reject: reject,\n      timeout: setTimeout(() => {\n        log.trace(\"request\", id, \"is timed out\");\n        reject(new TwilsockError(\"Twilsock: request timeout: \" + id));\n      }, REQUEST_TIMEOUT) as ReturnType<typeof setTimeout>,\n    };\n    this.activeRequests.set(id, requestDescriptor);\n  }\n\n  public shutdown(): void {\n    this.activeRequests.forEach((descriptor) => {\n      clearTimeout(descriptor.timeout);\n      descriptor.reject(\n        new TwilsockError(\"Twilsock: request cancelled by user\")\n      );\n    });\n    this.activeRequests.clear();\n  }\n\n  public async sendInit(): Promise<Messages.InitReply> {\n    log.trace(\"sendInit\");\n\n    const metadata = Metadata.getMetadata(this.config);\n    const message = new Messages.Init(\n      this.config.token,\n      this.config.continuationToken,\n      metadata,\n      this.config.initRegistrations,\n      this.config.tweaks\n    );\n\n    const response = await this.sendWithReply(message);\n    return new Messages.InitReply(\n      response.id,\n      response.header.continuation_token,\n      new Set<string>(response.header.capabilities),\n      response.header.continuation_token_status,\n      response.header.offline_storage,\n      response.header.init_registrations,\n      response.header.debug_info\n    );\n  }\n\n  public sendClose(): void {\n    const message = new Messages.Close();\n    //@todo send telemetry AnyEventsIncludingUnfinished\n    this.send(message);\n  }\n\n  public sendWithReply(\n    header: Partial<Header>,\n    payload?: Context\n  ): Promise<PacketResponse> {\n    return new Promise((resolve, reject) => {\n      const id = this.send(header, payload);\n      this.storeRequest(id, resolve, reject);\n    });\n  }\n\n  public send(header: Partial<Header>, payload?: Context): string {\n    header.id = header.id || `TM${uuid()}`;\n    const message = Parser.createPacket(header, preparePayload(payload));\n\n    try {\n      this.channel.send(message);\n      return header.id;\n    } catch (e) {\n      log.debug(\"failed to send \", header, e);\n      log.trace(e.stack);\n      throw e;\n    }\n  }\n}\n\nexport { Channel, PacketResponse, PacketInterface };\n","import { Channel } from \"./interfaces/channel\";\nimport { EventEmitter } from \"events\";\nimport { log } from \"./logger\";\n\nclass WebSocketChannel extends EventEmitter implements Channel {\n  private readonly WebSocket;\n  private socket: WebSocket | null = null;\n\n  constructor(private readonly url: string) {\n    super();\n    this.url = url;\n    this.WebSocket =\n      global[\"WebSocket\"] || global[\"MozWebSocket\"] || require(\"ws\");\n  }\n\n  public get isConnected(): boolean {\n    return !!this.socket && this.socket.readyState === 1;\n  }\n\n  public connect(): void {\n    log.trace(\"connecting to socket\");\n\n    let socket;\n\n    try {\n      socket = new this.WebSocket(this.url);\n    } catch (e) {\n      log.debug(`Socket error: ${this.url}`);\n      this.emit(\"socketError\", e);\n      return;\n    }\n\n    socket.binaryType = \"arraybuffer\";\n\n    socket.onopen = () => {\n      log.debug(`socket opened ${this.url}`);\n      this.emit(\"connected\");\n    };\n\n    socket.onclose = (e) => {\n      log.debug(\"socket closed\", e);\n      this.emit(\"disconnected\", e);\n    };\n\n    socket.onerror = (e) => {\n      log.debug(\"Socket error:\", e);\n      this.emit(\"socketError\", e);\n    };\n\n    socket.onmessage = (message: MessageEvent) => {\n      this.emit(\"message\", message.data);\n    };\n\n    this.socket = socket;\n  }\n\n  public send(message: ArrayBuffer): void | null {\n    return this.socket && this.socket.send(message);\n  }\n\n  close(): void {\n    log.trace(\"closing socket\");\n\n    if (this.socket) {\n      this.socket.onopen = null;\n      this.socket.onclose = null;\n      this.socket.onerror = null;\n      this.socket.onmessage = null;\n      try {\n        this.socket.close();\n      } finally {\n      }\n    }\n  }\n}\n\nexport { WebSocketChannel };\n","import { log } from \"../logger\";\nimport { EventEmitter } from \"events\";\nimport { v4 as uuid } from \"uuid\";\nimport type { Context, MessageType } from \"../protocol/protocol\";\nimport { PacketInterface } from \"../packetinterface\";\nimport { TwilsockError } from \"../error/twilsockerror\";\n\n/**\n * Registrations module handles all operations with registration contexts through twilsock.\n * Main role: it automatically refreshes all registrations after reconnect.\n */\nclass Registrations extends EventEmitter {\n  private readonly registrations: Map<string, Context>;\n  private readonly registrationsInProgress: Map<string, Set<unknown>>;\n\n  constructor(private readonly transport: PacketInterface) {\n    super();\n\n    this.registrations = new Map();\n    this.registrationsInProgress = new Map();\n  }\n\n  private async putNotificationContext(\n    contextId: string,\n    context: Context\n  ): Promise<void> {\n    const header = {\n      method: \"put_notification_ctx\" as MessageType,\n      notification_ctx_id: contextId,\n    };\n    await this.transport.sendWithReply(header, context);\n  }\n\n  private async deleteNotificationContext(contextId: string): Promise<void> {\n    const message = {\n      method: \"delete_notification_ctx\" as MessageType,\n      notification_ctx_id: contextId,\n    };\n    await this.transport.sendWithReply(message);\n  }\n\n  private async updateRegistration(contextId: string, context: Context) {\n    log.debug(\"update registration for context\", contextId);\n\n    let registrationAttempts = this.registrationsInProgress.get(contextId);\n    if (!registrationAttempts) {\n      registrationAttempts = new Set();\n      this.registrationsInProgress.set(contextId, registrationAttempts);\n    }\n\n    const attemptId = uuid();\n    registrationAttempts.add(attemptId);\n\n    try {\n      await this.putNotificationContext(contextId, context);\n\n      log.debug(\"registration attempt succeeded for context\", context);\n      registrationAttempts.delete(attemptId);\n      if (registrationAttempts.size === 0) {\n        this.registrationsInProgress.delete(contextId);\n        this.emit(\"registered\", contextId);\n      }\n    } catch (err) {\n      log.warn(\"registration attempt failed for context\", context);\n      log.debug(err);\n\n      registrationAttempts.delete(attemptId);\n      if (registrationAttempts.size === 0) {\n        this.registrationsInProgress.delete(contextId);\n        this.emit(\"registrationFailed\", contextId, err);\n      }\n    }\n  }\n\n  public async updateRegistrations(): Promise<void> {\n    log.trace(`refreshing ${this.registrations.size} registrations`);\n    const promises: Promise<void>[] = [];\n    this.registrations.forEach((context: Context, id) => {\n      promises.push(this.updateRegistration(id, context));\n    });\n    await Promise.all(promises);\n  }\n\n  public async setNotificationsContext(\n    contextId: string,\n    context: Context\n  ): Promise<void> {\n    if (!contextId || !context) {\n      throw new TwilsockError(\"Invalid arguments provided\");\n    }\n\n    this.registrations.set(contextId, context);\n    return await this.updateRegistration(contextId, context);\n  }\n\n  public async removeNotificationsContext(contextId: string): Promise<void> {\n    if (!this.registrations.has(contextId)) {\n      return;\n    }\n\n    await this.deleteNotificationContext(contextId);\n    if (this.transport.isConnected) {\n      this.registrations.delete(contextId);\n    }\n  }\n}\n\nexport { Registrations };\n","import { TwilsockError } from \"./twilsockerror\";\nimport type { Context } from \"../protocol/protocol\";\n\nclass TwilsockUpstreamError extends TwilsockError {\n  private readonly status: number;\n  private readonly description: string;\n  private readonly body?: Context;\n\n  constructor(status: number, description: string, body?: Context) {\n    super(description);\n    this.status = status;\n    this.description = description;\n    this.body = body;\n  }\n}\n\nexport { TwilsockUpstreamError };\n","import { TwilsockError } from \"./twilsockerror\";\n\nclass TransportUnavailableError extends TwilsockError {\n  constructor(description: string) {\n    super(description);\n  }\n}\n\nexport { TransportUnavailableError };\n","import { log } from \"../logger\";\nimport { Configuration } from \"../configuration\";\nimport { PacketInterface } from \"../packetinterface\";\nimport { TwilsockError } from \"../error/twilsockerror\";\nimport { TwilsockUpstreamError } from \"../error/twilsockupstreamerror\";\nimport { Headers, Result } from \"../interfaces/transport\";\nimport type {\n  Address,\n  Headers as ProtocolHeaders,\n  Context,\n  Request as ProtocolRequest,\n} from \"../protocol/protocol\";\nimport * as Messages from \"../protocol/messages\";\nimport { TransportUnavailableError } from \"../error/transportunavailableerror\";\nimport { TwilsockChannel } from \"../twilsock\";\nimport { TwilsockReplyError } from \"../error/twilsockreplyerror\";\nconst REQUEST_TIMEOUT = 20000;\n\ntype MessageType = {\n  to: Address;\n  headers: ProtocolHeaders;\n  body: Context;\n  grant?: string;\n};\n\nfunction isHttpSuccess(code: number): boolean {\n  return code >= 200 && code < 300;\n}\n\nfunction isHttpReply(packet): boolean {\n  return packet && packet.header && packet.header.http_status;\n}\n\ninterface Request {\n  message: MessageType;\n  timeout: ReturnType<typeof setTimeout>;\n  reject: (reason?: TwilsockReplyError | TwilsockError) => void;\n  resolve: (value: Result<Context> | PromiseLike<Result<Context>>) => void;\n  alreadyRejected: boolean;\n}\n\nfunction parseUri(uri: string) {\n  const match = uri.match(\n    /^(https?\\:)\\/\\/(([^:\\/?#]*)(?:\\:([0-9]+))?)(\\/[^?#]*)(\\?[^#]*|)(#.*|)$/\n  );\n  if (match) {\n    const uriStruct = {\n      protocol: match[1],\n      host: match[2],\n      hostname: match[3],\n      port: match[4],\n      pathname: match[5],\n      search: match[6],\n      hash: match[7],\n      params: {},\n    };\n\n    if (uriStruct.search.length > 0) {\n      const paramsString = uriStruct.search.substring(1);\n      uriStruct.params = paramsString\n        .split(\"&\")\n        .map((el) => el.split(\"=\"))\n        .reduce((prev, curr) => {\n          if (!prev.hasOwnProperty(curr[0])) {\n            prev[curr[0]] = curr[1];\n          } else if (Array.isArray(prev[curr[0]])) {\n            prev[curr[0]].push(curr[1]);\n          } else {\n            prev[curr[0]] = [prev[curr[0]], curr[1]];\n          }\n          return prev;\n        }, {});\n    }\n    return uriStruct;\n  }\n  throw new TwilsockError(\"Incorrect URI: \" + uri);\n}\n\nfunction twilsockAddress(method: string, uri: string): Address {\n  const parsedUri = parseUri(uri);\n  const to = {\n    method: method,\n    host: parsedUri.host,\n    path: parsedUri.pathname,\n  } as Address;\n  if (parsedUri.params) {\n    to.params = parsedUri.params;\n  }\n  return to;\n}\n\nfunction twilsockParams(\n  method: string,\n  uri: string,\n  headers: Headers,\n  body?,\n  grant?: string\n) {\n  return {\n    to: twilsockAddress(method, uri),\n    headers: headers,\n    body: body,\n    grant: grant,\n  };\n}\n\nclass Upstream {\n  private readonly config: Configuration;\n  private readonly transport: PacketInterface;\n  private readonly pendingMessages: Request[];\n  private readonly twilsock: TwilsockChannel;\n\n  constructor(\n    transport: PacketInterface,\n    twilsock: TwilsockChannel,\n    config: Configuration\n  ) {\n    this.config = config;\n    this.transport = transport;\n    this.pendingMessages = [];\n    this.twilsock = twilsock;\n  }\n\n  public saveMessage(message: MessageType): Promise<Result<Context>> {\n    return new Promise<Result<Context>>((resolve, reject) => {\n      const requestDescriptor = {\n        message,\n        resolve,\n        reject,\n        alreadyRejected: false,\n        timeout: setTimeout(() => {\n          log.debug(\"request is timed out\");\n          reject(\n            new TwilsockError(\n              `request '${message.to.method}' to '${message.to.host}' timed out`\n            )\n          );\n          requestDescriptor.alreadyRejected = true;\n        }, REQUEST_TIMEOUT),\n      };\n      this.pendingMessages.push(requestDescriptor);\n    });\n  }\n\n  public sendPendingMessages(): void {\n    while (this.pendingMessages.length > 0) {\n      const request = this.pendingMessages[0];\n      // Do not send message if we've rejected its promise already\n      if (!request.alreadyRejected) {\n        try {\n          const message = request.message;\n          this.actualSend(message)\n            .then((response) => request.resolve(response))\n            .catch((e) => request.reject(e));\n          clearTimeout(request.timeout);\n        } catch (e) {\n          log.debug(\"Failed to send pending message\", e);\n          break;\n        }\n      }\n      this.pendingMessages.splice(0, 1);\n    }\n  }\n\n  public rejectPendingMessages(): void {\n    this.pendingMessages.forEach((message) => {\n      message.reject(\n        new TransportUnavailableError( // @todo Error Unhandled promise rejection!\n          \"Unable to connect: \" + this.twilsock.getTerminationReason\n        )\n      );\n      message.alreadyRejected = true;\n      clearTimeout(message.timeout);\n    });\n\n    this.pendingMessages.splice(0, this.pendingMessages.length);\n  }\n\n  public async actualSend(message: MessageType): Promise<Result<Context>> {\n    const address = message.to as Address;\n    const headers = message.headers as ProtocolHeaders;\n    const body = message.body;\n    const grant = message.grant ?? this.config.activeGrant;\n\n    const httpRequest = {\n      host: address.host,\n      path: address.path,\n      method: address.method,\n      params: address.params,\n      headers: headers,\n    } as ProtocolRequest;\n\n    const upstreamMessage = new Messages.Message(\n      grant,\n      headers[\"Content-Type\"] || \"application/json\",\n      httpRequest\n    );\n\n    log.trace(\"Sending upstream message\", upstreamMessage);\n\n    const reply = await this.transport.sendWithReply(upstreamMessage, body);\n\n    log.trace(\"Received upstream message response\", reply);\n\n    if (isHttpReply(reply) && !isHttpSuccess(reply.header.http_status.code)) {\n      throw new TwilsockUpstreamError(\n        reply.header.http_status.code,\n        reply.header.http_status.status,\n        reply.body\n      );\n    }\n\n    return {\n      status: reply.header.http_status,\n      headers: reply.header.http_headers,\n      body: reply.body,\n    };\n  }\n\n  /**\n   * Send an upstream message\n   * @param {string} method The upstream method\n   * @param {string} url URL to send the message to\n   * @param {object} [headers] The message headers\n   * @param {any} [body] The message body\n   * @param {string} [grant] The product grant\n   * @returns {Promise<Result>} Result from remote side\n   */\n  public send(\n    method: string,\n    url: string,\n    headers: Headers = {},\n    body?: Context | string,\n    grant?: string\n  ): Promise<Result<Context>> {\n    if (this.twilsock.isTerminalState) {\n      return Promise.reject(\n        new TransportUnavailableError(\n          \"Unable to connect: \" + this.twilsock.getTerminationReason\n        )\n      );\n    }\n\n    const twilsockMessage = twilsockParams(method, url, headers, body, grant);\n    if (!this.twilsock.isConnected) {\n      return this.saveMessage(twilsockMessage);\n    }\n    return this.actualSend(twilsockMessage);\n  }\n}\n\nexport { Upstream };\n","class Deferred<T> {\n  private readonly _promise: Promise<T>;\n  private _resolve;\n  private _reject;\n\n  constructor() {\n    this._promise = new Promise<T>((resolve, reject) => {\n      this._resolve = resolve;\n      this._reject = reject;\n    });\n  }\n\n  public get promise(): Promise<T> {\n    return this._promise;\n  }\n\n  update(value: T): void {\n    this._resolve(value);\n  }\n\n  set(value: T): void {\n    this._resolve(value);\n  }\n\n  fail(e: Error): void {\n    this._reject(e);\n  }\n}\n\nexport { Deferred };\n","import { TwilsockError } from \"./error/twilsockerror\";\n\nclass OfflineProductStorage {\n  public readonly id: string;\n\n  constructor(id: string) {\n    this.id = id;\n  }\n\n  public static create(productPayload: {\n    storage_id: string;\n  }): OfflineProductStorage {\n    if (productPayload instanceof Object && \"storage_id\" in productPayload) {\n      return new OfflineProductStorage(productPayload.storage_id);\n    } else {\n      throw new TwilsockError('Field \"storage_id\" is missing');\n    }\n  }\n}\n\nexport { OfflineProductStorage };\n","class TokenStorage {\n  private initializedFlag = \"twilio_twilsock_token_storage\";\n  private tokenStoragePrefix = \"twilio_continuation_token_\";\n  private static _instance: TokenStorage | null = null;\n\n  constructor() {\n    if (!TokenStorage._instance) {\n      this.initialize();\n      TokenStorage._instance = this;\n    }\n    return TokenStorage._instance;\n  }\n\n  public sessionStorage(): Storage | null {\n    try {\n      return global[\"sessionStorage\"];\n    } catch (err) {\n      return null;\n    }\n  }\n\n  public window(): Window | null {\n    try {\n      return global[\"window\"];\n    } catch (err) {\n      return null;\n    }\n  }\n\n  public storeToken(continuationToken: string, productId: string): void {\n    if (this.canStore()) {\n      this.sessionStorage.setItem(\n        this.getKeyName(productId),\n        continuationToken\n      );\n    }\n  }\n\n  public getStoredToken(productId: string): string | null {\n    if (!this.canStore()) {\n      return null;\n    }\n\n    return this.sessionStorage.getItem(this.getKeyName(productId));\n  }\n\n  private initialize(): void {\n    if (this.canStore()) {\n      const flag = this.sessionStorage.getItem(this.initializedFlag);\n\n      // Duplicated tab, cleaning up all stored keys\n      if (flag) {\n        this.clear();\n      }\n      this.sessionStorage.setItem(this.initializedFlag, \"true\");\n\n      // When leaving page or refreshing\n      const removeStorageItem = this.sessionStorage.removeItem;\n      this.window.addEventListener(\"unload\", () => {\n        removeStorageItem(this.initializedFlag);\n      });\n    }\n  }\n\n  public clear(): void {\n    if (this.canStore()) {\n      const keyToDelete: string[] = [];\n      for (let i = 0; i < this.sessionStorage.length; i++) {\n        const key = this.sessionStorage.key(i);\n        // We manually removed startsWith here due to some problems with babel polyfill setup.\n        // Restore it when we figure out what's wrong.\n        //if (key.startsWith(TokenStorage.tokenStoragePrefix)) {\n        if (key && key.indexOf(this.tokenStoragePrefix) === 0) {\n          keyToDelete.push(key);\n        }\n      }\n      const removeStorageItem = this.sessionStorage.removeItem;\n      keyToDelete.forEach((key) => removeStorageItem(key));\n      removeStorageItem(this.initializedFlag);\n    }\n  }\n\n  private getKeyName(productId: string) {\n    return `${this.tokenStoragePrefix}${productId}`;\n  }\n\n  private canStore(): this is TokenStorage & {\n    window: Window;\n    sessionStorage: Storage;\n  } {\n    return !!(this.sessionStorage && this.sessionStorage.length && this.window);\n  }\n}\n\nexport default new TokenStorage();\n","import { Configuration } from \"../configuration\";\nimport { PacketInterface } from \"../packetinterface\";\nimport { Telemetry, TelemetryEvent } from \"../protocol/messages/telemetry\";\nimport { log } from \"../logger\";\n\nclass TelemetryEventDescription {\n  end?: Date | null;\n\n  constructor(\n    readonly title: string,\n    readonly details: string,\n    readonly start: Date,\n    end?: Date | null,\n    readonly type?: string,\n    readonly id?: string\n  ) {\n    this.end = end;\n  }\n\n  // Prepare telemetry event right before sending it.\n  // Convert times to relative.\n  public toTelemetryEvent(): TelemetryEvent {\n    // Fix dates\n    const now = new Date();\n    let actualStart = this.start;\n    let actualEnd = this.end ? this.end : now;\n    if (actualEnd < actualStart) {\n      const tmp = actualEnd;\n      actualEnd = actualStart;\n      actualStart = tmp;\n    }\n\n    // Converting dates to relative offset from current moment in ms\n    const startOffset = actualStart.getTime() - now.getTime();\n    const endOffset = actualEnd.getTime() - now.getTime();\n\n    const result = new TelemetryEvent(\n      startOffset,\n      endOffset,\n      this.title,\n      this.details,\n      this.id,\n      this.type\n    );\n\n    return result;\n  }\n}\n\nenum TelemetryPoint {\n  Start,\n  End,\n}\n\nenum EventSendingLimitation {\n  MinEventsPortion, // check for minimal amount of telemetry events, skip sending if less than 100 events are ready to send\n  AnyEvents, // send all collected events, do not check for count, skip sending only if no events are ready to send\n  AnyEventsIncludingUnfinished, // send all collected (ready to send) as well as unfinished (just started) events\n}\n\nclass TelemetryTracker {\n  // accumulated events count that is big enough to be sent out of schedule (not on timer but on new event registration)\n  private readonly minEventsPortionToSend = 50;\n  // max events batch size to be sent in a single Telemetry message\n  private readonly maxEventsPortionToSend = 100;\n  private readonly config: Configuration; // to check confirmed capabilities\n  private readonly packetInterface: PacketInterface;\n  private pendingEvents = new Map(); // started events: have TelemetryEvent::startTime only\n  private readyEvents: TelemetryEventDescription[] = []; // events ready to send\n  private hasInitializationFinished = false;\n\n  private _canSendTelemetry = false;\n\n  constructor(config: Configuration, packetInterface: PacketInterface) {\n    this.config = config;\n    this.packetInterface = packetInterface;\n  }\n\n  // Keeping this private prevents the type declaration from being generated properly.\n  // Ideally, this should be private.\n  get isTelemetryEnabled(): boolean {\n    return this.config.confirmedCapabilities.has(\"telemetry.v1\");\n  }\n\n  public get canSendTelemetry(): boolean {\n    return this._canSendTelemetry && this.isTelemetryEnabled;\n  }\n\n  public set canSendTelemetry(enable: boolean) {\n    log.debug(\n      `TelemetryTracker.canSendTelemetry: ${enable} TelemetryTracker.isTelemetryEnabled: ${this.isTelemetryEnabled}`\n    );\n\n    // We want to keep telemetry events added in advance but\n    // we need to purge events from previous connection when being disconnected\n    if (this._canSendTelemetry && !enable) {\n      this.pendingEvents.clear();\n      this.readyEvents = [];\n    }\n\n    this._canSendTelemetry = enable;\n\n    if (enable) {\n      this.sendTelemetry(EventSendingLimitation.AnyEvents);\n    }\n\n    if (enable && !this.hasInitializationFinished) {\n      this.hasInitializationFinished = true;\n    }\n  }\n\n  // Add complete event\n  public addTelemetryEvent(event: TelemetryEventDescription): void {\n    // Allow adding events before initialization.\n    if (!this.canSendTelemetry && this.hasInitializationFinished) {\n      return;\n    }\n\n    this.readyEvents.push(event);\n  }\n\n  // Add incomplete event (with either starting or ending time point)\n  public addPartialEvent(\n    incompleteEvent: TelemetryEventDescription,\n    eventKey: string,\n    point: TelemetryPoint\n  ): void {\n    log.debug(\n      `Adding ${\n        point === TelemetryPoint.Start ? \"starting\" : \"ending\"\n      } timepoint for '${eventKey}' event`\n    );\n    const exists = this.pendingEvents.has(eventKey);\n    if (point === TelemetryPoint.Start) {\n      if (exists) {\n        log.debug(`Overwriting starting point for '${eventKey}' event`);\n      }\n      this.pendingEvents.set(eventKey, incompleteEvent);\n    } else {\n      if (!exists) {\n        log.info(`Could not find started event for '${eventKey}' event`);\n        return;\n      }\n      this.addTelemetryEvent(\n        this.merge(this.pendingEvents.get(eventKey), incompleteEvent)\n      );\n      this.pendingEvents.delete(eventKey);\n    }\n  }\n\n  public getTelemetryToSend(\n    sendingLimit: EventSendingLimitation\n  ): TelemetryEventDescription[] {\n    if (!this.canSendTelemetry || this.readyEvents.length == 0) {\n      return []; // Events are collected but not sent until telemetry is enabled\n    }\n\n    if (\n      sendingLimit == EventSendingLimitation.MinEventsPortion &&\n      this.readyEvents.length < this.minEventsPortionToSend\n    ) {\n      return [];\n    }\n\n    return this.getTelemetryPortion(\n      sendingLimit == EventSendingLimitation.AnyEventsIncludingUnfinished\n    );\n  }\n\n  private getTelemetryPortion(\n    includeUnfinished: boolean\n  ): TelemetryEventDescription[] {\n    const eventsPortionToSend = Math.min(\n      this.readyEvents.length,\n      this.maxEventsPortionToSend\n    );\n    const res = this.readyEvents.splice(0, eventsPortionToSend);\n\n    if (includeUnfinished && res.length < this.maxEventsPortionToSend) {\n      this.pendingEvents.forEach((value, key) => {\n        if (res.length >= this.maxEventsPortionToSend) {\n          return; // @fixme does not end the loop early\n        }\n        const event = this.pendingEvents.get(key);\n        this.pendingEvents.delete(key);\n        res.push(\n          new TelemetryEventDescription(\n            `[UNFINISHED] ${event.title}`, // add prefix title to mark unfinished events for CleanSock\n            event.details,\n            event.start,\n            null, // Not ended, on sending will be replaced with now\n            event.type,\n            event.id\n          )\n        );\n      });\n    }\n\n    return res;\n  }\n\n  // Merging 2 partial events:\n  //   use start.startTime & end.endTime.\n  // For other fields,\n  //   if there are values in end, use them,\n  //   else use values from start.\n  private merge(\n    start: TelemetryEventDescription,\n    end: TelemetryEventDescription\n  ): TelemetryEventDescription {\n    return new TelemetryEventDescription(\n      end.title ? end.title : start.title,\n      end.details ? end.details : start.details,\n      start.start,\n      end.end,\n      end.type ? end.type : start.type,\n      end.id ? end.id : start.id\n    );\n  }\n\n  public sendTelemetryIfMinimalPortionCollected(): void {\n    this.sendTelemetry(EventSendingLimitation.MinEventsPortion);\n  }\n\n  // NB: getTelemetryToSend will return non-empty array only if we have already received initReply\n  // and telemetry.v1 capability is enabled there.\n  public sendTelemetry(limit: EventSendingLimitation): void {\n    const events = this.getTelemetryToSend(limit);\n\n    if (events.length === 0) {\n      return; // not enough telemetry data collected\n    }\n\n    try {\n      this.packetInterface.send(\n        new Telemetry(events.map((e) => e.toTelemetryEvent()))\n      );\n    } catch (err) {\n      log.debug(\n        `Error while sending ${events.length} telemetry events due to ${err}; they will be resubmitted`\n      );\n      this.readyEvents = this.readyEvents.concat(events);\n    }\n  }\n}\n\nexport {\n  TelemetryTracker,\n  TelemetryEventDescription,\n  TelemetryPoint,\n  EventSendingLimitation,\n};\n","import { EventEmitter } from \"events\";\nimport {\n  validateConstructorTypes,\n  nonEmptyString,\n  pureObject,\n  literal,\n} from \"@twilio/declarative-type-validator\";\n\nimport { log } from \"./logger\";\nimport { Configuration, RetryPolicyType } from \"./configuration\";\nimport { TwilsockChannel } from \"./twilsock\";\nimport type { Context, Headers } from \"./protocol/protocol\";\nimport { PacketInterface } from \"./packetinterface\";\nimport { WebSocketChannel } from \"./websocketchannel\";\nimport { Registrations } from \"./services/registrations\";\nimport { Upstream } from \"./services/upstream\";\nimport { Result, Transport } from \"./interfaces/transport\";\nimport { InitReply } from \"./protocol/messages/initReply\";\nimport { Deferred } from \"./deferred\";\nimport { TwilsockError } from \"./error/twilsockerror\";\nimport { OfflineProductStorage } from \"./offlinestorage\";\nimport { InitRegistration } from \"./protocol/initregistration\";\nimport TokenStorage from \"./tokenStorage\";\nimport {\n  EventSendingLimitation,\n  TelemetryEventDescription,\n  TelemetryPoint,\n  TelemetryTracker,\n} from \"./services/telemetrytracker\";\nimport { version } from \"../package.json\";\nimport { LogLevelDesc } from \"loglevel\";\n\nexport class TelemetryEvents {\n  public static readonly TWILSOCK_CONNECT = \"twilsock.sdk.connect\"; // establish WebSocket connection (with WebSocket handshake finished)\n  public static readonly TWILSOCK_INIT = \"twilsock.sdk.init\"; // send \"init\" message and receive reply\n}\n\n/**\n * Indicates current state of connection between the client and Sync service.\n * <p>Possible values are as follows:\n * <li>'connecting' - client is offline and connection attempt is in process.\n * <li>'connected' - client is online and ready.\n * <li>'disconnecting' - client is going offline as disconnection is in process.\n * <li>'disconnected' - client is offline and no connection attempt is in process.\n * <li>'denied' - client connection is denied because of invalid JWT access token. User must refresh token in order to proceed.\n * <li>'error' - client connection is in a permanent erroneous state. Client re-initialization is required.\n * @typedef {('unknown'|'connecting'|'connected'|'disconnecting'|'disconnected'|'denied'|'error')} TwilsockClient#ConnectionState\n */\nexport type ConnectionState =\n  | \"unknown\"\n  | \"disconnecting\"\n  | \"disconnected\"\n  | \"connecting\"\n  | \"connected\"\n  | \"denied\"\n  | \"error\";\n\nexport type ClientOptionsType = {\n  continuationToken?: string | null;\n  channel?: TwilsockChannel;\n  transport?: Transport;\n  registrations?: Registrations;\n  logLevel?: LogLevelDesc;\n  region?: string;\n  twilsock?: { uri?: string };\n  Twilsock?: { uri?: string };\n  retryPolicy?: RetryPolicyType;\n  initRegistrations?: InitRegistration[] | null;\n  tweaks: Record<string, unknown> | null;\n  clientMetadata: Record<string, unknown>;\n  productId?: string;\n  twilsockClient?: TwilsockClient;\n  notifications?: {\n    region?: string;\n    ersUrl?: string;\n  };\n};\n\n/**\n * @alias Twilsock\n * @classdesc Client library for the Twilsock service\n * It allows to recevie service-generated updates as well as bi-directional transport\n * @fires Twilsock#message\n * @fires Twilsock#connected\n * @fires Twilsock#disconnected\n * @fires Twilsock#tokenAboutToExpire\n * @fires Twilsock#tokenExpired\n * @fires Twilsock#stateChanged\n * @fires Twilsock#connectionError\n */\n@validateConstructorTypes(nonEmptyString, nonEmptyString, [\n  pureObject,\n  \"undefined\",\n  literal(null),\n])\nclass TwilsockClient extends EventEmitter {\n  private readonly config: Configuration;\n  private readonly channel: TwilsockChannel;\n\n  private readonly registrations: Registrations;\n  private readonly upstream: Upstream;\n  private readonly telemetryTracker: TelemetryTracker;\n  public readonly version = version;\n\n  private offlineStorageDeferred: Deferred<OfflineProductStorage> =\n    new Deferred();\n\n  /**\n   * @param {string} token Twilio access token\n   * @param {string} productId Product identifier. Should be the same as a grant name in token\n   * @param {object} options Twilsock configuration options\n   */\n  constructor(\n    token: string,\n    productId: string,\n    options: Partial<ClientOptionsType>\n  ) {\n    super();\n\n    options.continuationToken = options.continuationToken\n      ? options.continuationToken\n      : TokenStorage.getStoredToken(productId);\n\n    const config = (this.config = new Configuration(token, productId, options));\n\n    log.setLevel(config.logLevel);\n\n    const websocket = new WebSocketChannel(config.url);\n\n    const transport = new PacketInterface(websocket, config);\n    this.channel = new TwilsockChannel(websocket, transport, config);\n    this.registrations = new Registrations(transport);\n\n    this.upstream = new Upstream(transport, this.channel, config);\n\n    // Send telemetry only when connected and initialised\n    this.telemetryTracker = new TelemetryTracker(config, transport);\n    this.channel.on(\n      \"initialized\",\n      () => (this.telemetryTracker.canSendTelemetry = true)\n    );\n    websocket.on(\n      \"disconnected\",\n      () => (this.telemetryTracker.canSendTelemetry = false)\n    );\n\n    this.registrations.on(\"registered\", (id) => this.emit(\"registered\", id));\n\n    this.channel.on(\"message\", (type, message) =>\n      setTimeout(() => this.emit(\"message\", type, message), 0)\n    );\n\n    this.channel.on(\"stateChanged\", (state) =>\n      setTimeout(() => this.emit(\"stateChanged\", state), 0)\n    );\n\n    this.channel.on(\"connectionError\", (connectionError) =>\n      setTimeout(() => this.emit(\"connectionError\", connectionError), 0)\n    );\n\n    this.channel.on(\"tokenAboutToExpire\", () =>\n      setTimeout(() => this.emit(\"tokenAboutToExpire\"), 0)\n    );\n    this.channel.on(\"tokenExpired\", () =>\n      setTimeout(() => this.emit(\"tokenExpired\"), 0)\n    );\n\n    this.channel.on(\"connected\", () =>\n      this.registrations.updateRegistrations()\n    );\n    this.channel.on(\"connected\", () => this.upstream.sendPendingMessages());\n    this.channel.on(\"connected\", () =>\n      setTimeout(() => this.emit(\"connected\"), 0)\n    );\n\n    // Twilsock telemetry events\n    this.channel.on(\"beforeConnect\", () =>\n      this.telemetryTracker.addPartialEvent(\n        new TelemetryEventDescription(\n          \"Establish WebSocket connection\",\n          \"\",\n          new Date()\n        ),\n        TelemetryEvents.TWILSOCK_CONNECT,\n        TelemetryPoint.Start\n      )\n    );\n\n    this.channel.on(\"connected\", () =>\n      this.telemetryTracker.addPartialEvent(\n        new TelemetryEventDescription(\n          \"Establish WebSocket connection\",\n          \"\",\n          new Date(),\n          new Date()\n        ),\n        TelemetryEvents.TWILSOCK_CONNECT,\n        TelemetryPoint.End\n      )\n    );\n\n    this.channel.on(\"beforeSendInit\", () =>\n      this.telemetryTracker.addPartialEvent(\n        new TelemetryEventDescription(\"Send Twilsock init\", \"\", new Date()),\n        TelemetryEvents.TWILSOCK_INIT,\n        TelemetryPoint.Start\n      )\n    );\n\n    this.channel.on(\"initialized\", () =>\n      this.telemetryTracker.addPartialEvent(\n        new TelemetryEventDescription(\n          \"Send Twilsock init\",\n          \"Succeeded\",\n          new Date(),\n          new Date()\n        ),\n        TelemetryEvents.TWILSOCK_INIT,\n        TelemetryPoint.End\n      )\n    );\n\n    this.channel.on(\"sendInitFailed\", () =>\n      this.telemetryTracker.addPartialEvent(\n        new TelemetryEventDescription(\n          \"Send Twilsock init\",\n          \"Failed\",\n          new Date(),\n          new Date()\n        ),\n        TelemetryEvents.TWILSOCK_INIT,\n        TelemetryPoint.End\n      )\n    );\n\n    this.channel.on(\"initialized\", (initReply: InitReply) => {\n      this.handleStorageId(productId, initReply);\n      TokenStorage.storeToken(initReply.continuationToken, productId);\n      setTimeout(() => this.emit(\"initialized\", initReply), 0);\n    });\n\n    this.channel.on(\"disconnected\", () =>\n      setTimeout(() => this.emit(\"disconnected\"), 0)\n    );\n    this.channel.on(\"disconnected\", () =>\n      this.upstream.rejectPendingMessages()\n    );\n    this.channel.on(\"disconnected\", () =>\n      this.offlineStorageDeferred.fail(new TwilsockError(\"Client disconnected\"))\n    );\n\n    this.offlineStorageDeferred.promise.catch(() => void 0);\n  }\n\n  public emit(event: string | symbol, ...args: unknown[]): boolean {\n    log.debug(\n      `Emitting ${event.toString()}(${args\n        .map((a) => JSON.stringify(a))\n        .join(\", \")})`\n    );\n    return super.emit(event, ...args);\n  }\n\n  private handleStorageId(productId: string, initReply: InitReply) {\n    if (!initReply.offlineStorage) {\n      this.offlineStorageDeferred.fail(\n        new TwilsockError(\"No offline storage id\")\n      );\n    } else if (initReply.offlineStorage.hasOwnProperty(productId)) {\n      try {\n        this.offlineStorageDeferred.set(\n          OfflineProductStorage.create(initReply.offlineStorage[productId])\n        );\n        log.debug(\n          `Offline storage for '${productId}' product: ${JSON.stringify(\n            initReply.offlineStorage[productId]\n          )}.`\n        );\n      } catch (e) {\n        this.offlineStorageDeferred.fail(\n          new TwilsockError(\n            `Failed to parse offline storage for ${productId} ${JSON.stringify(\n              initReply.offlineStorage[productId]\n            )}. ${e}.`\n          )\n        );\n      }\n    } else {\n      this.offlineStorageDeferred.fail(\n        new TwilsockError(\n          `No offline storage id for '${productId}' product: ${JSON.stringify(\n            initReply.offlineStorage\n          )}`\n        )\n      );\n    }\n  }\n\n  /**\n   * Get offline storage ID\n   * @returns {Promise}\n   */\n  public storageId(): Promise<OfflineProductStorage> {\n    return this.offlineStorageDeferred.promise;\n  }\n\n  /**\n   * Indicates if twilsock is connected now\n   * @returns {Boolean}\n   */\n  public get isConnected(): boolean {\n    return this.channel.isConnected;\n  }\n\n  /**\n   * Current state\n   * @returns {ConnectionState}\n   */\n  public get state(): ConnectionState {\n    return this.channel.state;\n  }\n\n  /**\n   * Update token\n   * @param {String} token\n   * @returns {Promise}\n   */\n  public async updateToken(token: string): Promise<void> {\n    log.trace(`updating token '${token}'`);\n    if (this.config.token === token) {\n      return;\n    }\n\n    this.config.updateToken(token);\n    return await this.channel.updateToken(token);\n  }\n\n  /**\n   * Updates notification context.\n   * This method shouldn't be used anyone except twilio notifications library\n   * @param contextId id of notification context\n   * @param context value of notification context\n   * @private\n   */\n  public async setNotificationsContext(\n    contextId: string,\n    context: Context\n  ): Promise<void> {\n    await this.registrations.setNotificationsContext(contextId, context);\n  }\n\n  /**\n   * Remove notification context.\n   * This method shouldn't be used anyone except twilio notifications library\n   * @param contextId id of notification context\n   * @private\n   */\n  public async removeNotificationsContext(contextId: string): Promise<void> {\n    await this.registrations.removeNotificationsContext(contextId);\n  }\n\n  /**\n   * Connect to the server\n   * @fires Twilsock#connected\n   * @public\n   * @returns {void}\n   */\n  public connect(): void {\n    return this.channel.connect();\n  }\n\n  /**\n   * Disconnect from the server\n   * @fires Twilsock#disconnected\n   * @public\n   * @returns {Promise}\n   */\n  public async disconnect(): Promise<void> {\n    this.telemetryTracker.sendTelemetry(\n      EventSendingLimitation.AnyEventsIncludingUnfinished\n    );\n    return await this.channel.disconnect();\n  }\n\n  /**\n   * Get HTTP request to upstream service\n   * @param {string} url Upstream service url\n   * @param {headers} headers Set of custom headers\n   * @param {string} [grant] The product grant\n   * @returns {Promise}\n   */\n  public async get(\n    url: string,\n    headers: Headers,\n    grant?: string\n  ): Promise<Result<Context>> {\n    this.telemetryTracker.sendTelemetry(EventSendingLimitation.AnyEvents); // send collected telemetry (if any) before upstream message shipment\n    return await this.upstream.send(\"GET\", url, headers, undefined, grant);\n  }\n\n  /**\n   * Post HTTP request to upstream service\n   * @param {string} url Upstream service url\n   * @param {headers} headers Set of custom headers\n   * @param {body} body Body to send\n   * @param {string} [grant] The product grant\n   * @returns {Promise}\n   */\n  public async post<\n    T extends Record<string, unknown> = Record<string, unknown>\n  >(\n    url: string,\n    headers: Headers,\n    body: Context | string,\n    grant?: string\n  ): Promise<Result<Context<T>>> {\n    this.telemetryTracker.sendTelemetry(EventSendingLimitation.AnyEvents); // send collected telemetry (if any) before upstream message shipment\n    return (await this.upstream.send(\n      \"POST\",\n      url,\n      headers,\n      body,\n      grant\n    )) as Result<Context<T>>;\n  }\n\n  /**\n   * Put HTTP request to upstream service\n   * @param {string} url Upstream service url\n   * @param {headers} headers Set of custom headers\n   * @param {body} body Body to send\n   * @param {string} [grant] The product grant\n   * @returns {Promise}\n   */\n  public async put<T extends Record<string, unknown> = Record<string, unknown>>(\n    url: string,\n    headers: Headers,\n    body: Context | string,\n    grant?: string\n  ): Promise<Result<Context<T>>> {\n    this.telemetryTracker.sendTelemetry(EventSendingLimitation.AnyEvents); // send collected telemetry (if any) before upstream message shipment\n    return (await this.upstream.send(\n      \"PUT\",\n      url,\n      headers,\n      body,\n      grant\n    )) as Result<Context<T>>;\n  }\n\n  /**\n   * Delete HTTP request to upstream service\n   * @param {string} url Upstream service url\n   * @param {headers} headers Set of custom headers\n   * @param {body} body Body to send\n   * @param {string} [grant] The product grant\n   * @returns {Promise}\n   */\n  public async delete<\n    T extends Record<string, unknown> = Record<string, unknown>\n  >(\n    url: string,\n    headers: Headers,\n    body?: Context | string,\n    grant?: string\n  ): Promise<Result<Context<T>>> {\n    this.telemetryTracker.sendTelemetry(EventSendingLimitation.AnyEvents); // send collected telemetry (if any) before upstream message shipment\n    return (await this.upstream.send(\n      \"DELETE\",\n      url,\n      headers,\n      body,\n      grant\n    )) as Result<Context<T>>;\n  }\n\n  /**\n   * Submits internal telemetry event. Not to be used for any customer and/or sensitive data.\n   * @param {TelemetryEventDescription} event Event details.\n   * @returns {void}\n   */\n  public addTelemetryEvent(event: TelemetryEventDescription): void {\n    this.telemetryTracker.addTelemetryEvent(event);\n    this.telemetryTracker.sendTelemetryIfMinimalPortionCollected(); // send telemetry if need\n  }\n\n  /**\n   * Submits internal telemetry event. Not to be used for any customer and/or sensitive data.\n   * @param {TelemetryEventDescription} event Event details.\n   * @param {string} eventKey Unique event key.\n   * @param {TelemetryPoint} point Is this partial event for start or end of measurement.\n   * @returns {void}\n   */\n  public addPartialTelemetryEvent(\n    event: TelemetryEventDescription,\n    eventKey: string,\n    point: TelemetryPoint\n  ): void {\n    this.telemetryTracker.addPartialEvent(event, eventKey, point);\n    if (point === TelemetryPoint.End) {\n      // this telemetry event is complete, so minimal portion could become ready to send\n      this.telemetryTracker.sendTelemetryIfMinimalPortionCollected(); // send telemetry if need\n    }\n  }\n}\n\nexport { Context, Result, TwilsockClient, TwilsockClient as Twilsock };\n\n/**\n * Twilsock destination address descriptor\n * @typedef {Object} Twilsock#Address\n * @property {String} method - HTTP method. (POST, PUT, etc)\n * @property {String} host - host name without path. (e.g. my.company.com)\n * @property {String} path - path on the host (e.g. /my/app/to/call.php)\n */\n\n/**\n * Twilsock upstream message\n * @typedef {Object} Twilsock#Message\n * @property {Twilsock#Address} to - destination address\n * @property {Object} headers - HTTP headers\n * @property {Object} body - Body\n */\n\n/**\n * Fired when new message received\n * @param {Twilsock#Message} message\n * @event Twilsock#message\n */\n\n/**\n * Fired when socket connected\n * @param {String} URI of endpoint\n * @event Twilsock#connected\n */\n\n/**\n * Fired when socket disconnected\n * @event Twilsock#disconnected\n */\n\n/**\n * Fired when token is about to expire and should be updated\n * @event Twilsock#tokenAboutToExpire\n */\n\n/**\n * Fired when token has expired and connection is aborted\n * @event Twilsock#tokenExpired\n */\n\n/**\n * Fired when socket connected\n * @param ConnectionState state - general twilsock state\n * @event Twilsock#stateChanged\n */\n\n/**\n * Fired when connection is interrupted by unexpected reason\n * @type {Object}\n * @property {Boolean} terminal - twilsock will stop connection attempts\n * @property {String} message - root cause\n * @property {Number} [httpStatusCode] - http status code if available\n * @property {Number} [errorCode] - Twilio public error code if available\n * @event Twilsock#connectionError\n */\n","class InitRegistration {\n  public product: string;\n  public type: string;\n  public notification_protocol_version: number;\n  public message_types: string[]; // It's a Set<string> but TS cannot serialize Sets properly.\n\n  constructor(product: string) {\n    this.product = product;\n    this.type = \"ers\";\n    this.notification_protocol_version = 0;\n    this.message_types = [];\n  }\n\n  /*\n   * @internal\n   *\n   * Populate init registrations section in the Twilsock configuration generically with\n   * passed-in list of types to register.\n   *\n   * Used only by the SDK, ignore.\n   *\n   * @param {string[]} types List of types to add to init registrations in options.\n   * @param {object} options Twilsock options object to update. Omit to create a new one.\n   */\n  public populateInitRegistrations(types: string[]): void {\n    const s = new Set<string>(this.message_types);\n    // Update options reference in place\n    for (const idx in types) {\n      s.add(types[idx]);\n    }\n    this.message_types = Array.from(s);\n  }\n}\n\nexport { InitRegistration };\n"]},"metadata":{},"sourceType":"script"}