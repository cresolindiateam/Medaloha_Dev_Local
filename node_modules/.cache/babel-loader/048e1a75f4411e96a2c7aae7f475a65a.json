{"ast":null,"code":"/*\n@license\nCopyright (c) 2021 Twilio Inc.\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n*/\n'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nvar _typeof = require('@babel/runtime/helpers/typeof');\nvar _slicedToArray = require('@babel/runtime/helpers/slicedToArray');\nvar _toConsumableArray = require('@babel/runtime/helpers/toConsumableArray');\nvar _classCallCheck = require('@babel/runtime/helpers/classCallCheck');\nvar _inherits = require('@babel/runtime/helpers/inherits');\nvar _possibleConstructorReturn = require('@babel/runtime/helpers/possibleConstructorReturn');\nvar _getPrototypeOf = require('@babel/runtime/helpers/getPrototypeOf');\nfunction _interopDefaultLegacy(e) {\n  return e && typeof e === 'object' && 'default' in e ? e : {\n    'default': e\n  };\n}\nvar _typeof__default = /*#__PURE__*/_interopDefaultLegacy(_typeof);\nvar _slicedToArray__default = /*#__PURE__*/_interopDefaultLegacy(_slicedToArray);\nvar _toConsumableArray__default = /*#__PURE__*/_interopDefaultLegacy(_toConsumableArray);\nvar _classCallCheck__default = /*#__PURE__*/_interopDefaultLegacy(_classCallCheck);\nvar _inherits__default = /*#__PURE__*/_interopDefaultLegacy(_inherits);\nvar _possibleConstructorReturn__default = /*#__PURE__*/_interopDefaultLegacy(_possibleConstructorReturn);\nvar _getPrototypeOf__default = /*#__PURE__*/_interopDefaultLegacy(_getPrototypeOf);\nvar custom = function custom() {\n  for (var _len = arguments.length, checks = new Array(_len), _key = 0; _key < _len; _key++) {\n    checks[_key] = arguments[_key];\n  }\n  return {\n    checks: checks\n  };\n};\nfunction _createForOfIteratorHelper$3(o, allowArrayLike) {\n  var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"];\n  if (!it) {\n    if (Array.isArray(o) || (it = _unsupportedIterableToArray$3(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n      var F = function F() {};\n      return {\n        s: F,\n        n: function n() {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function e(_e) {\n          throw _e;\n        },\n        f: F\n      };\n    }\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n  var normalCompletion = true,\n    didErr = false,\n    err;\n  return {\n    s: function s() {\n      it = it.call(o);\n    },\n    n: function n() {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function e(_e2) {\n      didErr = true;\n      err = _e2;\n    },\n    f: function f() {\n      try {\n        if (!normalCompletion && it.return != null) it.return();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}\nfunction _unsupportedIterableToArray$3(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray$3(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$3(o, minLen);\n}\nfunction _arrayLikeToArray$3(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n  return arr2;\n}\nvar type = function type() {\n  for (var _len = arguments.length, checks = new Array(_len), _key = 0; _key < _len; _key++) {\n    checks[_key] = arguments[_key];\n  }\n  return custom(function (value) {\n    var isValid = false;\n    var expectedTypes = [];\n    var _iterator = _createForOfIteratorHelper$3(checks),\n      _step;\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var _type = _step.value;\n        if (typeof _type === \"string\") {\n          isValid = isValid || _typeof__default['default'](value) === _type;\n          expectedTypes.push(\"of type \".concat(_type));\n          continue;\n        }\n        isValid = isValid || value instanceof _type;\n        expectedTypes.push(\"an instance of \".concat(_type.name));\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n    return [isValid, expectedTypes];\n  });\n};\nfunction _createForOfIteratorHelper$2(o, allowArrayLike) {\n  var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"];\n  if (!it) {\n    if (Array.isArray(o) || (it = _unsupportedIterableToArray$2(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n      var F = function F() {};\n      return {\n        s: F,\n        n: function n() {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function e(_e) {\n          throw _e;\n        },\n        f: F\n      };\n    }\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n  var normalCompletion = true,\n    didErr = false,\n    err;\n  return {\n    s: function s() {\n      it = it.call(o);\n    },\n    n: function n() {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function e(_e2) {\n      didErr = true;\n      err = _e2;\n    },\n    f: function f() {\n      try {\n        if (!normalCompletion && it.return != null) it.return();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}\nfunction _unsupportedIterableToArray$2(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray$2(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$2(o, minLen);\n}\nfunction _arrayLikeToArray$2(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n  return arr2;\n}\nvar literal = function literal() {\n  for (var _len = arguments.length, checks = new Array(_len), _key = 0; _key < _len; _key++) {\n    checks[_key] = arguments[_key];\n  }\n  return custom(function (value) {\n    var isValid = false;\n    var expectedTypes = [];\n    var _iterator = _createForOfIteratorHelper$2(checks),\n      _step;\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var type = _step.value;\n        isValid = isValid || value === type;\n        expectedTypes.push(typeof type === \"string\" ? \"\\\"\".concat(type, \"\\\"\") : \"\".concat(type));\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n    return [isValid, expectedTypes];\n  });\n};\nvar nonEmptyString = custom(function (value) {\n  return [typeof value === \"string\" && value.length > 0, \"a non-empty string\"];\n});\nvar nonNegativeInteger = custom(function (value) {\n  return [typeof value === \"number\" && Number.isInteger(value) && value >= 0, \"a non-negative integer\"];\n});\nvar pureObject = custom(function (value) {\n  return [_typeof__default['default'](value) === \"object\" && value !== null && !Array.isArray(value), \"a pure object (non-null and non-array)\"];\n});\nfunction _createSuper(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct();\n  return function _createSuperInternal() {\n    var Super = _getPrototypeOf__default['default'](Derived),\n      result;\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf__default['default'](this).constructor;\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n    return _possibleConstructorReturn__default['default'](this, result);\n  };\n}\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n  try {\n    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\nfunction _createForOfIteratorHelper$1(o, allowArrayLike) {\n  var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"];\n  if (!it) {\n    if (Array.isArray(o) || (it = _unsupportedIterableToArray$1(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n      var F = function F() {};\n      return {\n        s: F,\n        n: function n() {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function e(_e) {\n          throw _e;\n        },\n        f: F\n      };\n    }\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n  var normalCompletion = true,\n    didErr = false,\n    err;\n  return {\n    s: function s() {\n      it = it.call(o);\n    },\n    n: function n() {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function e(_e2) {\n      didErr = true;\n      err = _e2;\n    },\n    f: function f() {\n      try {\n        if (!normalCompletion && it.return != null) it.return();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}\nfunction _unsupportedIterableToArray$1(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray$1(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$1(o, minLen);\n}\nfunction _arrayLikeToArray$1(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n  return arr2;\n}\nvar runtimeTypeValidation = function runtimeTypeValidation(rules, values) {\n  if (values.length > rules.length) {\n    throw new Error(\"Expected at most \".concat(rules.length, \" argument(s), but got \").concat(values.length));\n  }\n  while (values.length < rules.length) {\n    values.push(undefined);\n  }\n  var _iterator = _createForOfIteratorHelper$1(values.entries()),\n    _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var _step$value = _slicedToArray__default['default'](_step.value, 2),\n        index = _step$value[0],\n        value = _step$value[1];\n      var _validateValue = validateValue(rules[index], value),\n        _validateValue2 = _slicedToArray__default['default'](_validateValue, 4),\n        isValid = _validateValue2[0],\n        received = _validateValue2[1],\n        expected = _validateValue2[2],\n        delimeter = _validateValue2[3];\n      if (isValid) {\n        continue;\n      }\n      var argumentIndex = index + 1;\n      throw new Error(\"Argument \".concat(argumentIndex, \" is expected to be \").concat(expected).concat(delimeter, \" but got \").concat(received));\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n};\nvar stringifyReceivedType = function stringifyReceivedType(value) {\n  var _value$constructor;\n  var receivedType;\n  var types = [\"undefined\", \"boolean\", \"number\", \"bigint\", \"string\"];\n  if (types.includes(_typeof__default['default'](value))) {\n    receivedType = typeof value === \"string\" ? \"\\\"\".concat(value, \"\\\"\") : \"\".concat(value);\n  }\n  if (_typeof__default['default'](value) === \"object\" && (value === null || value === void 0 ? void 0 : (_value$constructor = value.constructor) === null || _value$constructor === void 0 ? void 0 : _value$constructor.name) !== \"Object\") {\n    var _value$constructor2;\n    receivedType = value === null ? \"null\" : \"instance of \".concat(value === null || value === void 0 ? void 0 : (_value$constructor2 = value.constructor) === null || _value$constructor2 === void 0 ? void 0 : _value$constructor2.name);\n  }\n  if (!receivedType) {\n    receivedType = _typeof__default['default'](value);\n  }\n  return receivedType;\n};\n/* eslint-disable @typescript-eslint/no-explicit-any */\n\nvar validateConstructorTypes = function validateConstructorTypes() {\n  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n  var finalRuleSet = convertRuleArguments(args);\n  return function (ctor) {\n    return /*#__PURE__*/function (_ctor) {\n      _inherits__default['default'](_class, _ctor);\n      var _super = _createSuper(_class);\n      function _class() {\n        _classCallCheck__default['default'](this, _class);\n        for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n          args[_key2] = arguments[_key2];\n        }\n        runtimeTypeValidation(finalRuleSet, args);\n        return _super.call.apply(_super, [this].concat(args));\n      }\n      return _class;\n    }(ctor);\n  };\n};\n/* eslint-enable @typescript-eslint/no-explicit-any */\n\nvar validateTypes = function validateTypes() {\n  for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n    args[_key3] = arguments[_key3];\n  }\n  var finalRuleSet = convertRuleArguments(args);\n  return function (target, propertyKey, descriptor) {\n    if (typeof descriptor.value !== \"function\") {\n      throw new Error(\"The validateTypes decorator can only be applied to methods\");\n    }\n    var originalMethod = descriptor.value;\n    descriptor.value = function () {\n      for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n        args[_key4] = arguments[_key4];\n      }\n      runtimeTypeValidation(finalRuleSet, args);\n      return originalMethod.apply(this, args);\n    };\n  };\n};\nvar validateTypesAsync = function validateTypesAsync() {\n  for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {\n    args[_key5] = arguments[_key5];\n  }\n  var finalRuleSet = convertRuleArguments(args);\n  return function (target, propertyKey, descriptor) {\n    if (typeof descriptor.value !== \"function\") {\n      throw new Error(\"The validateTypesAsync decorator can only be applied to methods\");\n    }\n    var originalMethod = descriptor.value;\n    descriptor.value = function () {\n      for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {\n        args[_key6] = arguments[_key6];\n      }\n      try {\n        runtimeTypeValidation(finalRuleSet, args);\n      } catch (e) {\n        return Promise.reject(e);\n      }\n      return originalMethod.apply(this, args);\n    };\n  };\n};\nvar convertRuleArguments = function convertRuleArguments(args) {\n  var finalRuleDefinitionSet = [];\n  var _iterator2 = _createForOfIteratorHelper$1(args),\n    _step2;\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var arg = _step2.value;\n      finalRuleDefinitionSet.push(convertRuleArgument(arg));\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n  return finalRuleDefinitionSet;\n};\nvar convertRuleArgument = function convertRuleArgument(arg) {\n  var finalArgumentRuleDefinitions = [];\n  var declaredRules = Array.isArray(arg) ? arg : [arg];\n  var _iterator3 = _createForOfIteratorHelper$1(declaredRules),\n    _step3;\n  try {\n    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n      var rule = _step3.value;\n      if (typeof rule === \"string\" || typeof rule === \"function\") {\n        finalArgumentRuleDefinitions.push(type(rule));\n        continue;\n      }\n      finalArgumentRuleDefinitions.push(rule);\n    }\n  } catch (err) {\n    _iterator3.e(err);\n  } finally {\n    _iterator3.f();\n  }\n  return finalArgumentRuleDefinitions;\n};\nvar validateValue = function validateValue(ruleDefinitions, value) {\n  var expectedTypes = [];\n  var customReceivedType;\n  var isValid = false;\n  var _iterator4 = _createForOfIteratorHelper$1(ruleDefinitions),\n    _step4;\n  try {\n    for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n      var definition = _step4.value;\n      var _iterator5 = _createForOfIteratorHelper$1(definition.checks),\n        _step5;\n      try {\n        for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n          var check = _step5.value;\n          var _check = check(value),\n            _check2 = _slicedToArray__default['default'](_check, 3),\n            checkPassed = _check2[0],\n            typeDescription = _check2[1],\n            _receivedType = _check2[2];\n          isValid = isValid || checkPassed;\n          if (!customReceivedType && _receivedType) {\n            customReceivedType = _receivedType;\n          }\n          if (typeDescription) {\n            expectedTypes = typeof typeDescription === \"string\" ? [].concat(_toConsumableArray__default['default'](expectedTypes), [typeDescription]) : [].concat(_toConsumableArray__default['default'](expectedTypes), _toConsumableArray__default['default'](typeDescription));\n          }\n        }\n      } catch (err) {\n        _iterator5.e(err);\n      } finally {\n        _iterator5.f();\n      }\n    }\n  } catch (err) {\n    _iterator4.e(err);\n  } finally {\n    _iterator4.f();\n  }\n  if (isValid) {\n    return [true];\n  }\n  var receivedType = customReceivedType || stringifyReceivedType(value);\n  var lastIndex = expectedTypes.length - 1;\n  var expectedTypesString = lastIndex > 0 ? \"\".concat(expectedTypes.slice(0, lastIndex).join(\", \"), \" or \").concat(expectedTypes[lastIndex]) : expectedTypes.join(\", \");\n  return [false, receivedType, expectedTypesString, lastIndex > 1 ? \";\" : \",\"];\n};\nvar objectSchema = function objectSchema(name, schema) {\n  return custom(function (object) {\n    if (_typeof__default['default'](object) !== \"object\" || object === null || Array.isArray(object)) {\n      return [false, \"valid \".concat(name, \" (should be a pure object)\")];\n    }\n    for (var _i = 0, _Object$entries = Object.entries(schema); _i < _Object$entries.length; _i++) {\n      var _Object$entries$_i = _slicedToArray__default['default'](_Object$entries[_i], 2),\n        key = _Object$entries$_i[0],\n        rules = _Object$entries$_i[1];\n      var _validateValue = validateValue(convertRuleArgument(rules), object[key]),\n        _validateValue2 = _slicedToArray__default['default'](_validateValue, 3),\n        isValid = _validateValue2[0],\n        received = _validateValue2[1],\n        expected = _validateValue2[2];\n      if (!isValid) {\n        return [false, \"valid \".concat(name, \" (key \\\"\").concat(key, \"\\\" should be \").concat(expected, \")\"), \"malformed \".concat(name, \" (key \\\"\").concat(key, \"\\\" is \").concat(received, \")\")];\n      }\n    }\n    return [true];\n  });\n};\nfunction _createForOfIteratorHelper(o, allowArrayLike) {\n  var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"];\n  if (!it) {\n    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n      var F = function F() {};\n      return {\n        s: F,\n        n: function n() {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function e(_e) {\n          throw _e;\n        },\n        f: F\n      };\n    }\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n  var normalCompletion = true,\n    didErr = false,\n    err;\n  return {\n    s: function s() {\n      it = it.call(o);\n    },\n    n: function n() {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function e(_e2) {\n      didErr = true;\n      err = _e2;\n    },\n    f: function f() {\n      try {\n        if (!normalCompletion && it.return != null) it.return();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n  return arr2;\n}\nvar array = function array(name, rules) {\n  return custom(function (value) {\n    if (!Array.isArray(value)) {\n      return [false, \"an array of \".concat(name)];\n    }\n    var _iterator = _createForOfIteratorHelper(value.entries()),\n      _step;\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var _step$value = _slicedToArray__default['default'](_step.value, 2),\n          key = _step$value[0],\n          valueOfKey = _step$value[1];\n        var _validateValue = validateValue(convertRuleArgument(rules), valueOfKey),\n          _validateValue2 = _slicedToArray__default['default'](_validateValue, 3),\n          isValid = _validateValue2[0],\n          received = _validateValue2[1],\n          expected = _validateValue2[2];\n        if (!isValid) {\n          return [false, \"a valid array of \".concat(name, \" (index \").concat(key, \" should be \").concat(expected, \")\"), \"malformed array of \".concat(name, \" (index \").concat(key, \" is \").concat(received, \")\")];\n        }\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n    return [true];\n  });\n};\nexports.array = array;\nexports.custom = custom;\nexports.literal = literal;\nexports.nonEmptyString = nonEmptyString;\nexports.nonNegativeInteger = nonNegativeInteger;\nexports.objectSchema = objectSchema;\nexports.pureObject = pureObject;\nexports.runtimeTypeValidation = runtimeTypeValidation;\nexports.stringifyReceivedType = stringifyReceivedType;\nexports.type = type;\nexports.validateConstructorTypes = validateConstructorTypes;\nexports.validateTypes = validateTypes;\nexports.validateTypesAsync = validateTypesAsync;","map":{"version":3,"sources":["../src/rules/custom.ts","../src/rules/type.ts","../src/rules/literal.ts","../src/rules/non-empty-string.ts","../src/rules/non-negative-integer.ts","../src/rules/pure-object.ts","../src/type-validator.ts","../src/rules/object-schema.ts","../src/rules/array.ts"],"names":["_typeof"],"mappings":"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","sourcesContent":["import { RuleDefinition, RuleFunction } from \"../type-validator\";\n\nexport const custom = (...checks: RuleFunction[]): RuleDefinition => ({\n  checks,\n});\n","import { RuleDefinition, TypeRule } from \"../type-validator\";\nimport { custom } from \"./custom\";\n\nexport const type = (...checks: TypeRule[]): RuleDefinition =>\n  custom((value: unknown) => {\n    let isValid = false;\n    const expectedTypes: string[] = [];\n\n    for (const type of checks) {\n      if (typeof type === \"string\") {\n        isValid = isValid || typeof value === type;\n        expectedTypes.push(`of type ${type}`);\n\n        continue;\n      }\n\n      isValid = isValid || value instanceof type;\n      expectedTypes.push(`an instance of ${type.name}`);\n    }\n\n    return [isValid, expectedTypes];\n  });\n","import { RuleDefinition } from \"../type-validator\";\nimport { custom } from \"./custom\";\n\nexport const literal = (...checks: unknown[]): RuleDefinition =>\n  custom((value: unknown) => {\n    let isValid = false;\n    const expectedTypes = [];\n\n    for (const type of checks) {\n      isValid = isValid || value === type;\n      expectedTypes.push(typeof type === \"string\" ? `\"${type}\"` : `${type}`);\n    }\n\n    return [isValid, expectedTypes];\n  });\n","import { RuleDefinition } from \"../type-validator\";\nimport { custom } from \"./custom\";\n\nexport const nonEmptyString: RuleDefinition = custom((value) => [\n  typeof value === \"string\" && value.length > 0,\n  \"a non-empty string\",\n]);\n","import { RuleDefinition } from \"../type-validator\";\nimport { custom } from \"./custom\";\n\nexport const nonNegativeInteger: RuleDefinition = custom((value) => [\n  typeof value === \"number\" && Number.isInteger(value) && value >= 0,\n  \"a non-negative integer\",\n]);\n","import { RuleDefinition } from \"../type-validator\";\nimport { custom } from \"./custom\";\n\nexport const pureObject: RuleDefinition = custom((value) => [\n  typeof value === \"object\" && value !== null && !Array.isArray(value),\n  \"a pure object (non-null and non-array)\",\n]);\n","import { type } from \"./rules/type\";\n\nexport type TypeRule =\n  | \"undefined\"\n  | \"object\"\n  | \"boolean\"\n  | \"number\"\n  | \"bigint\"\n  | \"string\"\n  | \"symbol\"\n  | \"function\"\n  | { new (...args: unknown[]): unknown };\n\nexport type RuleFunction = (\n  value: unknown\n) => [boolean, (string | string[])?, string?];\n\nexport type RuleDefinition = {\n  checks: RuleFunction[];\n};\n\nexport type RuleArgument =\n  | TypeRule\n  | RuleDefinition\n  | (TypeRule | RuleDefinition)[];\n\ntype Decorator = (\n  target: unknown,\n  propertyKey: string,\n  descriptor: PropertyDescriptor\n) => void;\n\nexport const runtimeTypeValidation = (\n  rules: RuleDefinition[][],\n  values: unknown[]\n): void => {\n  if (values.length > rules.length) {\n    throw new Error(\n      `Expected at most ${rules.length} argument(s), but got ${values.length}`\n    );\n  }\n\n  while (values.length < rules.length) {\n    values.push(undefined);\n  }\n\n  for (const [index, value] of values.entries()) {\n    const [isValid, received, expected, delimeter] = validateValue(\n      rules[index],\n      value\n    );\n\n    if (isValid) {\n      continue;\n    }\n\n    const argumentIndex = index + 1;\n\n    throw new Error(\n      `Argument ${argumentIndex} is expected to be ${expected}${delimeter} but got ${received}`\n    );\n  }\n};\n\nexport const stringifyReceivedType = (value: unknown): string => {\n  let receivedType;\n  const types = [\"undefined\", \"boolean\", \"number\", \"bigint\", \"string\"];\n\n  if (types.includes(typeof value)) {\n    receivedType = typeof value === \"string\" ? `\"${value}\"` : `${value}`;\n  }\n\n  if (typeof value === \"object\" && value?.constructor?.name !== \"Object\") {\n    receivedType =\n      value === null ? \"null\" : `instance of ${value?.constructor?.name}`;\n  }\n\n  if (!receivedType) {\n    receivedType = typeof value;\n  }\n\n  return receivedType;\n};\n\n/* eslint-disable @typescript-eslint/no-explicit-any */\nexport const validateConstructorTypes = (\n  ...args: RuleArgument[]\n): (<T extends new (...args: any[]) => any>(ctor: T) => T) => {\n  const finalRuleSet = convertRuleArguments(args);\n\n  return <T extends { new (...args: any[]): any }>(ctor: T): T => {\n    return class extends ctor {\n      constructor(...args: any[]) {\n        runtimeTypeValidation(finalRuleSet, args);\n        super(...args);\n      }\n    };\n  };\n};\n/* eslint-enable @typescript-eslint/no-explicit-any */\n\nexport const validateTypes = (...args: RuleArgument[]): Decorator => {\n  const finalRuleSet = convertRuleArguments(args);\n\n  return (\n    target: unknown,\n    propertyKey: string,\n    descriptor: PropertyDescriptor\n  ) => {\n    if (typeof descriptor.value !== \"function\") {\n      throw new Error(\n        \"The validateTypes decorator can only be applied to methods\"\n      );\n    }\n\n    const originalMethod = descriptor.value;\n\n    descriptor.value = function (...args: unknown[]) {\n      runtimeTypeValidation(finalRuleSet, args);\n      return originalMethod.apply(this, args);\n    };\n  };\n};\n\nexport const validateTypesAsync = (...args: RuleArgument[]): Decorator => {\n  const finalRuleSet = convertRuleArguments(args);\n\n  return (\n    target: unknown,\n    propertyKey: string,\n    descriptor: PropertyDescriptor\n  ) => {\n    if (typeof descriptor.value !== \"function\") {\n      throw new Error(\n        \"The validateTypesAsync decorator can only be applied to methods\"\n      );\n    }\n\n    const originalMethod = descriptor.value;\n\n    descriptor.value = function (...args: unknown[]) {\n      try {\n        runtimeTypeValidation(finalRuleSet, args);\n      } catch (e) {\n        return Promise.reject<Error>(e);\n      }\n\n      return originalMethod.apply(this, args);\n    };\n  };\n};\n\nexport const convertRuleArguments = (\n  args: RuleArgument[]\n): RuleDefinition[][] => {\n  const finalRuleDefinitionSet: RuleDefinition[][] = [];\n\n  for (const arg of args) {\n    finalRuleDefinitionSet.push(convertRuleArgument(arg));\n  }\n\n  return finalRuleDefinitionSet;\n};\n\nexport const convertRuleArgument = (arg: RuleArgument): RuleDefinition[] => {\n  const finalArgumentRuleDefinitions: RuleDefinition[] = [];\n  const declaredRules = Array.isArray(arg) ? arg : [arg];\n\n  for (const rule of declaredRules) {\n    if (typeof rule === \"string\" || typeof rule === \"function\") {\n      finalArgumentRuleDefinitions.push(type(rule));\n      continue;\n    }\n\n    finalArgumentRuleDefinitions.push(rule);\n  }\n\n  return finalArgumentRuleDefinitions;\n};\n\nexport const validateValue = (\n  ruleDefinitions: RuleDefinition[],\n  value: unknown\n): [true] | [false, string, string, string] => {\n  let expectedTypes: string[] = [];\n  let customReceivedType: string | undefined;\n  let isValid = false;\n\n  for (const definition of ruleDefinitions) {\n    for (const check of definition.checks) {\n      const [checkPassed, typeDescription, receivedType] = check(value);\n      isValid = isValid || checkPassed;\n\n      if (!customReceivedType && receivedType) {\n        customReceivedType = receivedType;\n      }\n\n      if (typeDescription) {\n        expectedTypes =\n          typeof typeDescription === \"string\"\n            ? [...expectedTypes, typeDescription]\n            : [...expectedTypes, ...typeDescription];\n      }\n    }\n  }\n\n  if (isValid) {\n    return [true];\n  }\n\n  const receivedType = customReceivedType || stringifyReceivedType(value);\n  const lastIndex = expectedTypes.length - 1;\n  const expectedTypesString =\n    lastIndex > 0\n      ? `${expectedTypes.slice(0, lastIndex).join(\", \")} or ${\n          expectedTypes[lastIndex]\n        }`\n      : expectedTypes.join(\", \");\n\n  return [false, receivedType, expectedTypesString, lastIndex > 1 ? \";\" : \",\"];\n};\n","import {\n  convertRuleArgument,\n  RuleArgument,\n  RuleDefinition,\n  validateValue,\n} from \"../type-validator\";\nimport { custom } from \"./custom\";\n\nexport const objectSchema = (\n  name: string,\n  schema: Record<string, RuleArgument>\n): RuleDefinition =>\n  custom((object) => {\n    if (\n      typeof object !== \"object\" ||\n      object === null ||\n      Array.isArray(object)\n    ) {\n      return [false, `valid ${name} (should be a pure object)`];\n    }\n\n    for (const [key, rules] of Object.entries(schema)) {\n      const [isValid, received, expected] = validateValue(\n        convertRuleArgument(rules),\n        (object as Record<string, unknown>)[key]\n      );\n\n      if (!isValid) {\n        return [\n          false,\n          `valid ${name} (key \"${key}\" should be ${expected})`,\n          `malformed ${name} (key \"${key}\" is ${received})`,\n        ];\n      }\n    }\n\n    return [true];\n  });\n","import {\n  convertRuleArgument,\n  RuleArgument,\n  RuleDefinition,\n  validateValue,\n} from \"../type-validator\";\nimport { custom } from \"./custom\";\n\nexport const array = (name: string, rules: RuleArgument): RuleDefinition =>\n  custom((value) => {\n    if (!Array.isArray(value)) {\n      return [false, `an array of ${name}`];\n    }\n\n    for (const [key, valueOfKey] of value.entries()) {\n      const [isValid, received, expected] = validateValue(\n        convertRuleArgument(rules),\n        valueOfKey\n      );\n\n      if (!isValid) {\n        return [\n          false,\n          `a valid array of ${name} (index ${key} should be ${expected})`,\n          `malformed array of ${name} (index ${key} is ${received})`,\n        ];\n      }\n    }\n\n    return [true];\n  });\n"]},"metadata":{},"sourceType":"script"}